
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model TBEventReg_ACM2017
 * 
 */
export type TBEventReg_ACM2017 = {
  ID: number
  EventTitle: string | null
  RegName: string | null
  RegEmail: string | null
  RegTel: string | null
  RegAddress: string | null
  RegAffiliate: string | null
  RegPreamble: string
  RegQuestion: string
  RegDate: Date | null
  RegIP: string
}

/**
 * Model TBEventReg_ACM2018
 * 
 */
export type TBEventReg_ACM2018 = {
  ID: number
  EventTitle: string | null
  RegName: string | null
  RegEmail: string | null
  RegTel: string | null
  RegAddress: string | null
  RegAffiliate: string | null
  RegPreamble: string
  RegQuestion: string
  RegDate: Date | null
  RegIP: string
}

/**
 * Model TBEventReg_ACM2022
 * 
 */
export type TBEventReg_ACM2022 = {
  ID: number
  EventTitle: string | null
  RegName: string | null
  RegEmail: string | null
  RegTel: string | null
  RegAddress: string | null
  RegAffiliate: string | null
  RegPreamble: string
  RegQuestion: string
  RegDate: Date | null
  RegIP: string
}

/**
 * Model TBEventReg_ChessChampionship2019
 * 
 */
export type TBEventReg_ChessChampionship2019 = {
  ID: number
  EventTitle: string
  RegNameFirst: string
  RegNameLast: string
  RegDOB: Date
  RegEmail: string
  RegTel: string
  ParentNameFirst: string
  ParentNameLast: string
  ParentTel: string
  ParentEmail: string
  RegDate: Date
  RegIP: string
}

/**
 * Model TBEventReg_SEEE_2017
 * 
 */
export type TBEventReg_SEEE_2017 = {
  ID: number
  EventTitle: string
  RegName: string
  RegEmail: string
  RegTel: string
  RegAddress: string
  RegDate: Date
  RegIP: string
  RegLunch: string | null
}

/**
 * Model TBEventReg_SEEE_2017_VenderInfo
 * 
 */
export type TBEventReg_SEEE_2017_VenderInfo = {
  ID: number
  VenderCompTitle: string
  VenderResource: string
  VenderEmail: string
  VenderDescrip: string
  VenderBooth: string
  VenderTel: string
  AMorPM: string
  AM1: string
  AM2: string
  AM3: string
  AM4: string
  AM5: string
  AM6: string
  PM1: string
  PM2: string
  PM3: string
  PM4: string
  PM5: string
  PM6: string
}

/**
 * Model TBEventReg_SEEE_2018
 * 
 */
export type TBEventReg_SEEE_2018 = {
  ID: number
  EventTitle: string
  RegName: string
  RegEmail: string
  RegTel: string
  RegAddress: string
  RegDate: Date
  RegIP: string
  RegLunch: string | null
}

/**
 * Model TBEventReg_SEEE_2018_VenderInfo
 * 
 */
export type TBEventReg_SEEE_2018_VenderInfo = {
  ID: number
  VenderCompTitle: string
  VenderContactPerson: string
  VenderResource: string
  VenderEmail: string
  VenderDescrip: string
  VenderBooth: string
  VenderTel: string
  TimeSlot1: string
  TimeSlot2: string
  TimeSlot3: string
  TimeSlot4: string
  TimeSlot5: string
  TimeSlot6: string
  TimeSlot7: string
  TimeSlot8: string
  TimeSlot9: string
  TimeSlot10: string
}

/**
 * Model TBEventReg_SpringIntoAction
 * 
 */
export type TBEventReg_SpringIntoAction = {
  ID: number
  EventTitle: string | null
  RegName: string | null
  RegEmail: string | null
  RegTel: string | null
  RegAddress: string | null
  RegDate: Date | null
  RegIP: string
}

/**
 * Model TBInvisibleIllness2019
 * 
 */
export type TBInvisibleIllness2019 = {
  IndexID: number
  RegName: string
  RegEmail: string
  RegTel: string
  IfRCDMember: string
  RegDate: Date
  RegIP: string
}

/**
 * Model TB_2017Gala_Karaoka
 * 
 */
export type TB_2017Gala_Karaoka = {
  ID: number
  NominatorName: string
  NominatorTelEmail: string
  NomineeName: string
  NomineeTelEmail: string
  KaraokeName: string
  BringCD: string
  RegDateTime: Date
}

/**
 * Model Tbl_barrage_ILAcrossCanadaDay2023
 * 
 */
export type Tbl_barrage_ILAcrossCanadaDay2023 = {
  barrage_id: number
  barrage_content: string
  createdAt: Date
}

/**
 * Model auth_group
 * 
 */
export type auth_group = {
  id: number
  name: string
}

/**
 * Model auth_group_permissions
 * 
 */
export type auth_group_permissions = {
  id: bigint
  group_id: number
  permission_id: number
}

/**
 * Model auth_permission
 * 
 */
export type auth_permission = {
  id: number
  name: string
  content_type_id: number
  codename: string
}

/**
 * Model auth_user
 * 
 */
export type auth_user = {
  id: number
  password: string
  last_login: Date | null
  is_superuser: boolean
  username: string
  first_name: string
  last_name: string
  email: string
  is_staff: boolean
  is_active: boolean
  date_joined: Date
}

/**
 * Model auth_user_groups
 * 
 */
export type auth_user_groups = {
  id: bigint
  user_id: number
  group_id: number
}

/**
 * Model auth_user_user_permissions
 * 
 */
export type auth_user_user_permissions = {
  id: bigint
  user_id: number
  permission_id: number
}

/**
 * Model categoryList
 * 
 */
export type categoryList = {
  categorytype: string | null
  hide: number | null
  categoryID: number
}

/**
 * Model django_admin_log
 * 
 */
export type django_admin_log = {
  id: number
  action_time: Date
  object_id: string | null
  object_repr: string
  action_flag: number
  change_message: string
  content_type_id: number | null
  user_id: number
}

/**
 * Model django_content_type
 * 
 */
export type django_content_type = {
  id: number
  app_label: string
  model: string
}

/**
 * Model django_migrations
 * 
 */
export type django_migrations = {
  id: bigint
  app: string
  name: string
  applied: Date
}

/**
 * Model django_session
 * 
 */
export type django_session = {
  session_key: string
  session_data: string
  expire_date: Date
}

/**
 * Model events
 * 
 */
export type events = {
  id: number
  title: string
  color: string | null
  start: Date
  end: Date | null
}

/**
 * Model recordInfo
 * 
 */
export type recordInfo = {
  recordInfo_ID: number
  categoryID: number | null
  Name: string | null
  StreetAddress: string | null
  City: string | null
  PostalCode: string | null
  Province: string | null
  Telephone: string | null
  Fax: string | null
  Website: string | null
}

/**
 * Model tbl_BMORun2024_Barrage
 * 
 */
export type tbl_BMORun2024_Barrage = {
  ID: number
  donor_Fname: string | null
  donor_Lname: string | null
  donor_Org: string | null
  donor_Amount: Prisma.Decimal | null
  createdAt: string
}

/**
 * Model tbl_ETransferInfo
 * 
 */
export type tbl_ETransferInfo = {
  id: number
  fname: string
  lname: string
  userAddress: string
  userTel: string
  useremail: string
  todaydate: Date
  RegDate: Date
  RegTime: Date
  userIP: string
}

/**
 * Model tbl_TshirtContest
 * 
 */
export type tbl_TshirtContest = {
  id: number
  fname: string
  lname: string
  tel: string
  email: string
  notes: string
  artwork: string
  imgPreview: string
  ip: string
  submitTime: Date
}

/**
 * Model tbl_barrage_at_us_2023
 * 
 */
export type tbl_barrage_at_us_2023 = {
  id: number
  barrageContent: string
}

/**
 * Model tbl_next_auth
 * 
 */
export type tbl_next_auth = {
  id: number
  username: string
  password: string
  email: string
  isVerified: boolean
  isAdmin: boolean
}

/**
 * Model tbl_onlineconcert2022_donors
 * 
 */
export type tbl_onlineconcert2022_donors = {
  donor_id: number
  donor_fname: string
  donor_lname: string
  donor_amount: number
}

/**
 * Model users
 * 
 */
export type users = {
  Username: string
  Password: string
  id: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more TBEventReg_ACM2017s
 * const tBEventReg_ACM2017s = await prisma.tBEventReg_ACM2017.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more TBEventReg_ACM2017s
   * const tBEventReg_ACM2017s = await prisma.tBEventReg_ACM2017.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.tBEventReg_ACM2017`: Exposes CRUD operations for the **TBEventReg_ACM2017** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TBEventReg_ACM2017s
    * const tBEventReg_ACM2017s = await prisma.tBEventReg_ACM2017.findMany()
    * ```
    */
  get tBEventReg_ACM2017(): Prisma.TBEventReg_ACM2017Delegate<GlobalReject>;

  /**
   * `prisma.tBEventReg_ACM2018`: Exposes CRUD operations for the **TBEventReg_ACM2018** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TBEventReg_ACM2018s
    * const tBEventReg_ACM2018s = await prisma.tBEventReg_ACM2018.findMany()
    * ```
    */
  get tBEventReg_ACM2018(): Prisma.TBEventReg_ACM2018Delegate<GlobalReject>;

  /**
   * `prisma.tBEventReg_ACM2022`: Exposes CRUD operations for the **TBEventReg_ACM2022** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TBEventReg_ACM2022s
    * const tBEventReg_ACM2022s = await prisma.tBEventReg_ACM2022.findMany()
    * ```
    */
  get tBEventReg_ACM2022(): Prisma.TBEventReg_ACM2022Delegate<GlobalReject>;

  /**
   * `prisma.tBEventReg_ChessChampionship2019`: Exposes CRUD operations for the **TBEventReg_ChessChampionship2019** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TBEventReg_ChessChampionship2019s
    * const tBEventReg_ChessChampionship2019s = await prisma.tBEventReg_ChessChampionship2019.findMany()
    * ```
    */
  get tBEventReg_ChessChampionship2019(): Prisma.TBEventReg_ChessChampionship2019Delegate<GlobalReject>;

  /**
   * `prisma.tBEventReg_SEEE_2017`: Exposes CRUD operations for the **TBEventReg_SEEE_2017** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TBEventReg_SEEE_2017s
    * const tBEventReg_SEEE_2017s = await prisma.tBEventReg_SEEE_2017.findMany()
    * ```
    */
  get tBEventReg_SEEE_2017(): Prisma.TBEventReg_SEEE_2017Delegate<GlobalReject>;

  /**
   * `prisma.tBEventReg_SEEE_2017_VenderInfo`: Exposes CRUD operations for the **TBEventReg_SEEE_2017_VenderInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TBEventReg_SEEE_2017_VenderInfos
    * const tBEventReg_SEEE_2017_VenderInfos = await prisma.tBEventReg_SEEE_2017_VenderInfo.findMany()
    * ```
    */
  get tBEventReg_SEEE_2017_VenderInfo(): Prisma.TBEventReg_SEEE_2017_VenderInfoDelegate<GlobalReject>;

  /**
   * `prisma.tBEventReg_SEEE_2018`: Exposes CRUD operations for the **TBEventReg_SEEE_2018** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TBEventReg_SEEE_2018s
    * const tBEventReg_SEEE_2018s = await prisma.tBEventReg_SEEE_2018.findMany()
    * ```
    */
  get tBEventReg_SEEE_2018(): Prisma.TBEventReg_SEEE_2018Delegate<GlobalReject>;

  /**
   * `prisma.tBEventReg_SEEE_2018_VenderInfo`: Exposes CRUD operations for the **TBEventReg_SEEE_2018_VenderInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TBEventReg_SEEE_2018_VenderInfos
    * const tBEventReg_SEEE_2018_VenderInfos = await prisma.tBEventReg_SEEE_2018_VenderInfo.findMany()
    * ```
    */
  get tBEventReg_SEEE_2018_VenderInfo(): Prisma.TBEventReg_SEEE_2018_VenderInfoDelegate<GlobalReject>;

  /**
   * `prisma.tBEventReg_SpringIntoAction`: Exposes CRUD operations for the **TBEventReg_SpringIntoAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TBEventReg_SpringIntoActions
    * const tBEventReg_SpringIntoActions = await prisma.tBEventReg_SpringIntoAction.findMany()
    * ```
    */
  get tBEventReg_SpringIntoAction(): Prisma.TBEventReg_SpringIntoActionDelegate<GlobalReject>;

  /**
   * `prisma.tBInvisibleIllness2019`: Exposes CRUD operations for the **TBInvisibleIllness2019** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TBInvisibleIllness2019s
    * const tBInvisibleIllness2019s = await prisma.tBInvisibleIllness2019.findMany()
    * ```
    */
  get tBInvisibleIllness2019(): Prisma.TBInvisibleIllness2019Delegate<GlobalReject>;

  /**
   * `prisma.tB_2017Gala_Karaoka`: Exposes CRUD operations for the **TB_2017Gala_Karaoka** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TB_2017Gala_Karaokas
    * const tB_2017Gala_Karaokas = await prisma.tB_2017Gala_Karaoka.findMany()
    * ```
    */
  get tB_2017Gala_Karaoka(): Prisma.TB_2017Gala_KaraokaDelegate<GlobalReject>;

  /**
   * `prisma.tbl_barrage_ILAcrossCanadaDay2023`: Exposes CRUD operations for the **Tbl_barrage_ILAcrossCanadaDay2023** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tbl_barrage_ILAcrossCanadaDay2023s
    * const tbl_barrage_ILAcrossCanadaDay2023s = await prisma.tbl_barrage_ILAcrossCanadaDay2023.findMany()
    * ```
    */
  get tbl_barrage_ILAcrossCanadaDay2023(): Prisma.Tbl_barrage_ILAcrossCanadaDay2023Delegate<GlobalReject>;

  /**
   * `prisma.auth_group`: Exposes CRUD operations for the **auth_group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auth_groups
    * const auth_groups = await prisma.auth_group.findMany()
    * ```
    */
  get auth_group(): Prisma.auth_groupDelegate<GlobalReject>;

  /**
   * `prisma.auth_group_permissions`: Exposes CRUD operations for the **auth_group_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auth_group_permissions
    * const auth_group_permissions = await prisma.auth_group_permissions.findMany()
    * ```
    */
  get auth_group_permissions(): Prisma.auth_group_permissionsDelegate<GlobalReject>;

  /**
   * `prisma.auth_permission`: Exposes CRUD operations for the **auth_permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auth_permissions
    * const auth_permissions = await prisma.auth_permission.findMany()
    * ```
    */
  get auth_permission(): Prisma.auth_permissionDelegate<GlobalReject>;

  /**
   * `prisma.auth_user`: Exposes CRUD operations for the **auth_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auth_users
    * const auth_users = await prisma.auth_user.findMany()
    * ```
    */
  get auth_user(): Prisma.auth_userDelegate<GlobalReject>;

  /**
   * `prisma.auth_user_groups`: Exposes CRUD operations for the **auth_user_groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auth_user_groups
    * const auth_user_groups = await prisma.auth_user_groups.findMany()
    * ```
    */
  get auth_user_groups(): Prisma.auth_user_groupsDelegate<GlobalReject>;

  /**
   * `prisma.auth_user_user_permissions`: Exposes CRUD operations for the **auth_user_user_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auth_user_user_permissions
    * const auth_user_user_permissions = await prisma.auth_user_user_permissions.findMany()
    * ```
    */
  get auth_user_user_permissions(): Prisma.auth_user_user_permissionsDelegate<GlobalReject>;

  /**
   * `prisma.categoryList`: Exposes CRUD operations for the **categoryList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoryLists
    * const categoryLists = await prisma.categoryList.findMany()
    * ```
    */
  get categoryList(): Prisma.categoryListDelegate<GlobalReject>;

  /**
   * `prisma.django_admin_log`: Exposes CRUD operations for the **django_admin_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Django_admin_logs
    * const django_admin_logs = await prisma.django_admin_log.findMany()
    * ```
    */
  get django_admin_log(): Prisma.django_admin_logDelegate<GlobalReject>;

  /**
   * `prisma.django_content_type`: Exposes CRUD operations for the **django_content_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Django_content_types
    * const django_content_types = await prisma.django_content_type.findMany()
    * ```
    */
  get django_content_type(): Prisma.django_content_typeDelegate<GlobalReject>;

  /**
   * `prisma.django_migrations`: Exposes CRUD operations for the **django_migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Django_migrations
    * const django_migrations = await prisma.django_migrations.findMany()
    * ```
    */
  get django_migrations(): Prisma.django_migrationsDelegate<GlobalReject>;

  /**
   * `prisma.django_session`: Exposes CRUD operations for the **django_session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Django_sessions
    * const django_sessions = await prisma.django_session.findMany()
    * ```
    */
  get django_session(): Prisma.django_sessionDelegate<GlobalReject>;

  /**
   * `prisma.events`: Exposes CRUD operations for the **events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.events.findMany()
    * ```
    */
  get events(): Prisma.eventsDelegate<GlobalReject>;

  /**
   * `prisma.recordInfo`: Exposes CRUD operations for the **recordInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecordInfos
    * const recordInfos = await prisma.recordInfo.findMany()
    * ```
    */
  get recordInfo(): Prisma.recordInfoDelegate<GlobalReject>;

  /**
   * `prisma.tbl_BMORun2024_Barrage`: Exposes CRUD operations for the **tbl_BMORun2024_Barrage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tbl_BMORun2024_Barrages
    * const tbl_BMORun2024_Barrages = await prisma.tbl_BMORun2024_Barrage.findMany()
    * ```
    */
  get tbl_BMORun2024_Barrage(): Prisma.tbl_BMORun2024_BarrageDelegate<GlobalReject>;

  /**
   * `prisma.tbl_ETransferInfo`: Exposes CRUD operations for the **tbl_ETransferInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tbl_ETransferInfos
    * const tbl_ETransferInfos = await prisma.tbl_ETransferInfo.findMany()
    * ```
    */
  get tbl_ETransferInfo(): Prisma.tbl_ETransferInfoDelegate<GlobalReject>;

  /**
   * `prisma.tbl_TshirtContest`: Exposes CRUD operations for the **tbl_TshirtContest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tbl_TshirtContests
    * const tbl_TshirtContests = await prisma.tbl_TshirtContest.findMany()
    * ```
    */
  get tbl_TshirtContest(): Prisma.tbl_TshirtContestDelegate<GlobalReject>;

  /**
   * `prisma.tbl_barrage_at_us_2023`: Exposes CRUD operations for the **tbl_barrage_at_us_2023** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tbl_barrage_at_us_2023s
    * const tbl_barrage_at_us_2023s = await prisma.tbl_barrage_at_us_2023.findMany()
    * ```
    */
  get tbl_barrage_at_us_2023(): Prisma.tbl_barrage_at_us_2023Delegate<GlobalReject>;

  /**
   * `prisma.tbl_next_auth`: Exposes CRUD operations for the **tbl_next_auth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tbl_next_auths
    * const tbl_next_auths = await prisma.tbl_next_auth.findMany()
    * ```
    */
  get tbl_next_auth(): Prisma.tbl_next_authDelegate<GlobalReject>;

  /**
   * `prisma.tbl_onlineconcert2022_donors`: Exposes CRUD operations for the **tbl_onlineconcert2022_donors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tbl_onlineconcert2022_donors
    * const tbl_onlineconcert2022_donors = await prisma.tbl_onlineconcert2022_donors.findMany()
    * ```
    */
  get tbl_onlineconcert2022_donors(): Prisma.tbl_onlineconcert2022_donorsDelegate<GlobalReject>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.14.1
   * Query Engine version: b9a39a7ee606c28e3455d0fd60e78c3ba82b1a2b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    TBEventReg_ACM2017: 'TBEventReg_ACM2017',
    TBEventReg_ACM2018: 'TBEventReg_ACM2018',
    TBEventReg_ACM2022: 'TBEventReg_ACM2022',
    TBEventReg_ChessChampionship2019: 'TBEventReg_ChessChampionship2019',
    TBEventReg_SEEE_2017: 'TBEventReg_SEEE_2017',
    TBEventReg_SEEE_2017_VenderInfo: 'TBEventReg_SEEE_2017_VenderInfo',
    TBEventReg_SEEE_2018: 'TBEventReg_SEEE_2018',
    TBEventReg_SEEE_2018_VenderInfo: 'TBEventReg_SEEE_2018_VenderInfo',
    TBEventReg_SpringIntoAction: 'TBEventReg_SpringIntoAction',
    TBInvisibleIllness2019: 'TBInvisibleIllness2019',
    TB_2017Gala_Karaoka: 'TB_2017Gala_Karaoka',
    Tbl_barrage_ILAcrossCanadaDay2023: 'Tbl_barrage_ILAcrossCanadaDay2023',
    auth_group: 'auth_group',
    auth_group_permissions: 'auth_group_permissions',
    auth_permission: 'auth_permission',
    auth_user: 'auth_user',
    auth_user_groups: 'auth_user_groups',
    auth_user_user_permissions: 'auth_user_user_permissions',
    categoryList: 'categoryList',
    django_admin_log: 'django_admin_log',
    django_content_type: 'django_content_type',
    django_migrations: 'django_migrations',
    django_session: 'django_session',
    events: 'events',
    recordInfo: 'recordInfo',
    tbl_BMORun2024_Barrage: 'tbl_BMORun2024_Barrage',
    tbl_ETransferInfo: 'tbl_ETransferInfo',
    tbl_TshirtContest: 'tbl_TshirtContest',
    tbl_barrage_at_us_2023: 'tbl_barrage_at_us_2023',
    tbl_next_auth: 'tbl_next_auth',
    tbl_onlineconcert2022_donors: 'tbl_onlineconcert2022_donors',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Auth_groupCountOutputType
   */


  export type Auth_groupCountOutputType = {
    auth_group_permissions: number
    auth_user_groups: number
  }

  export type Auth_groupCountOutputTypeSelect = {
    auth_group_permissions?: boolean | Auth_groupCountOutputTypeCountAuth_group_permissionsArgs
    auth_user_groups?: boolean | Auth_groupCountOutputTypeCountAuth_user_groupsArgs
  }

  export type Auth_groupCountOutputTypeGetPayload<S extends boolean | null | undefined | Auth_groupCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Auth_groupCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Auth_groupCountOutputTypeArgs)
    ? Auth_groupCountOutputType 
    : S extends { select: any } & (Auth_groupCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Auth_groupCountOutputType ? Auth_groupCountOutputType[P] : never
  } 
      : Auth_groupCountOutputType




  // Custom InputTypes

  /**
   * Auth_groupCountOutputType without action
   */
  export type Auth_groupCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Auth_groupCountOutputType
     */
    select?: Auth_groupCountOutputTypeSelect | null
  }


  /**
   * Auth_groupCountOutputType without action
   */
  export type Auth_groupCountOutputTypeCountAuth_group_permissionsArgs = {
    where?: auth_group_permissionsWhereInput
  }


  /**
   * Auth_groupCountOutputType without action
   */
  export type Auth_groupCountOutputTypeCountAuth_user_groupsArgs = {
    where?: auth_user_groupsWhereInput
  }



  /**
   * Count Type Auth_permissionCountOutputType
   */


  export type Auth_permissionCountOutputType = {
    auth_group_permissions: number
    auth_user_user_permissions: number
  }

  export type Auth_permissionCountOutputTypeSelect = {
    auth_group_permissions?: boolean | Auth_permissionCountOutputTypeCountAuth_group_permissionsArgs
    auth_user_user_permissions?: boolean | Auth_permissionCountOutputTypeCountAuth_user_user_permissionsArgs
  }

  export type Auth_permissionCountOutputTypeGetPayload<S extends boolean | null | undefined | Auth_permissionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Auth_permissionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Auth_permissionCountOutputTypeArgs)
    ? Auth_permissionCountOutputType 
    : S extends { select: any } & (Auth_permissionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Auth_permissionCountOutputType ? Auth_permissionCountOutputType[P] : never
  } 
      : Auth_permissionCountOutputType




  // Custom InputTypes

  /**
   * Auth_permissionCountOutputType without action
   */
  export type Auth_permissionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Auth_permissionCountOutputType
     */
    select?: Auth_permissionCountOutputTypeSelect | null
  }


  /**
   * Auth_permissionCountOutputType without action
   */
  export type Auth_permissionCountOutputTypeCountAuth_group_permissionsArgs = {
    where?: auth_group_permissionsWhereInput
  }


  /**
   * Auth_permissionCountOutputType without action
   */
  export type Auth_permissionCountOutputTypeCountAuth_user_user_permissionsArgs = {
    where?: auth_user_user_permissionsWhereInput
  }



  /**
   * Count Type Auth_userCountOutputType
   */


  export type Auth_userCountOutputType = {
    auth_user_groups: number
    auth_user_user_permissions: number
    django_admin_log: number
  }

  export type Auth_userCountOutputTypeSelect = {
    auth_user_groups?: boolean | Auth_userCountOutputTypeCountAuth_user_groupsArgs
    auth_user_user_permissions?: boolean | Auth_userCountOutputTypeCountAuth_user_user_permissionsArgs
    django_admin_log?: boolean | Auth_userCountOutputTypeCountDjango_admin_logArgs
  }

  export type Auth_userCountOutputTypeGetPayload<S extends boolean | null | undefined | Auth_userCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Auth_userCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Auth_userCountOutputTypeArgs)
    ? Auth_userCountOutputType 
    : S extends { select: any } & (Auth_userCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Auth_userCountOutputType ? Auth_userCountOutputType[P] : never
  } 
      : Auth_userCountOutputType




  // Custom InputTypes

  /**
   * Auth_userCountOutputType without action
   */
  export type Auth_userCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Auth_userCountOutputType
     */
    select?: Auth_userCountOutputTypeSelect | null
  }


  /**
   * Auth_userCountOutputType without action
   */
  export type Auth_userCountOutputTypeCountAuth_user_groupsArgs = {
    where?: auth_user_groupsWhereInput
  }


  /**
   * Auth_userCountOutputType without action
   */
  export type Auth_userCountOutputTypeCountAuth_user_user_permissionsArgs = {
    where?: auth_user_user_permissionsWhereInput
  }


  /**
   * Auth_userCountOutputType without action
   */
  export type Auth_userCountOutputTypeCountDjango_admin_logArgs = {
    where?: django_admin_logWhereInput
  }



  /**
   * Count Type Django_content_typeCountOutputType
   */


  export type Django_content_typeCountOutputType = {
    auth_permission: number
    django_admin_log: number
  }

  export type Django_content_typeCountOutputTypeSelect = {
    auth_permission?: boolean | Django_content_typeCountOutputTypeCountAuth_permissionArgs
    django_admin_log?: boolean | Django_content_typeCountOutputTypeCountDjango_admin_logArgs
  }

  export type Django_content_typeCountOutputTypeGetPayload<S extends boolean | null | undefined | Django_content_typeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Django_content_typeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Django_content_typeCountOutputTypeArgs)
    ? Django_content_typeCountOutputType 
    : S extends { select: any } & (Django_content_typeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Django_content_typeCountOutputType ? Django_content_typeCountOutputType[P] : never
  } 
      : Django_content_typeCountOutputType




  // Custom InputTypes

  /**
   * Django_content_typeCountOutputType without action
   */
  export type Django_content_typeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Django_content_typeCountOutputType
     */
    select?: Django_content_typeCountOutputTypeSelect | null
  }


  /**
   * Django_content_typeCountOutputType without action
   */
  export type Django_content_typeCountOutputTypeCountAuth_permissionArgs = {
    where?: auth_permissionWhereInput
  }


  /**
   * Django_content_typeCountOutputType without action
   */
  export type Django_content_typeCountOutputTypeCountDjango_admin_logArgs = {
    where?: django_admin_logWhereInput
  }



  /**
   * Models
   */

  /**
   * Model TBEventReg_ACM2017
   */


  export type AggregateTBEventReg_ACM2017 = {
    _count: TBEventReg_ACM2017CountAggregateOutputType | null
    _avg: TBEventReg_ACM2017AvgAggregateOutputType | null
    _sum: TBEventReg_ACM2017SumAggregateOutputType | null
    _min: TBEventReg_ACM2017MinAggregateOutputType | null
    _max: TBEventReg_ACM2017MaxAggregateOutputType | null
  }

  export type TBEventReg_ACM2017AvgAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_ACM2017SumAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_ACM2017MinAggregateOutputType = {
    ID: number | null
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegAffiliate: string | null
    RegPreamble: string | null
    RegQuestion: string | null
    RegDate: Date | null
    RegIP: string | null
  }

  export type TBEventReg_ACM2017MaxAggregateOutputType = {
    ID: number | null
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegAffiliate: string | null
    RegPreamble: string | null
    RegQuestion: string | null
    RegDate: Date | null
    RegIP: string | null
  }

  export type TBEventReg_ACM2017CountAggregateOutputType = {
    ID: number
    EventTitle: number
    RegName: number
    RegEmail: number
    RegTel: number
    RegAddress: number
    RegAffiliate: number
    RegPreamble: number
    RegQuestion: number
    RegDate: number
    RegIP: number
    _all: number
  }


  export type TBEventReg_ACM2017AvgAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_ACM2017SumAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_ACM2017MinAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegAffiliate?: true
    RegPreamble?: true
    RegQuestion?: true
    RegDate?: true
    RegIP?: true
  }

  export type TBEventReg_ACM2017MaxAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegAffiliate?: true
    RegPreamble?: true
    RegQuestion?: true
    RegDate?: true
    RegIP?: true
  }

  export type TBEventReg_ACM2017CountAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegAffiliate?: true
    RegPreamble?: true
    RegQuestion?: true
    RegDate?: true
    RegIP?: true
    _all?: true
  }

  export type TBEventReg_ACM2017AggregateArgs = {
    /**
     * Filter which TBEventReg_ACM2017 to aggregate.
     */
    where?: TBEventReg_ACM2017WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ACM2017s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ACM2017OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TBEventReg_ACM2017WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ACM2017s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ACM2017s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TBEventReg_ACM2017s
    **/
    _count?: true | TBEventReg_ACM2017CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TBEventReg_ACM2017AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TBEventReg_ACM2017SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TBEventReg_ACM2017MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TBEventReg_ACM2017MaxAggregateInputType
  }

  export type GetTBEventReg_ACM2017AggregateType<T extends TBEventReg_ACM2017AggregateArgs> = {
        [P in keyof T & keyof AggregateTBEventReg_ACM2017]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTBEventReg_ACM2017[P]>
      : GetScalarType<T[P], AggregateTBEventReg_ACM2017[P]>
  }




  export type TBEventReg_ACM2017GroupByArgs = {
    where?: TBEventReg_ACM2017WhereInput
    orderBy?: Enumerable<TBEventReg_ACM2017OrderByWithAggregationInput>
    by: TBEventReg_ACM2017ScalarFieldEnum[]
    having?: TBEventReg_ACM2017ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TBEventReg_ACM2017CountAggregateInputType | true
    _avg?: TBEventReg_ACM2017AvgAggregateInputType
    _sum?: TBEventReg_ACM2017SumAggregateInputType
    _min?: TBEventReg_ACM2017MinAggregateInputType
    _max?: TBEventReg_ACM2017MaxAggregateInputType
  }


  export type TBEventReg_ACM2017GroupByOutputType = {
    ID: number
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegAffiliate: string | null
    RegPreamble: string
    RegQuestion: string
    RegDate: Date | null
    RegIP: string
    _count: TBEventReg_ACM2017CountAggregateOutputType | null
    _avg: TBEventReg_ACM2017AvgAggregateOutputType | null
    _sum: TBEventReg_ACM2017SumAggregateOutputType | null
    _min: TBEventReg_ACM2017MinAggregateOutputType | null
    _max: TBEventReg_ACM2017MaxAggregateOutputType | null
  }

  type GetTBEventReg_ACM2017GroupByPayload<T extends TBEventReg_ACM2017GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TBEventReg_ACM2017GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TBEventReg_ACM2017GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TBEventReg_ACM2017GroupByOutputType[P]>
            : GetScalarType<T[P], TBEventReg_ACM2017GroupByOutputType[P]>
        }
      >
    >


  export type TBEventReg_ACM2017Select = {
    ID?: boolean
    EventTitle?: boolean
    RegName?: boolean
    RegEmail?: boolean
    RegTel?: boolean
    RegAddress?: boolean
    RegAffiliate?: boolean
    RegPreamble?: boolean
    RegQuestion?: boolean
    RegDate?: boolean
    RegIP?: boolean
  }


  export type TBEventReg_ACM2017GetPayload<S extends boolean | null | undefined | TBEventReg_ACM2017Args> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TBEventReg_ACM2017 :
    S extends undefined ? never :
    S extends { include: any } & (TBEventReg_ACM2017Args | TBEventReg_ACM2017FindManyArgs)
    ? TBEventReg_ACM2017 
    : S extends { select: any } & (TBEventReg_ACM2017Args | TBEventReg_ACM2017FindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TBEventReg_ACM2017 ? TBEventReg_ACM2017[P] : never
  } 
      : TBEventReg_ACM2017


  type TBEventReg_ACM2017CountArgs = 
    Omit<TBEventReg_ACM2017FindManyArgs, 'select' | 'include'> & {
      select?: TBEventReg_ACM2017CountAggregateInputType | true
    }

  export interface TBEventReg_ACM2017Delegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TBEventReg_ACM2017 that matches the filter.
     * @param {TBEventReg_ACM2017FindUniqueArgs} args - Arguments to find a TBEventReg_ACM2017
     * @example
     * // Get one TBEventReg_ACM2017
     * const tBEventReg_ACM2017 = await prisma.tBEventReg_ACM2017.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TBEventReg_ACM2017FindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TBEventReg_ACM2017FindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TBEventReg_ACM2017'> extends True ? Prisma__TBEventReg_ACM2017Client<TBEventReg_ACM2017GetPayload<T>> : Prisma__TBEventReg_ACM2017Client<TBEventReg_ACM2017GetPayload<T> | null, null>

    /**
     * Find one TBEventReg_ACM2017 that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TBEventReg_ACM2017FindUniqueOrThrowArgs} args - Arguments to find a TBEventReg_ACM2017
     * @example
     * // Get one TBEventReg_ACM2017
     * const tBEventReg_ACM2017 = await prisma.tBEventReg_ACM2017.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TBEventReg_ACM2017FindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_ACM2017FindUniqueOrThrowArgs>
    ): Prisma__TBEventReg_ACM2017Client<TBEventReg_ACM2017GetPayload<T>>

    /**
     * Find the first TBEventReg_ACM2017 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2017FindFirstArgs} args - Arguments to find a TBEventReg_ACM2017
     * @example
     * // Get one TBEventReg_ACM2017
     * const tBEventReg_ACM2017 = await prisma.tBEventReg_ACM2017.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TBEventReg_ACM2017FindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TBEventReg_ACM2017FindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TBEventReg_ACM2017'> extends True ? Prisma__TBEventReg_ACM2017Client<TBEventReg_ACM2017GetPayload<T>> : Prisma__TBEventReg_ACM2017Client<TBEventReg_ACM2017GetPayload<T> | null, null>

    /**
     * Find the first TBEventReg_ACM2017 that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2017FindFirstOrThrowArgs} args - Arguments to find a TBEventReg_ACM2017
     * @example
     * // Get one TBEventReg_ACM2017
     * const tBEventReg_ACM2017 = await prisma.tBEventReg_ACM2017.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TBEventReg_ACM2017FindFirstOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_ACM2017FindFirstOrThrowArgs>
    ): Prisma__TBEventReg_ACM2017Client<TBEventReg_ACM2017GetPayload<T>>

    /**
     * Find zero or more TBEventReg_ACM2017s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2017FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TBEventReg_ACM2017s
     * const tBEventReg_ACM2017s = await prisma.tBEventReg_ACM2017.findMany()
     * 
     * // Get first 10 TBEventReg_ACM2017s
     * const tBEventReg_ACM2017s = await prisma.tBEventReg_ACM2017.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tBEventReg_ACM2017WithIDOnly = await prisma.tBEventReg_ACM2017.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends TBEventReg_ACM2017FindManyArgs>(
      args?: SelectSubset<T, TBEventReg_ACM2017FindManyArgs>
    ): Prisma.PrismaPromise<Array<TBEventReg_ACM2017GetPayload<T>>>

    /**
     * Create a TBEventReg_ACM2017.
     * @param {TBEventReg_ACM2017CreateArgs} args - Arguments to create a TBEventReg_ACM2017.
     * @example
     * // Create one TBEventReg_ACM2017
     * const TBEventReg_ACM2017 = await prisma.tBEventReg_ACM2017.create({
     *   data: {
     *     // ... data to create a TBEventReg_ACM2017
     *   }
     * })
     * 
    **/
    create<T extends TBEventReg_ACM2017CreateArgs>(
      args: SelectSubset<T, TBEventReg_ACM2017CreateArgs>
    ): Prisma__TBEventReg_ACM2017Client<TBEventReg_ACM2017GetPayload<T>>

    /**
     * Create many TBEventReg_ACM2017s.
     *     @param {TBEventReg_ACM2017CreateManyArgs} args - Arguments to create many TBEventReg_ACM2017s.
     *     @example
     *     // Create many TBEventReg_ACM2017s
     *     const tBEventReg_ACM2017 = await prisma.tBEventReg_ACM2017.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TBEventReg_ACM2017CreateManyArgs>(
      args?: SelectSubset<T, TBEventReg_ACM2017CreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TBEventReg_ACM2017.
     * @param {TBEventReg_ACM2017DeleteArgs} args - Arguments to delete one TBEventReg_ACM2017.
     * @example
     * // Delete one TBEventReg_ACM2017
     * const TBEventReg_ACM2017 = await prisma.tBEventReg_ACM2017.delete({
     *   where: {
     *     // ... filter to delete one TBEventReg_ACM2017
     *   }
     * })
     * 
    **/
    delete<T extends TBEventReg_ACM2017DeleteArgs>(
      args: SelectSubset<T, TBEventReg_ACM2017DeleteArgs>
    ): Prisma__TBEventReg_ACM2017Client<TBEventReg_ACM2017GetPayload<T>>

    /**
     * Update one TBEventReg_ACM2017.
     * @param {TBEventReg_ACM2017UpdateArgs} args - Arguments to update one TBEventReg_ACM2017.
     * @example
     * // Update one TBEventReg_ACM2017
     * const tBEventReg_ACM2017 = await prisma.tBEventReg_ACM2017.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TBEventReg_ACM2017UpdateArgs>(
      args: SelectSubset<T, TBEventReg_ACM2017UpdateArgs>
    ): Prisma__TBEventReg_ACM2017Client<TBEventReg_ACM2017GetPayload<T>>

    /**
     * Delete zero or more TBEventReg_ACM2017s.
     * @param {TBEventReg_ACM2017DeleteManyArgs} args - Arguments to filter TBEventReg_ACM2017s to delete.
     * @example
     * // Delete a few TBEventReg_ACM2017s
     * const { count } = await prisma.tBEventReg_ACM2017.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TBEventReg_ACM2017DeleteManyArgs>(
      args?: SelectSubset<T, TBEventReg_ACM2017DeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TBEventReg_ACM2017s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2017UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TBEventReg_ACM2017s
     * const tBEventReg_ACM2017 = await prisma.tBEventReg_ACM2017.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TBEventReg_ACM2017UpdateManyArgs>(
      args: SelectSubset<T, TBEventReg_ACM2017UpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TBEventReg_ACM2017.
     * @param {TBEventReg_ACM2017UpsertArgs} args - Arguments to update or create a TBEventReg_ACM2017.
     * @example
     * // Update or create a TBEventReg_ACM2017
     * const tBEventReg_ACM2017 = await prisma.tBEventReg_ACM2017.upsert({
     *   create: {
     *     // ... data to create a TBEventReg_ACM2017
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TBEventReg_ACM2017 we want to update
     *   }
     * })
    **/
    upsert<T extends TBEventReg_ACM2017UpsertArgs>(
      args: SelectSubset<T, TBEventReg_ACM2017UpsertArgs>
    ): Prisma__TBEventReg_ACM2017Client<TBEventReg_ACM2017GetPayload<T>>

    /**
     * Count the number of TBEventReg_ACM2017s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2017CountArgs} args - Arguments to filter TBEventReg_ACM2017s to count.
     * @example
     * // Count the number of TBEventReg_ACM2017s
     * const count = await prisma.tBEventReg_ACM2017.count({
     *   where: {
     *     // ... the filter for the TBEventReg_ACM2017s we want to count
     *   }
     * })
    **/
    count<T extends TBEventReg_ACM2017CountArgs>(
      args?: Subset<T, TBEventReg_ACM2017CountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TBEventReg_ACM2017CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TBEventReg_ACM2017.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2017AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TBEventReg_ACM2017AggregateArgs>(args: Subset<T, TBEventReg_ACM2017AggregateArgs>): Prisma.PrismaPromise<GetTBEventReg_ACM2017AggregateType<T>>

    /**
     * Group by TBEventReg_ACM2017.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2017GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TBEventReg_ACM2017GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TBEventReg_ACM2017GroupByArgs['orderBy'] }
        : { orderBy?: TBEventReg_ACM2017GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TBEventReg_ACM2017GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTBEventReg_ACM2017GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TBEventReg_ACM2017.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TBEventReg_ACM2017Client<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TBEventReg_ACM2017 base type for findUnique actions
   */
  export type TBEventReg_ACM2017FindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2017
     */
    select?: TBEventReg_ACM2017Select | null
    /**
     * Filter, which TBEventReg_ACM2017 to fetch.
     */
    where: TBEventReg_ACM2017WhereUniqueInput
  }

  /**
   * TBEventReg_ACM2017 findUnique
   */
  export interface TBEventReg_ACM2017FindUniqueArgs extends TBEventReg_ACM2017FindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_ACM2017 findUniqueOrThrow
   */
  export type TBEventReg_ACM2017FindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2017
     */
    select?: TBEventReg_ACM2017Select | null
    /**
     * Filter, which TBEventReg_ACM2017 to fetch.
     */
    where: TBEventReg_ACM2017WhereUniqueInput
  }


  /**
   * TBEventReg_ACM2017 base type for findFirst actions
   */
  export type TBEventReg_ACM2017FindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2017
     */
    select?: TBEventReg_ACM2017Select | null
    /**
     * Filter, which TBEventReg_ACM2017 to fetch.
     */
    where?: TBEventReg_ACM2017WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ACM2017s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ACM2017OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_ACM2017s.
     */
    cursor?: TBEventReg_ACM2017WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ACM2017s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ACM2017s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_ACM2017s.
     */
    distinct?: Enumerable<TBEventReg_ACM2017ScalarFieldEnum>
  }

  /**
   * TBEventReg_ACM2017 findFirst
   */
  export interface TBEventReg_ACM2017FindFirstArgs extends TBEventReg_ACM2017FindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_ACM2017 findFirstOrThrow
   */
  export type TBEventReg_ACM2017FindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2017
     */
    select?: TBEventReg_ACM2017Select | null
    /**
     * Filter, which TBEventReg_ACM2017 to fetch.
     */
    where?: TBEventReg_ACM2017WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ACM2017s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ACM2017OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_ACM2017s.
     */
    cursor?: TBEventReg_ACM2017WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ACM2017s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ACM2017s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_ACM2017s.
     */
    distinct?: Enumerable<TBEventReg_ACM2017ScalarFieldEnum>
  }


  /**
   * TBEventReg_ACM2017 findMany
   */
  export type TBEventReg_ACM2017FindManyArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2017
     */
    select?: TBEventReg_ACM2017Select | null
    /**
     * Filter, which TBEventReg_ACM2017s to fetch.
     */
    where?: TBEventReg_ACM2017WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ACM2017s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ACM2017OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TBEventReg_ACM2017s.
     */
    cursor?: TBEventReg_ACM2017WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ACM2017s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ACM2017s.
     */
    skip?: number
    distinct?: Enumerable<TBEventReg_ACM2017ScalarFieldEnum>
  }


  /**
   * TBEventReg_ACM2017 create
   */
  export type TBEventReg_ACM2017CreateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2017
     */
    select?: TBEventReg_ACM2017Select | null
    /**
     * The data needed to create a TBEventReg_ACM2017.
     */
    data: XOR<TBEventReg_ACM2017CreateInput, TBEventReg_ACM2017UncheckedCreateInput>
  }


  /**
   * TBEventReg_ACM2017 createMany
   */
  export type TBEventReg_ACM2017CreateManyArgs = {
    /**
     * The data used to create many TBEventReg_ACM2017s.
     */
    data: Enumerable<TBEventReg_ACM2017CreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TBEventReg_ACM2017 update
   */
  export type TBEventReg_ACM2017UpdateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2017
     */
    select?: TBEventReg_ACM2017Select | null
    /**
     * The data needed to update a TBEventReg_ACM2017.
     */
    data: XOR<TBEventReg_ACM2017UpdateInput, TBEventReg_ACM2017UncheckedUpdateInput>
    /**
     * Choose, which TBEventReg_ACM2017 to update.
     */
    where: TBEventReg_ACM2017WhereUniqueInput
  }


  /**
   * TBEventReg_ACM2017 updateMany
   */
  export type TBEventReg_ACM2017UpdateManyArgs = {
    /**
     * The data used to update TBEventReg_ACM2017s.
     */
    data: XOR<TBEventReg_ACM2017UpdateManyMutationInput, TBEventReg_ACM2017UncheckedUpdateManyInput>
    /**
     * Filter which TBEventReg_ACM2017s to update
     */
    where?: TBEventReg_ACM2017WhereInput
  }


  /**
   * TBEventReg_ACM2017 upsert
   */
  export type TBEventReg_ACM2017UpsertArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2017
     */
    select?: TBEventReg_ACM2017Select | null
    /**
     * The filter to search for the TBEventReg_ACM2017 to update in case it exists.
     */
    where: TBEventReg_ACM2017WhereUniqueInput
    /**
     * In case the TBEventReg_ACM2017 found by the `where` argument doesn't exist, create a new TBEventReg_ACM2017 with this data.
     */
    create: XOR<TBEventReg_ACM2017CreateInput, TBEventReg_ACM2017UncheckedCreateInput>
    /**
     * In case the TBEventReg_ACM2017 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TBEventReg_ACM2017UpdateInput, TBEventReg_ACM2017UncheckedUpdateInput>
  }


  /**
   * TBEventReg_ACM2017 delete
   */
  export type TBEventReg_ACM2017DeleteArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2017
     */
    select?: TBEventReg_ACM2017Select | null
    /**
     * Filter which TBEventReg_ACM2017 to delete.
     */
    where: TBEventReg_ACM2017WhereUniqueInput
  }


  /**
   * TBEventReg_ACM2017 deleteMany
   */
  export type TBEventReg_ACM2017DeleteManyArgs = {
    /**
     * Filter which TBEventReg_ACM2017s to delete
     */
    where?: TBEventReg_ACM2017WhereInput
  }


  /**
   * TBEventReg_ACM2017 without action
   */
  export type TBEventReg_ACM2017Args = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2017
     */
    select?: TBEventReg_ACM2017Select | null
  }



  /**
   * Model TBEventReg_ACM2018
   */


  export type AggregateTBEventReg_ACM2018 = {
    _count: TBEventReg_ACM2018CountAggregateOutputType | null
    _avg: TBEventReg_ACM2018AvgAggregateOutputType | null
    _sum: TBEventReg_ACM2018SumAggregateOutputType | null
    _min: TBEventReg_ACM2018MinAggregateOutputType | null
    _max: TBEventReg_ACM2018MaxAggregateOutputType | null
  }

  export type TBEventReg_ACM2018AvgAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_ACM2018SumAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_ACM2018MinAggregateOutputType = {
    ID: number | null
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegAffiliate: string | null
    RegPreamble: string | null
    RegQuestion: string | null
    RegDate: Date | null
    RegIP: string | null
  }

  export type TBEventReg_ACM2018MaxAggregateOutputType = {
    ID: number | null
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegAffiliate: string | null
    RegPreamble: string | null
    RegQuestion: string | null
    RegDate: Date | null
    RegIP: string | null
  }

  export type TBEventReg_ACM2018CountAggregateOutputType = {
    ID: number
    EventTitle: number
    RegName: number
    RegEmail: number
    RegTel: number
    RegAddress: number
    RegAffiliate: number
    RegPreamble: number
    RegQuestion: number
    RegDate: number
    RegIP: number
    _all: number
  }


  export type TBEventReg_ACM2018AvgAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_ACM2018SumAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_ACM2018MinAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegAffiliate?: true
    RegPreamble?: true
    RegQuestion?: true
    RegDate?: true
    RegIP?: true
  }

  export type TBEventReg_ACM2018MaxAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegAffiliate?: true
    RegPreamble?: true
    RegQuestion?: true
    RegDate?: true
    RegIP?: true
  }

  export type TBEventReg_ACM2018CountAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegAffiliate?: true
    RegPreamble?: true
    RegQuestion?: true
    RegDate?: true
    RegIP?: true
    _all?: true
  }

  export type TBEventReg_ACM2018AggregateArgs = {
    /**
     * Filter which TBEventReg_ACM2018 to aggregate.
     */
    where?: TBEventReg_ACM2018WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ACM2018s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ACM2018OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TBEventReg_ACM2018WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ACM2018s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ACM2018s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TBEventReg_ACM2018s
    **/
    _count?: true | TBEventReg_ACM2018CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TBEventReg_ACM2018AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TBEventReg_ACM2018SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TBEventReg_ACM2018MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TBEventReg_ACM2018MaxAggregateInputType
  }

  export type GetTBEventReg_ACM2018AggregateType<T extends TBEventReg_ACM2018AggregateArgs> = {
        [P in keyof T & keyof AggregateTBEventReg_ACM2018]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTBEventReg_ACM2018[P]>
      : GetScalarType<T[P], AggregateTBEventReg_ACM2018[P]>
  }




  export type TBEventReg_ACM2018GroupByArgs = {
    where?: TBEventReg_ACM2018WhereInput
    orderBy?: Enumerable<TBEventReg_ACM2018OrderByWithAggregationInput>
    by: TBEventReg_ACM2018ScalarFieldEnum[]
    having?: TBEventReg_ACM2018ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TBEventReg_ACM2018CountAggregateInputType | true
    _avg?: TBEventReg_ACM2018AvgAggregateInputType
    _sum?: TBEventReg_ACM2018SumAggregateInputType
    _min?: TBEventReg_ACM2018MinAggregateInputType
    _max?: TBEventReg_ACM2018MaxAggregateInputType
  }


  export type TBEventReg_ACM2018GroupByOutputType = {
    ID: number
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegAffiliate: string | null
    RegPreamble: string
    RegQuestion: string
    RegDate: Date | null
    RegIP: string
    _count: TBEventReg_ACM2018CountAggregateOutputType | null
    _avg: TBEventReg_ACM2018AvgAggregateOutputType | null
    _sum: TBEventReg_ACM2018SumAggregateOutputType | null
    _min: TBEventReg_ACM2018MinAggregateOutputType | null
    _max: TBEventReg_ACM2018MaxAggregateOutputType | null
  }

  type GetTBEventReg_ACM2018GroupByPayload<T extends TBEventReg_ACM2018GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TBEventReg_ACM2018GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TBEventReg_ACM2018GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TBEventReg_ACM2018GroupByOutputType[P]>
            : GetScalarType<T[P], TBEventReg_ACM2018GroupByOutputType[P]>
        }
      >
    >


  export type TBEventReg_ACM2018Select = {
    ID?: boolean
    EventTitle?: boolean
    RegName?: boolean
    RegEmail?: boolean
    RegTel?: boolean
    RegAddress?: boolean
    RegAffiliate?: boolean
    RegPreamble?: boolean
    RegQuestion?: boolean
    RegDate?: boolean
    RegIP?: boolean
  }


  export type TBEventReg_ACM2018GetPayload<S extends boolean | null | undefined | TBEventReg_ACM2018Args> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TBEventReg_ACM2018 :
    S extends undefined ? never :
    S extends { include: any } & (TBEventReg_ACM2018Args | TBEventReg_ACM2018FindManyArgs)
    ? TBEventReg_ACM2018 
    : S extends { select: any } & (TBEventReg_ACM2018Args | TBEventReg_ACM2018FindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TBEventReg_ACM2018 ? TBEventReg_ACM2018[P] : never
  } 
      : TBEventReg_ACM2018


  type TBEventReg_ACM2018CountArgs = 
    Omit<TBEventReg_ACM2018FindManyArgs, 'select' | 'include'> & {
      select?: TBEventReg_ACM2018CountAggregateInputType | true
    }

  export interface TBEventReg_ACM2018Delegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TBEventReg_ACM2018 that matches the filter.
     * @param {TBEventReg_ACM2018FindUniqueArgs} args - Arguments to find a TBEventReg_ACM2018
     * @example
     * // Get one TBEventReg_ACM2018
     * const tBEventReg_ACM2018 = await prisma.tBEventReg_ACM2018.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TBEventReg_ACM2018FindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TBEventReg_ACM2018FindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TBEventReg_ACM2018'> extends True ? Prisma__TBEventReg_ACM2018Client<TBEventReg_ACM2018GetPayload<T>> : Prisma__TBEventReg_ACM2018Client<TBEventReg_ACM2018GetPayload<T> | null, null>

    /**
     * Find one TBEventReg_ACM2018 that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TBEventReg_ACM2018FindUniqueOrThrowArgs} args - Arguments to find a TBEventReg_ACM2018
     * @example
     * // Get one TBEventReg_ACM2018
     * const tBEventReg_ACM2018 = await prisma.tBEventReg_ACM2018.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TBEventReg_ACM2018FindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_ACM2018FindUniqueOrThrowArgs>
    ): Prisma__TBEventReg_ACM2018Client<TBEventReg_ACM2018GetPayload<T>>

    /**
     * Find the first TBEventReg_ACM2018 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2018FindFirstArgs} args - Arguments to find a TBEventReg_ACM2018
     * @example
     * // Get one TBEventReg_ACM2018
     * const tBEventReg_ACM2018 = await prisma.tBEventReg_ACM2018.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TBEventReg_ACM2018FindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TBEventReg_ACM2018FindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TBEventReg_ACM2018'> extends True ? Prisma__TBEventReg_ACM2018Client<TBEventReg_ACM2018GetPayload<T>> : Prisma__TBEventReg_ACM2018Client<TBEventReg_ACM2018GetPayload<T> | null, null>

    /**
     * Find the first TBEventReg_ACM2018 that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2018FindFirstOrThrowArgs} args - Arguments to find a TBEventReg_ACM2018
     * @example
     * // Get one TBEventReg_ACM2018
     * const tBEventReg_ACM2018 = await prisma.tBEventReg_ACM2018.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TBEventReg_ACM2018FindFirstOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_ACM2018FindFirstOrThrowArgs>
    ): Prisma__TBEventReg_ACM2018Client<TBEventReg_ACM2018GetPayload<T>>

    /**
     * Find zero or more TBEventReg_ACM2018s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2018FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TBEventReg_ACM2018s
     * const tBEventReg_ACM2018s = await prisma.tBEventReg_ACM2018.findMany()
     * 
     * // Get first 10 TBEventReg_ACM2018s
     * const tBEventReg_ACM2018s = await prisma.tBEventReg_ACM2018.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tBEventReg_ACM2018WithIDOnly = await prisma.tBEventReg_ACM2018.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends TBEventReg_ACM2018FindManyArgs>(
      args?: SelectSubset<T, TBEventReg_ACM2018FindManyArgs>
    ): Prisma.PrismaPromise<Array<TBEventReg_ACM2018GetPayload<T>>>

    /**
     * Create a TBEventReg_ACM2018.
     * @param {TBEventReg_ACM2018CreateArgs} args - Arguments to create a TBEventReg_ACM2018.
     * @example
     * // Create one TBEventReg_ACM2018
     * const TBEventReg_ACM2018 = await prisma.tBEventReg_ACM2018.create({
     *   data: {
     *     // ... data to create a TBEventReg_ACM2018
     *   }
     * })
     * 
    **/
    create<T extends TBEventReg_ACM2018CreateArgs>(
      args: SelectSubset<T, TBEventReg_ACM2018CreateArgs>
    ): Prisma__TBEventReg_ACM2018Client<TBEventReg_ACM2018GetPayload<T>>

    /**
     * Create many TBEventReg_ACM2018s.
     *     @param {TBEventReg_ACM2018CreateManyArgs} args - Arguments to create many TBEventReg_ACM2018s.
     *     @example
     *     // Create many TBEventReg_ACM2018s
     *     const tBEventReg_ACM2018 = await prisma.tBEventReg_ACM2018.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TBEventReg_ACM2018CreateManyArgs>(
      args?: SelectSubset<T, TBEventReg_ACM2018CreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TBEventReg_ACM2018.
     * @param {TBEventReg_ACM2018DeleteArgs} args - Arguments to delete one TBEventReg_ACM2018.
     * @example
     * // Delete one TBEventReg_ACM2018
     * const TBEventReg_ACM2018 = await prisma.tBEventReg_ACM2018.delete({
     *   where: {
     *     // ... filter to delete one TBEventReg_ACM2018
     *   }
     * })
     * 
    **/
    delete<T extends TBEventReg_ACM2018DeleteArgs>(
      args: SelectSubset<T, TBEventReg_ACM2018DeleteArgs>
    ): Prisma__TBEventReg_ACM2018Client<TBEventReg_ACM2018GetPayload<T>>

    /**
     * Update one TBEventReg_ACM2018.
     * @param {TBEventReg_ACM2018UpdateArgs} args - Arguments to update one TBEventReg_ACM2018.
     * @example
     * // Update one TBEventReg_ACM2018
     * const tBEventReg_ACM2018 = await prisma.tBEventReg_ACM2018.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TBEventReg_ACM2018UpdateArgs>(
      args: SelectSubset<T, TBEventReg_ACM2018UpdateArgs>
    ): Prisma__TBEventReg_ACM2018Client<TBEventReg_ACM2018GetPayload<T>>

    /**
     * Delete zero or more TBEventReg_ACM2018s.
     * @param {TBEventReg_ACM2018DeleteManyArgs} args - Arguments to filter TBEventReg_ACM2018s to delete.
     * @example
     * // Delete a few TBEventReg_ACM2018s
     * const { count } = await prisma.tBEventReg_ACM2018.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TBEventReg_ACM2018DeleteManyArgs>(
      args?: SelectSubset<T, TBEventReg_ACM2018DeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TBEventReg_ACM2018s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2018UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TBEventReg_ACM2018s
     * const tBEventReg_ACM2018 = await prisma.tBEventReg_ACM2018.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TBEventReg_ACM2018UpdateManyArgs>(
      args: SelectSubset<T, TBEventReg_ACM2018UpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TBEventReg_ACM2018.
     * @param {TBEventReg_ACM2018UpsertArgs} args - Arguments to update or create a TBEventReg_ACM2018.
     * @example
     * // Update or create a TBEventReg_ACM2018
     * const tBEventReg_ACM2018 = await prisma.tBEventReg_ACM2018.upsert({
     *   create: {
     *     // ... data to create a TBEventReg_ACM2018
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TBEventReg_ACM2018 we want to update
     *   }
     * })
    **/
    upsert<T extends TBEventReg_ACM2018UpsertArgs>(
      args: SelectSubset<T, TBEventReg_ACM2018UpsertArgs>
    ): Prisma__TBEventReg_ACM2018Client<TBEventReg_ACM2018GetPayload<T>>

    /**
     * Count the number of TBEventReg_ACM2018s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2018CountArgs} args - Arguments to filter TBEventReg_ACM2018s to count.
     * @example
     * // Count the number of TBEventReg_ACM2018s
     * const count = await prisma.tBEventReg_ACM2018.count({
     *   where: {
     *     // ... the filter for the TBEventReg_ACM2018s we want to count
     *   }
     * })
    **/
    count<T extends TBEventReg_ACM2018CountArgs>(
      args?: Subset<T, TBEventReg_ACM2018CountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TBEventReg_ACM2018CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TBEventReg_ACM2018.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2018AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TBEventReg_ACM2018AggregateArgs>(args: Subset<T, TBEventReg_ACM2018AggregateArgs>): Prisma.PrismaPromise<GetTBEventReg_ACM2018AggregateType<T>>

    /**
     * Group by TBEventReg_ACM2018.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2018GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TBEventReg_ACM2018GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TBEventReg_ACM2018GroupByArgs['orderBy'] }
        : { orderBy?: TBEventReg_ACM2018GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TBEventReg_ACM2018GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTBEventReg_ACM2018GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TBEventReg_ACM2018.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TBEventReg_ACM2018Client<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TBEventReg_ACM2018 base type for findUnique actions
   */
  export type TBEventReg_ACM2018FindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2018
     */
    select?: TBEventReg_ACM2018Select | null
    /**
     * Filter, which TBEventReg_ACM2018 to fetch.
     */
    where: TBEventReg_ACM2018WhereUniqueInput
  }

  /**
   * TBEventReg_ACM2018 findUnique
   */
  export interface TBEventReg_ACM2018FindUniqueArgs extends TBEventReg_ACM2018FindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_ACM2018 findUniqueOrThrow
   */
  export type TBEventReg_ACM2018FindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2018
     */
    select?: TBEventReg_ACM2018Select | null
    /**
     * Filter, which TBEventReg_ACM2018 to fetch.
     */
    where: TBEventReg_ACM2018WhereUniqueInput
  }


  /**
   * TBEventReg_ACM2018 base type for findFirst actions
   */
  export type TBEventReg_ACM2018FindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2018
     */
    select?: TBEventReg_ACM2018Select | null
    /**
     * Filter, which TBEventReg_ACM2018 to fetch.
     */
    where?: TBEventReg_ACM2018WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ACM2018s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ACM2018OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_ACM2018s.
     */
    cursor?: TBEventReg_ACM2018WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ACM2018s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ACM2018s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_ACM2018s.
     */
    distinct?: Enumerable<TBEventReg_ACM2018ScalarFieldEnum>
  }

  /**
   * TBEventReg_ACM2018 findFirst
   */
  export interface TBEventReg_ACM2018FindFirstArgs extends TBEventReg_ACM2018FindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_ACM2018 findFirstOrThrow
   */
  export type TBEventReg_ACM2018FindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2018
     */
    select?: TBEventReg_ACM2018Select | null
    /**
     * Filter, which TBEventReg_ACM2018 to fetch.
     */
    where?: TBEventReg_ACM2018WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ACM2018s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ACM2018OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_ACM2018s.
     */
    cursor?: TBEventReg_ACM2018WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ACM2018s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ACM2018s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_ACM2018s.
     */
    distinct?: Enumerable<TBEventReg_ACM2018ScalarFieldEnum>
  }


  /**
   * TBEventReg_ACM2018 findMany
   */
  export type TBEventReg_ACM2018FindManyArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2018
     */
    select?: TBEventReg_ACM2018Select | null
    /**
     * Filter, which TBEventReg_ACM2018s to fetch.
     */
    where?: TBEventReg_ACM2018WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ACM2018s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ACM2018OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TBEventReg_ACM2018s.
     */
    cursor?: TBEventReg_ACM2018WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ACM2018s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ACM2018s.
     */
    skip?: number
    distinct?: Enumerable<TBEventReg_ACM2018ScalarFieldEnum>
  }


  /**
   * TBEventReg_ACM2018 create
   */
  export type TBEventReg_ACM2018CreateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2018
     */
    select?: TBEventReg_ACM2018Select | null
    /**
     * The data needed to create a TBEventReg_ACM2018.
     */
    data: XOR<TBEventReg_ACM2018CreateInput, TBEventReg_ACM2018UncheckedCreateInput>
  }


  /**
   * TBEventReg_ACM2018 createMany
   */
  export type TBEventReg_ACM2018CreateManyArgs = {
    /**
     * The data used to create many TBEventReg_ACM2018s.
     */
    data: Enumerable<TBEventReg_ACM2018CreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TBEventReg_ACM2018 update
   */
  export type TBEventReg_ACM2018UpdateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2018
     */
    select?: TBEventReg_ACM2018Select | null
    /**
     * The data needed to update a TBEventReg_ACM2018.
     */
    data: XOR<TBEventReg_ACM2018UpdateInput, TBEventReg_ACM2018UncheckedUpdateInput>
    /**
     * Choose, which TBEventReg_ACM2018 to update.
     */
    where: TBEventReg_ACM2018WhereUniqueInput
  }


  /**
   * TBEventReg_ACM2018 updateMany
   */
  export type TBEventReg_ACM2018UpdateManyArgs = {
    /**
     * The data used to update TBEventReg_ACM2018s.
     */
    data: XOR<TBEventReg_ACM2018UpdateManyMutationInput, TBEventReg_ACM2018UncheckedUpdateManyInput>
    /**
     * Filter which TBEventReg_ACM2018s to update
     */
    where?: TBEventReg_ACM2018WhereInput
  }


  /**
   * TBEventReg_ACM2018 upsert
   */
  export type TBEventReg_ACM2018UpsertArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2018
     */
    select?: TBEventReg_ACM2018Select | null
    /**
     * The filter to search for the TBEventReg_ACM2018 to update in case it exists.
     */
    where: TBEventReg_ACM2018WhereUniqueInput
    /**
     * In case the TBEventReg_ACM2018 found by the `where` argument doesn't exist, create a new TBEventReg_ACM2018 with this data.
     */
    create: XOR<TBEventReg_ACM2018CreateInput, TBEventReg_ACM2018UncheckedCreateInput>
    /**
     * In case the TBEventReg_ACM2018 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TBEventReg_ACM2018UpdateInput, TBEventReg_ACM2018UncheckedUpdateInput>
  }


  /**
   * TBEventReg_ACM2018 delete
   */
  export type TBEventReg_ACM2018DeleteArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2018
     */
    select?: TBEventReg_ACM2018Select | null
    /**
     * Filter which TBEventReg_ACM2018 to delete.
     */
    where: TBEventReg_ACM2018WhereUniqueInput
  }


  /**
   * TBEventReg_ACM2018 deleteMany
   */
  export type TBEventReg_ACM2018DeleteManyArgs = {
    /**
     * Filter which TBEventReg_ACM2018s to delete
     */
    where?: TBEventReg_ACM2018WhereInput
  }


  /**
   * TBEventReg_ACM2018 without action
   */
  export type TBEventReg_ACM2018Args = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2018
     */
    select?: TBEventReg_ACM2018Select | null
  }



  /**
   * Model TBEventReg_ACM2022
   */


  export type AggregateTBEventReg_ACM2022 = {
    _count: TBEventReg_ACM2022CountAggregateOutputType | null
    _avg: TBEventReg_ACM2022AvgAggregateOutputType | null
    _sum: TBEventReg_ACM2022SumAggregateOutputType | null
    _min: TBEventReg_ACM2022MinAggregateOutputType | null
    _max: TBEventReg_ACM2022MaxAggregateOutputType | null
  }

  export type TBEventReg_ACM2022AvgAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_ACM2022SumAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_ACM2022MinAggregateOutputType = {
    ID: number | null
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegAffiliate: string | null
    RegPreamble: string | null
    RegQuestion: string | null
    RegDate: Date | null
    RegIP: string | null
  }

  export type TBEventReg_ACM2022MaxAggregateOutputType = {
    ID: number | null
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegAffiliate: string | null
    RegPreamble: string | null
    RegQuestion: string | null
    RegDate: Date | null
    RegIP: string | null
  }

  export type TBEventReg_ACM2022CountAggregateOutputType = {
    ID: number
    EventTitle: number
    RegName: number
    RegEmail: number
    RegTel: number
    RegAddress: number
    RegAffiliate: number
    RegPreamble: number
    RegQuestion: number
    RegDate: number
    RegIP: number
    _all: number
  }


  export type TBEventReg_ACM2022AvgAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_ACM2022SumAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_ACM2022MinAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegAffiliate?: true
    RegPreamble?: true
    RegQuestion?: true
    RegDate?: true
    RegIP?: true
  }

  export type TBEventReg_ACM2022MaxAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegAffiliate?: true
    RegPreamble?: true
    RegQuestion?: true
    RegDate?: true
    RegIP?: true
  }

  export type TBEventReg_ACM2022CountAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegAffiliate?: true
    RegPreamble?: true
    RegQuestion?: true
    RegDate?: true
    RegIP?: true
    _all?: true
  }

  export type TBEventReg_ACM2022AggregateArgs = {
    /**
     * Filter which TBEventReg_ACM2022 to aggregate.
     */
    where?: TBEventReg_ACM2022WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ACM2022s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ACM2022OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TBEventReg_ACM2022WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ACM2022s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ACM2022s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TBEventReg_ACM2022s
    **/
    _count?: true | TBEventReg_ACM2022CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TBEventReg_ACM2022AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TBEventReg_ACM2022SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TBEventReg_ACM2022MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TBEventReg_ACM2022MaxAggregateInputType
  }

  export type GetTBEventReg_ACM2022AggregateType<T extends TBEventReg_ACM2022AggregateArgs> = {
        [P in keyof T & keyof AggregateTBEventReg_ACM2022]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTBEventReg_ACM2022[P]>
      : GetScalarType<T[P], AggregateTBEventReg_ACM2022[P]>
  }




  export type TBEventReg_ACM2022GroupByArgs = {
    where?: TBEventReg_ACM2022WhereInput
    orderBy?: Enumerable<TBEventReg_ACM2022OrderByWithAggregationInput>
    by: TBEventReg_ACM2022ScalarFieldEnum[]
    having?: TBEventReg_ACM2022ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TBEventReg_ACM2022CountAggregateInputType | true
    _avg?: TBEventReg_ACM2022AvgAggregateInputType
    _sum?: TBEventReg_ACM2022SumAggregateInputType
    _min?: TBEventReg_ACM2022MinAggregateInputType
    _max?: TBEventReg_ACM2022MaxAggregateInputType
  }


  export type TBEventReg_ACM2022GroupByOutputType = {
    ID: number
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegAffiliate: string | null
    RegPreamble: string
    RegQuestion: string
    RegDate: Date | null
    RegIP: string
    _count: TBEventReg_ACM2022CountAggregateOutputType | null
    _avg: TBEventReg_ACM2022AvgAggregateOutputType | null
    _sum: TBEventReg_ACM2022SumAggregateOutputType | null
    _min: TBEventReg_ACM2022MinAggregateOutputType | null
    _max: TBEventReg_ACM2022MaxAggregateOutputType | null
  }

  type GetTBEventReg_ACM2022GroupByPayload<T extends TBEventReg_ACM2022GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TBEventReg_ACM2022GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TBEventReg_ACM2022GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TBEventReg_ACM2022GroupByOutputType[P]>
            : GetScalarType<T[P], TBEventReg_ACM2022GroupByOutputType[P]>
        }
      >
    >


  export type TBEventReg_ACM2022Select = {
    ID?: boolean
    EventTitle?: boolean
    RegName?: boolean
    RegEmail?: boolean
    RegTel?: boolean
    RegAddress?: boolean
    RegAffiliate?: boolean
    RegPreamble?: boolean
    RegQuestion?: boolean
    RegDate?: boolean
    RegIP?: boolean
  }


  export type TBEventReg_ACM2022GetPayload<S extends boolean | null | undefined | TBEventReg_ACM2022Args> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TBEventReg_ACM2022 :
    S extends undefined ? never :
    S extends { include: any } & (TBEventReg_ACM2022Args | TBEventReg_ACM2022FindManyArgs)
    ? TBEventReg_ACM2022 
    : S extends { select: any } & (TBEventReg_ACM2022Args | TBEventReg_ACM2022FindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TBEventReg_ACM2022 ? TBEventReg_ACM2022[P] : never
  } 
      : TBEventReg_ACM2022


  type TBEventReg_ACM2022CountArgs = 
    Omit<TBEventReg_ACM2022FindManyArgs, 'select' | 'include'> & {
      select?: TBEventReg_ACM2022CountAggregateInputType | true
    }

  export interface TBEventReg_ACM2022Delegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TBEventReg_ACM2022 that matches the filter.
     * @param {TBEventReg_ACM2022FindUniqueArgs} args - Arguments to find a TBEventReg_ACM2022
     * @example
     * // Get one TBEventReg_ACM2022
     * const tBEventReg_ACM2022 = await prisma.tBEventReg_ACM2022.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TBEventReg_ACM2022FindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TBEventReg_ACM2022FindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TBEventReg_ACM2022'> extends True ? Prisma__TBEventReg_ACM2022Client<TBEventReg_ACM2022GetPayload<T>> : Prisma__TBEventReg_ACM2022Client<TBEventReg_ACM2022GetPayload<T> | null, null>

    /**
     * Find one TBEventReg_ACM2022 that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TBEventReg_ACM2022FindUniqueOrThrowArgs} args - Arguments to find a TBEventReg_ACM2022
     * @example
     * // Get one TBEventReg_ACM2022
     * const tBEventReg_ACM2022 = await prisma.tBEventReg_ACM2022.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TBEventReg_ACM2022FindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_ACM2022FindUniqueOrThrowArgs>
    ): Prisma__TBEventReg_ACM2022Client<TBEventReg_ACM2022GetPayload<T>>

    /**
     * Find the first TBEventReg_ACM2022 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2022FindFirstArgs} args - Arguments to find a TBEventReg_ACM2022
     * @example
     * // Get one TBEventReg_ACM2022
     * const tBEventReg_ACM2022 = await prisma.tBEventReg_ACM2022.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TBEventReg_ACM2022FindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TBEventReg_ACM2022FindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TBEventReg_ACM2022'> extends True ? Prisma__TBEventReg_ACM2022Client<TBEventReg_ACM2022GetPayload<T>> : Prisma__TBEventReg_ACM2022Client<TBEventReg_ACM2022GetPayload<T> | null, null>

    /**
     * Find the first TBEventReg_ACM2022 that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2022FindFirstOrThrowArgs} args - Arguments to find a TBEventReg_ACM2022
     * @example
     * // Get one TBEventReg_ACM2022
     * const tBEventReg_ACM2022 = await prisma.tBEventReg_ACM2022.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TBEventReg_ACM2022FindFirstOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_ACM2022FindFirstOrThrowArgs>
    ): Prisma__TBEventReg_ACM2022Client<TBEventReg_ACM2022GetPayload<T>>

    /**
     * Find zero or more TBEventReg_ACM2022s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2022FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TBEventReg_ACM2022s
     * const tBEventReg_ACM2022s = await prisma.tBEventReg_ACM2022.findMany()
     * 
     * // Get first 10 TBEventReg_ACM2022s
     * const tBEventReg_ACM2022s = await prisma.tBEventReg_ACM2022.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tBEventReg_ACM2022WithIDOnly = await prisma.tBEventReg_ACM2022.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends TBEventReg_ACM2022FindManyArgs>(
      args?: SelectSubset<T, TBEventReg_ACM2022FindManyArgs>
    ): Prisma.PrismaPromise<Array<TBEventReg_ACM2022GetPayload<T>>>

    /**
     * Create a TBEventReg_ACM2022.
     * @param {TBEventReg_ACM2022CreateArgs} args - Arguments to create a TBEventReg_ACM2022.
     * @example
     * // Create one TBEventReg_ACM2022
     * const TBEventReg_ACM2022 = await prisma.tBEventReg_ACM2022.create({
     *   data: {
     *     // ... data to create a TBEventReg_ACM2022
     *   }
     * })
     * 
    **/
    create<T extends TBEventReg_ACM2022CreateArgs>(
      args: SelectSubset<T, TBEventReg_ACM2022CreateArgs>
    ): Prisma__TBEventReg_ACM2022Client<TBEventReg_ACM2022GetPayload<T>>

    /**
     * Create many TBEventReg_ACM2022s.
     *     @param {TBEventReg_ACM2022CreateManyArgs} args - Arguments to create many TBEventReg_ACM2022s.
     *     @example
     *     // Create many TBEventReg_ACM2022s
     *     const tBEventReg_ACM2022 = await prisma.tBEventReg_ACM2022.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TBEventReg_ACM2022CreateManyArgs>(
      args?: SelectSubset<T, TBEventReg_ACM2022CreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TBEventReg_ACM2022.
     * @param {TBEventReg_ACM2022DeleteArgs} args - Arguments to delete one TBEventReg_ACM2022.
     * @example
     * // Delete one TBEventReg_ACM2022
     * const TBEventReg_ACM2022 = await prisma.tBEventReg_ACM2022.delete({
     *   where: {
     *     // ... filter to delete one TBEventReg_ACM2022
     *   }
     * })
     * 
    **/
    delete<T extends TBEventReg_ACM2022DeleteArgs>(
      args: SelectSubset<T, TBEventReg_ACM2022DeleteArgs>
    ): Prisma__TBEventReg_ACM2022Client<TBEventReg_ACM2022GetPayload<T>>

    /**
     * Update one TBEventReg_ACM2022.
     * @param {TBEventReg_ACM2022UpdateArgs} args - Arguments to update one TBEventReg_ACM2022.
     * @example
     * // Update one TBEventReg_ACM2022
     * const tBEventReg_ACM2022 = await prisma.tBEventReg_ACM2022.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TBEventReg_ACM2022UpdateArgs>(
      args: SelectSubset<T, TBEventReg_ACM2022UpdateArgs>
    ): Prisma__TBEventReg_ACM2022Client<TBEventReg_ACM2022GetPayload<T>>

    /**
     * Delete zero or more TBEventReg_ACM2022s.
     * @param {TBEventReg_ACM2022DeleteManyArgs} args - Arguments to filter TBEventReg_ACM2022s to delete.
     * @example
     * // Delete a few TBEventReg_ACM2022s
     * const { count } = await prisma.tBEventReg_ACM2022.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TBEventReg_ACM2022DeleteManyArgs>(
      args?: SelectSubset<T, TBEventReg_ACM2022DeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TBEventReg_ACM2022s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2022UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TBEventReg_ACM2022s
     * const tBEventReg_ACM2022 = await prisma.tBEventReg_ACM2022.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TBEventReg_ACM2022UpdateManyArgs>(
      args: SelectSubset<T, TBEventReg_ACM2022UpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TBEventReg_ACM2022.
     * @param {TBEventReg_ACM2022UpsertArgs} args - Arguments to update or create a TBEventReg_ACM2022.
     * @example
     * // Update or create a TBEventReg_ACM2022
     * const tBEventReg_ACM2022 = await prisma.tBEventReg_ACM2022.upsert({
     *   create: {
     *     // ... data to create a TBEventReg_ACM2022
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TBEventReg_ACM2022 we want to update
     *   }
     * })
    **/
    upsert<T extends TBEventReg_ACM2022UpsertArgs>(
      args: SelectSubset<T, TBEventReg_ACM2022UpsertArgs>
    ): Prisma__TBEventReg_ACM2022Client<TBEventReg_ACM2022GetPayload<T>>

    /**
     * Count the number of TBEventReg_ACM2022s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2022CountArgs} args - Arguments to filter TBEventReg_ACM2022s to count.
     * @example
     * // Count the number of TBEventReg_ACM2022s
     * const count = await prisma.tBEventReg_ACM2022.count({
     *   where: {
     *     // ... the filter for the TBEventReg_ACM2022s we want to count
     *   }
     * })
    **/
    count<T extends TBEventReg_ACM2022CountArgs>(
      args?: Subset<T, TBEventReg_ACM2022CountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TBEventReg_ACM2022CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TBEventReg_ACM2022.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2022AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TBEventReg_ACM2022AggregateArgs>(args: Subset<T, TBEventReg_ACM2022AggregateArgs>): Prisma.PrismaPromise<GetTBEventReg_ACM2022AggregateType<T>>

    /**
     * Group by TBEventReg_ACM2022.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ACM2022GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TBEventReg_ACM2022GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TBEventReg_ACM2022GroupByArgs['orderBy'] }
        : { orderBy?: TBEventReg_ACM2022GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TBEventReg_ACM2022GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTBEventReg_ACM2022GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TBEventReg_ACM2022.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TBEventReg_ACM2022Client<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TBEventReg_ACM2022 base type for findUnique actions
   */
  export type TBEventReg_ACM2022FindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2022
     */
    select?: TBEventReg_ACM2022Select | null
    /**
     * Filter, which TBEventReg_ACM2022 to fetch.
     */
    where: TBEventReg_ACM2022WhereUniqueInput
  }

  /**
   * TBEventReg_ACM2022 findUnique
   */
  export interface TBEventReg_ACM2022FindUniqueArgs extends TBEventReg_ACM2022FindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_ACM2022 findUniqueOrThrow
   */
  export type TBEventReg_ACM2022FindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2022
     */
    select?: TBEventReg_ACM2022Select | null
    /**
     * Filter, which TBEventReg_ACM2022 to fetch.
     */
    where: TBEventReg_ACM2022WhereUniqueInput
  }


  /**
   * TBEventReg_ACM2022 base type for findFirst actions
   */
  export type TBEventReg_ACM2022FindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2022
     */
    select?: TBEventReg_ACM2022Select | null
    /**
     * Filter, which TBEventReg_ACM2022 to fetch.
     */
    where?: TBEventReg_ACM2022WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ACM2022s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ACM2022OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_ACM2022s.
     */
    cursor?: TBEventReg_ACM2022WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ACM2022s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ACM2022s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_ACM2022s.
     */
    distinct?: Enumerable<TBEventReg_ACM2022ScalarFieldEnum>
  }

  /**
   * TBEventReg_ACM2022 findFirst
   */
  export interface TBEventReg_ACM2022FindFirstArgs extends TBEventReg_ACM2022FindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_ACM2022 findFirstOrThrow
   */
  export type TBEventReg_ACM2022FindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2022
     */
    select?: TBEventReg_ACM2022Select | null
    /**
     * Filter, which TBEventReg_ACM2022 to fetch.
     */
    where?: TBEventReg_ACM2022WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ACM2022s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ACM2022OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_ACM2022s.
     */
    cursor?: TBEventReg_ACM2022WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ACM2022s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ACM2022s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_ACM2022s.
     */
    distinct?: Enumerable<TBEventReg_ACM2022ScalarFieldEnum>
  }


  /**
   * TBEventReg_ACM2022 findMany
   */
  export type TBEventReg_ACM2022FindManyArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2022
     */
    select?: TBEventReg_ACM2022Select | null
    /**
     * Filter, which TBEventReg_ACM2022s to fetch.
     */
    where?: TBEventReg_ACM2022WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ACM2022s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ACM2022OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TBEventReg_ACM2022s.
     */
    cursor?: TBEventReg_ACM2022WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ACM2022s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ACM2022s.
     */
    skip?: number
    distinct?: Enumerable<TBEventReg_ACM2022ScalarFieldEnum>
  }


  /**
   * TBEventReg_ACM2022 create
   */
  export type TBEventReg_ACM2022CreateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2022
     */
    select?: TBEventReg_ACM2022Select | null
    /**
     * The data needed to create a TBEventReg_ACM2022.
     */
    data: XOR<TBEventReg_ACM2022CreateInput, TBEventReg_ACM2022UncheckedCreateInput>
  }


  /**
   * TBEventReg_ACM2022 createMany
   */
  export type TBEventReg_ACM2022CreateManyArgs = {
    /**
     * The data used to create many TBEventReg_ACM2022s.
     */
    data: Enumerable<TBEventReg_ACM2022CreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TBEventReg_ACM2022 update
   */
  export type TBEventReg_ACM2022UpdateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2022
     */
    select?: TBEventReg_ACM2022Select | null
    /**
     * The data needed to update a TBEventReg_ACM2022.
     */
    data: XOR<TBEventReg_ACM2022UpdateInput, TBEventReg_ACM2022UncheckedUpdateInput>
    /**
     * Choose, which TBEventReg_ACM2022 to update.
     */
    where: TBEventReg_ACM2022WhereUniqueInput
  }


  /**
   * TBEventReg_ACM2022 updateMany
   */
  export type TBEventReg_ACM2022UpdateManyArgs = {
    /**
     * The data used to update TBEventReg_ACM2022s.
     */
    data: XOR<TBEventReg_ACM2022UpdateManyMutationInput, TBEventReg_ACM2022UncheckedUpdateManyInput>
    /**
     * Filter which TBEventReg_ACM2022s to update
     */
    where?: TBEventReg_ACM2022WhereInput
  }


  /**
   * TBEventReg_ACM2022 upsert
   */
  export type TBEventReg_ACM2022UpsertArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2022
     */
    select?: TBEventReg_ACM2022Select | null
    /**
     * The filter to search for the TBEventReg_ACM2022 to update in case it exists.
     */
    where: TBEventReg_ACM2022WhereUniqueInput
    /**
     * In case the TBEventReg_ACM2022 found by the `where` argument doesn't exist, create a new TBEventReg_ACM2022 with this data.
     */
    create: XOR<TBEventReg_ACM2022CreateInput, TBEventReg_ACM2022UncheckedCreateInput>
    /**
     * In case the TBEventReg_ACM2022 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TBEventReg_ACM2022UpdateInput, TBEventReg_ACM2022UncheckedUpdateInput>
  }


  /**
   * TBEventReg_ACM2022 delete
   */
  export type TBEventReg_ACM2022DeleteArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2022
     */
    select?: TBEventReg_ACM2022Select | null
    /**
     * Filter which TBEventReg_ACM2022 to delete.
     */
    where: TBEventReg_ACM2022WhereUniqueInput
  }


  /**
   * TBEventReg_ACM2022 deleteMany
   */
  export type TBEventReg_ACM2022DeleteManyArgs = {
    /**
     * Filter which TBEventReg_ACM2022s to delete
     */
    where?: TBEventReg_ACM2022WhereInput
  }


  /**
   * TBEventReg_ACM2022 without action
   */
  export type TBEventReg_ACM2022Args = {
    /**
     * Select specific fields to fetch from the TBEventReg_ACM2022
     */
    select?: TBEventReg_ACM2022Select | null
  }



  /**
   * Model TBEventReg_ChessChampionship2019
   */


  export type AggregateTBEventReg_ChessChampionship2019 = {
    _count: TBEventReg_ChessChampionship2019CountAggregateOutputType | null
    _avg: TBEventReg_ChessChampionship2019AvgAggregateOutputType | null
    _sum: TBEventReg_ChessChampionship2019SumAggregateOutputType | null
    _min: TBEventReg_ChessChampionship2019MinAggregateOutputType | null
    _max: TBEventReg_ChessChampionship2019MaxAggregateOutputType | null
  }

  export type TBEventReg_ChessChampionship2019AvgAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_ChessChampionship2019SumAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_ChessChampionship2019MinAggregateOutputType = {
    ID: number | null
    EventTitle: string | null
    RegNameFirst: string | null
    RegNameLast: string | null
    RegDOB: Date | null
    RegEmail: string | null
    RegTel: string | null
    ParentNameFirst: string | null
    ParentNameLast: string | null
    ParentTel: string | null
    ParentEmail: string | null
    RegDate: Date | null
    RegIP: string | null
  }

  export type TBEventReg_ChessChampionship2019MaxAggregateOutputType = {
    ID: number | null
    EventTitle: string | null
    RegNameFirst: string | null
    RegNameLast: string | null
    RegDOB: Date | null
    RegEmail: string | null
    RegTel: string | null
    ParentNameFirst: string | null
    ParentNameLast: string | null
    ParentTel: string | null
    ParentEmail: string | null
    RegDate: Date | null
    RegIP: string | null
  }

  export type TBEventReg_ChessChampionship2019CountAggregateOutputType = {
    ID: number
    EventTitle: number
    RegNameFirst: number
    RegNameLast: number
    RegDOB: number
    RegEmail: number
    RegTel: number
    ParentNameFirst: number
    ParentNameLast: number
    ParentTel: number
    ParentEmail: number
    RegDate: number
    RegIP: number
    _all: number
  }


  export type TBEventReg_ChessChampionship2019AvgAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_ChessChampionship2019SumAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_ChessChampionship2019MinAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegNameFirst?: true
    RegNameLast?: true
    RegDOB?: true
    RegEmail?: true
    RegTel?: true
    ParentNameFirst?: true
    ParentNameLast?: true
    ParentTel?: true
    ParentEmail?: true
    RegDate?: true
    RegIP?: true
  }

  export type TBEventReg_ChessChampionship2019MaxAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegNameFirst?: true
    RegNameLast?: true
    RegDOB?: true
    RegEmail?: true
    RegTel?: true
    ParentNameFirst?: true
    ParentNameLast?: true
    ParentTel?: true
    ParentEmail?: true
    RegDate?: true
    RegIP?: true
  }

  export type TBEventReg_ChessChampionship2019CountAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegNameFirst?: true
    RegNameLast?: true
    RegDOB?: true
    RegEmail?: true
    RegTel?: true
    ParentNameFirst?: true
    ParentNameLast?: true
    ParentTel?: true
    ParentEmail?: true
    RegDate?: true
    RegIP?: true
    _all?: true
  }

  export type TBEventReg_ChessChampionship2019AggregateArgs = {
    /**
     * Filter which TBEventReg_ChessChampionship2019 to aggregate.
     */
    where?: TBEventReg_ChessChampionship2019WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ChessChampionship2019s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ChessChampionship2019OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TBEventReg_ChessChampionship2019WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ChessChampionship2019s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ChessChampionship2019s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TBEventReg_ChessChampionship2019s
    **/
    _count?: true | TBEventReg_ChessChampionship2019CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TBEventReg_ChessChampionship2019AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TBEventReg_ChessChampionship2019SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TBEventReg_ChessChampionship2019MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TBEventReg_ChessChampionship2019MaxAggregateInputType
  }

  export type GetTBEventReg_ChessChampionship2019AggregateType<T extends TBEventReg_ChessChampionship2019AggregateArgs> = {
        [P in keyof T & keyof AggregateTBEventReg_ChessChampionship2019]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTBEventReg_ChessChampionship2019[P]>
      : GetScalarType<T[P], AggregateTBEventReg_ChessChampionship2019[P]>
  }




  export type TBEventReg_ChessChampionship2019GroupByArgs = {
    where?: TBEventReg_ChessChampionship2019WhereInput
    orderBy?: Enumerable<TBEventReg_ChessChampionship2019OrderByWithAggregationInput>
    by: TBEventReg_ChessChampionship2019ScalarFieldEnum[]
    having?: TBEventReg_ChessChampionship2019ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TBEventReg_ChessChampionship2019CountAggregateInputType | true
    _avg?: TBEventReg_ChessChampionship2019AvgAggregateInputType
    _sum?: TBEventReg_ChessChampionship2019SumAggregateInputType
    _min?: TBEventReg_ChessChampionship2019MinAggregateInputType
    _max?: TBEventReg_ChessChampionship2019MaxAggregateInputType
  }


  export type TBEventReg_ChessChampionship2019GroupByOutputType = {
    ID: number
    EventTitle: string
    RegNameFirst: string
    RegNameLast: string
    RegDOB: Date
    RegEmail: string
    RegTel: string
    ParentNameFirst: string
    ParentNameLast: string
    ParentTel: string
    ParentEmail: string
    RegDate: Date
    RegIP: string
    _count: TBEventReg_ChessChampionship2019CountAggregateOutputType | null
    _avg: TBEventReg_ChessChampionship2019AvgAggregateOutputType | null
    _sum: TBEventReg_ChessChampionship2019SumAggregateOutputType | null
    _min: TBEventReg_ChessChampionship2019MinAggregateOutputType | null
    _max: TBEventReg_ChessChampionship2019MaxAggregateOutputType | null
  }

  type GetTBEventReg_ChessChampionship2019GroupByPayload<T extends TBEventReg_ChessChampionship2019GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TBEventReg_ChessChampionship2019GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TBEventReg_ChessChampionship2019GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TBEventReg_ChessChampionship2019GroupByOutputType[P]>
            : GetScalarType<T[P], TBEventReg_ChessChampionship2019GroupByOutputType[P]>
        }
      >
    >


  export type TBEventReg_ChessChampionship2019Select = {
    ID?: boolean
    EventTitle?: boolean
    RegNameFirst?: boolean
    RegNameLast?: boolean
    RegDOB?: boolean
    RegEmail?: boolean
    RegTel?: boolean
    ParentNameFirst?: boolean
    ParentNameLast?: boolean
    ParentTel?: boolean
    ParentEmail?: boolean
    RegDate?: boolean
    RegIP?: boolean
  }


  export type TBEventReg_ChessChampionship2019GetPayload<S extends boolean | null | undefined | TBEventReg_ChessChampionship2019Args> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TBEventReg_ChessChampionship2019 :
    S extends undefined ? never :
    S extends { include: any } & (TBEventReg_ChessChampionship2019Args | TBEventReg_ChessChampionship2019FindManyArgs)
    ? TBEventReg_ChessChampionship2019 
    : S extends { select: any } & (TBEventReg_ChessChampionship2019Args | TBEventReg_ChessChampionship2019FindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TBEventReg_ChessChampionship2019 ? TBEventReg_ChessChampionship2019[P] : never
  } 
      : TBEventReg_ChessChampionship2019


  type TBEventReg_ChessChampionship2019CountArgs = 
    Omit<TBEventReg_ChessChampionship2019FindManyArgs, 'select' | 'include'> & {
      select?: TBEventReg_ChessChampionship2019CountAggregateInputType | true
    }

  export interface TBEventReg_ChessChampionship2019Delegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TBEventReg_ChessChampionship2019 that matches the filter.
     * @param {TBEventReg_ChessChampionship2019FindUniqueArgs} args - Arguments to find a TBEventReg_ChessChampionship2019
     * @example
     * // Get one TBEventReg_ChessChampionship2019
     * const tBEventReg_ChessChampionship2019 = await prisma.tBEventReg_ChessChampionship2019.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TBEventReg_ChessChampionship2019FindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TBEventReg_ChessChampionship2019FindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TBEventReg_ChessChampionship2019'> extends True ? Prisma__TBEventReg_ChessChampionship2019Client<TBEventReg_ChessChampionship2019GetPayload<T>> : Prisma__TBEventReg_ChessChampionship2019Client<TBEventReg_ChessChampionship2019GetPayload<T> | null, null>

    /**
     * Find one TBEventReg_ChessChampionship2019 that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TBEventReg_ChessChampionship2019FindUniqueOrThrowArgs} args - Arguments to find a TBEventReg_ChessChampionship2019
     * @example
     * // Get one TBEventReg_ChessChampionship2019
     * const tBEventReg_ChessChampionship2019 = await prisma.tBEventReg_ChessChampionship2019.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TBEventReg_ChessChampionship2019FindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_ChessChampionship2019FindUniqueOrThrowArgs>
    ): Prisma__TBEventReg_ChessChampionship2019Client<TBEventReg_ChessChampionship2019GetPayload<T>>

    /**
     * Find the first TBEventReg_ChessChampionship2019 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ChessChampionship2019FindFirstArgs} args - Arguments to find a TBEventReg_ChessChampionship2019
     * @example
     * // Get one TBEventReg_ChessChampionship2019
     * const tBEventReg_ChessChampionship2019 = await prisma.tBEventReg_ChessChampionship2019.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TBEventReg_ChessChampionship2019FindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TBEventReg_ChessChampionship2019FindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TBEventReg_ChessChampionship2019'> extends True ? Prisma__TBEventReg_ChessChampionship2019Client<TBEventReg_ChessChampionship2019GetPayload<T>> : Prisma__TBEventReg_ChessChampionship2019Client<TBEventReg_ChessChampionship2019GetPayload<T> | null, null>

    /**
     * Find the first TBEventReg_ChessChampionship2019 that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ChessChampionship2019FindFirstOrThrowArgs} args - Arguments to find a TBEventReg_ChessChampionship2019
     * @example
     * // Get one TBEventReg_ChessChampionship2019
     * const tBEventReg_ChessChampionship2019 = await prisma.tBEventReg_ChessChampionship2019.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TBEventReg_ChessChampionship2019FindFirstOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_ChessChampionship2019FindFirstOrThrowArgs>
    ): Prisma__TBEventReg_ChessChampionship2019Client<TBEventReg_ChessChampionship2019GetPayload<T>>

    /**
     * Find zero or more TBEventReg_ChessChampionship2019s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ChessChampionship2019FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TBEventReg_ChessChampionship2019s
     * const tBEventReg_ChessChampionship2019s = await prisma.tBEventReg_ChessChampionship2019.findMany()
     * 
     * // Get first 10 TBEventReg_ChessChampionship2019s
     * const tBEventReg_ChessChampionship2019s = await prisma.tBEventReg_ChessChampionship2019.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tBEventReg_ChessChampionship2019WithIDOnly = await prisma.tBEventReg_ChessChampionship2019.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends TBEventReg_ChessChampionship2019FindManyArgs>(
      args?: SelectSubset<T, TBEventReg_ChessChampionship2019FindManyArgs>
    ): Prisma.PrismaPromise<Array<TBEventReg_ChessChampionship2019GetPayload<T>>>

    /**
     * Create a TBEventReg_ChessChampionship2019.
     * @param {TBEventReg_ChessChampionship2019CreateArgs} args - Arguments to create a TBEventReg_ChessChampionship2019.
     * @example
     * // Create one TBEventReg_ChessChampionship2019
     * const TBEventReg_ChessChampionship2019 = await prisma.tBEventReg_ChessChampionship2019.create({
     *   data: {
     *     // ... data to create a TBEventReg_ChessChampionship2019
     *   }
     * })
     * 
    **/
    create<T extends TBEventReg_ChessChampionship2019CreateArgs>(
      args: SelectSubset<T, TBEventReg_ChessChampionship2019CreateArgs>
    ): Prisma__TBEventReg_ChessChampionship2019Client<TBEventReg_ChessChampionship2019GetPayload<T>>

    /**
     * Create many TBEventReg_ChessChampionship2019s.
     *     @param {TBEventReg_ChessChampionship2019CreateManyArgs} args - Arguments to create many TBEventReg_ChessChampionship2019s.
     *     @example
     *     // Create many TBEventReg_ChessChampionship2019s
     *     const tBEventReg_ChessChampionship2019 = await prisma.tBEventReg_ChessChampionship2019.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TBEventReg_ChessChampionship2019CreateManyArgs>(
      args?: SelectSubset<T, TBEventReg_ChessChampionship2019CreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TBEventReg_ChessChampionship2019.
     * @param {TBEventReg_ChessChampionship2019DeleteArgs} args - Arguments to delete one TBEventReg_ChessChampionship2019.
     * @example
     * // Delete one TBEventReg_ChessChampionship2019
     * const TBEventReg_ChessChampionship2019 = await prisma.tBEventReg_ChessChampionship2019.delete({
     *   where: {
     *     // ... filter to delete one TBEventReg_ChessChampionship2019
     *   }
     * })
     * 
    **/
    delete<T extends TBEventReg_ChessChampionship2019DeleteArgs>(
      args: SelectSubset<T, TBEventReg_ChessChampionship2019DeleteArgs>
    ): Prisma__TBEventReg_ChessChampionship2019Client<TBEventReg_ChessChampionship2019GetPayload<T>>

    /**
     * Update one TBEventReg_ChessChampionship2019.
     * @param {TBEventReg_ChessChampionship2019UpdateArgs} args - Arguments to update one TBEventReg_ChessChampionship2019.
     * @example
     * // Update one TBEventReg_ChessChampionship2019
     * const tBEventReg_ChessChampionship2019 = await prisma.tBEventReg_ChessChampionship2019.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TBEventReg_ChessChampionship2019UpdateArgs>(
      args: SelectSubset<T, TBEventReg_ChessChampionship2019UpdateArgs>
    ): Prisma__TBEventReg_ChessChampionship2019Client<TBEventReg_ChessChampionship2019GetPayload<T>>

    /**
     * Delete zero or more TBEventReg_ChessChampionship2019s.
     * @param {TBEventReg_ChessChampionship2019DeleteManyArgs} args - Arguments to filter TBEventReg_ChessChampionship2019s to delete.
     * @example
     * // Delete a few TBEventReg_ChessChampionship2019s
     * const { count } = await prisma.tBEventReg_ChessChampionship2019.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TBEventReg_ChessChampionship2019DeleteManyArgs>(
      args?: SelectSubset<T, TBEventReg_ChessChampionship2019DeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TBEventReg_ChessChampionship2019s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ChessChampionship2019UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TBEventReg_ChessChampionship2019s
     * const tBEventReg_ChessChampionship2019 = await prisma.tBEventReg_ChessChampionship2019.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TBEventReg_ChessChampionship2019UpdateManyArgs>(
      args: SelectSubset<T, TBEventReg_ChessChampionship2019UpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TBEventReg_ChessChampionship2019.
     * @param {TBEventReg_ChessChampionship2019UpsertArgs} args - Arguments to update or create a TBEventReg_ChessChampionship2019.
     * @example
     * // Update or create a TBEventReg_ChessChampionship2019
     * const tBEventReg_ChessChampionship2019 = await prisma.tBEventReg_ChessChampionship2019.upsert({
     *   create: {
     *     // ... data to create a TBEventReg_ChessChampionship2019
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TBEventReg_ChessChampionship2019 we want to update
     *   }
     * })
    **/
    upsert<T extends TBEventReg_ChessChampionship2019UpsertArgs>(
      args: SelectSubset<T, TBEventReg_ChessChampionship2019UpsertArgs>
    ): Prisma__TBEventReg_ChessChampionship2019Client<TBEventReg_ChessChampionship2019GetPayload<T>>

    /**
     * Count the number of TBEventReg_ChessChampionship2019s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ChessChampionship2019CountArgs} args - Arguments to filter TBEventReg_ChessChampionship2019s to count.
     * @example
     * // Count the number of TBEventReg_ChessChampionship2019s
     * const count = await prisma.tBEventReg_ChessChampionship2019.count({
     *   where: {
     *     // ... the filter for the TBEventReg_ChessChampionship2019s we want to count
     *   }
     * })
    **/
    count<T extends TBEventReg_ChessChampionship2019CountArgs>(
      args?: Subset<T, TBEventReg_ChessChampionship2019CountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TBEventReg_ChessChampionship2019CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TBEventReg_ChessChampionship2019.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ChessChampionship2019AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TBEventReg_ChessChampionship2019AggregateArgs>(args: Subset<T, TBEventReg_ChessChampionship2019AggregateArgs>): Prisma.PrismaPromise<GetTBEventReg_ChessChampionship2019AggregateType<T>>

    /**
     * Group by TBEventReg_ChessChampionship2019.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_ChessChampionship2019GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TBEventReg_ChessChampionship2019GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TBEventReg_ChessChampionship2019GroupByArgs['orderBy'] }
        : { orderBy?: TBEventReg_ChessChampionship2019GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TBEventReg_ChessChampionship2019GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTBEventReg_ChessChampionship2019GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TBEventReg_ChessChampionship2019.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TBEventReg_ChessChampionship2019Client<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TBEventReg_ChessChampionship2019 base type for findUnique actions
   */
  export type TBEventReg_ChessChampionship2019FindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_ChessChampionship2019
     */
    select?: TBEventReg_ChessChampionship2019Select | null
    /**
     * Filter, which TBEventReg_ChessChampionship2019 to fetch.
     */
    where: TBEventReg_ChessChampionship2019WhereUniqueInput
  }

  /**
   * TBEventReg_ChessChampionship2019 findUnique
   */
  export interface TBEventReg_ChessChampionship2019FindUniqueArgs extends TBEventReg_ChessChampionship2019FindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_ChessChampionship2019 findUniqueOrThrow
   */
  export type TBEventReg_ChessChampionship2019FindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ChessChampionship2019
     */
    select?: TBEventReg_ChessChampionship2019Select | null
    /**
     * Filter, which TBEventReg_ChessChampionship2019 to fetch.
     */
    where: TBEventReg_ChessChampionship2019WhereUniqueInput
  }


  /**
   * TBEventReg_ChessChampionship2019 base type for findFirst actions
   */
  export type TBEventReg_ChessChampionship2019FindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_ChessChampionship2019
     */
    select?: TBEventReg_ChessChampionship2019Select | null
    /**
     * Filter, which TBEventReg_ChessChampionship2019 to fetch.
     */
    where?: TBEventReg_ChessChampionship2019WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ChessChampionship2019s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ChessChampionship2019OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_ChessChampionship2019s.
     */
    cursor?: TBEventReg_ChessChampionship2019WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ChessChampionship2019s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ChessChampionship2019s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_ChessChampionship2019s.
     */
    distinct?: Enumerable<TBEventReg_ChessChampionship2019ScalarFieldEnum>
  }

  /**
   * TBEventReg_ChessChampionship2019 findFirst
   */
  export interface TBEventReg_ChessChampionship2019FindFirstArgs extends TBEventReg_ChessChampionship2019FindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_ChessChampionship2019 findFirstOrThrow
   */
  export type TBEventReg_ChessChampionship2019FindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ChessChampionship2019
     */
    select?: TBEventReg_ChessChampionship2019Select | null
    /**
     * Filter, which TBEventReg_ChessChampionship2019 to fetch.
     */
    where?: TBEventReg_ChessChampionship2019WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ChessChampionship2019s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ChessChampionship2019OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_ChessChampionship2019s.
     */
    cursor?: TBEventReg_ChessChampionship2019WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ChessChampionship2019s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ChessChampionship2019s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_ChessChampionship2019s.
     */
    distinct?: Enumerable<TBEventReg_ChessChampionship2019ScalarFieldEnum>
  }


  /**
   * TBEventReg_ChessChampionship2019 findMany
   */
  export type TBEventReg_ChessChampionship2019FindManyArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ChessChampionship2019
     */
    select?: TBEventReg_ChessChampionship2019Select | null
    /**
     * Filter, which TBEventReg_ChessChampionship2019s to fetch.
     */
    where?: TBEventReg_ChessChampionship2019WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_ChessChampionship2019s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_ChessChampionship2019OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TBEventReg_ChessChampionship2019s.
     */
    cursor?: TBEventReg_ChessChampionship2019WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_ChessChampionship2019s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_ChessChampionship2019s.
     */
    skip?: number
    distinct?: Enumerable<TBEventReg_ChessChampionship2019ScalarFieldEnum>
  }


  /**
   * TBEventReg_ChessChampionship2019 create
   */
  export type TBEventReg_ChessChampionship2019CreateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ChessChampionship2019
     */
    select?: TBEventReg_ChessChampionship2019Select | null
    /**
     * The data needed to create a TBEventReg_ChessChampionship2019.
     */
    data: XOR<TBEventReg_ChessChampionship2019CreateInput, TBEventReg_ChessChampionship2019UncheckedCreateInput>
  }


  /**
   * TBEventReg_ChessChampionship2019 createMany
   */
  export type TBEventReg_ChessChampionship2019CreateManyArgs = {
    /**
     * The data used to create many TBEventReg_ChessChampionship2019s.
     */
    data: Enumerable<TBEventReg_ChessChampionship2019CreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TBEventReg_ChessChampionship2019 update
   */
  export type TBEventReg_ChessChampionship2019UpdateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ChessChampionship2019
     */
    select?: TBEventReg_ChessChampionship2019Select | null
    /**
     * The data needed to update a TBEventReg_ChessChampionship2019.
     */
    data: XOR<TBEventReg_ChessChampionship2019UpdateInput, TBEventReg_ChessChampionship2019UncheckedUpdateInput>
    /**
     * Choose, which TBEventReg_ChessChampionship2019 to update.
     */
    where: TBEventReg_ChessChampionship2019WhereUniqueInput
  }


  /**
   * TBEventReg_ChessChampionship2019 updateMany
   */
  export type TBEventReg_ChessChampionship2019UpdateManyArgs = {
    /**
     * The data used to update TBEventReg_ChessChampionship2019s.
     */
    data: XOR<TBEventReg_ChessChampionship2019UpdateManyMutationInput, TBEventReg_ChessChampionship2019UncheckedUpdateManyInput>
    /**
     * Filter which TBEventReg_ChessChampionship2019s to update
     */
    where?: TBEventReg_ChessChampionship2019WhereInput
  }


  /**
   * TBEventReg_ChessChampionship2019 upsert
   */
  export type TBEventReg_ChessChampionship2019UpsertArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ChessChampionship2019
     */
    select?: TBEventReg_ChessChampionship2019Select | null
    /**
     * The filter to search for the TBEventReg_ChessChampionship2019 to update in case it exists.
     */
    where: TBEventReg_ChessChampionship2019WhereUniqueInput
    /**
     * In case the TBEventReg_ChessChampionship2019 found by the `where` argument doesn't exist, create a new TBEventReg_ChessChampionship2019 with this data.
     */
    create: XOR<TBEventReg_ChessChampionship2019CreateInput, TBEventReg_ChessChampionship2019UncheckedCreateInput>
    /**
     * In case the TBEventReg_ChessChampionship2019 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TBEventReg_ChessChampionship2019UpdateInput, TBEventReg_ChessChampionship2019UncheckedUpdateInput>
  }


  /**
   * TBEventReg_ChessChampionship2019 delete
   */
  export type TBEventReg_ChessChampionship2019DeleteArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_ChessChampionship2019
     */
    select?: TBEventReg_ChessChampionship2019Select | null
    /**
     * Filter which TBEventReg_ChessChampionship2019 to delete.
     */
    where: TBEventReg_ChessChampionship2019WhereUniqueInput
  }


  /**
   * TBEventReg_ChessChampionship2019 deleteMany
   */
  export type TBEventReg_ChessChampionship2019DeleteManyArgs = {
    /**
     * Filter which TBEventReg_ChessChampionship2019s to delete
     */
    where?: TBEventReg_ChessChampionship2019WhereInput
  }


  /**
   * TBEventReg_ChessChampionship2019 without action
   */
  export type TBEventReg_ChessChampionship2019Args = {
    /**
     * Select specific fields to fetch from the TBEventReg_ChessChampionship2019
     */
    select?: TBEventReg_ChessChampionship2019Select | null
  }



  /**
   * Model TBEventReg_SEEE_2017
   */


  export type AggregateTBEventReg_SEEE_2017 = {
    _count: TBEventReg_SEEE_2017CountAggregateOutputType | null
    _avg: TBEventReg_SEEE_2017AvgAggregateOutputType | null
    _sum: TBEventReg_SEEE_2017SumAggregateOutputType | null
    _min: TBEventReg_SEEE_2017MinAggregateOutputType | null
    _max: TBEventReg_SEEE_2017MaxAggregateOutputType | null
  }

  export type TBEventReg_SEEE_2017AvgAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_SEEE_2017SumAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_SEEE_2017MinAggregateOutputType = {
    ID: number | null
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegDate: Date | null
    RegIP: string | null
    RegLunch: string | null
  }

  export type TBEventReg_SEEE_2017MaxAggregateOutputType = {
    ID: number | null
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegDate: Date | null
    RegIP: string | null
    RegLunch: string | null
  }

  export type TBEventReg_SEEE_2017CountAggregateOutputType = {
    ID: number
    EventTitle: number
    RegName: number
    RegEmail: number
    RegTel: number
    RegAddress: number
    RegDate: number
    RegIP: number
    RegLunch: number
    _all: number
  }


  export type TBEventReg_SEEE_2017AvgAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_SEEE_2017SumAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_SEEE_2017MinAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegDate?: true
    RegIP?: true
    RegLunch?: true
  }

  export type TBEventReg_SEEE_2017MaxAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegDate?: true
    RegIP?: true
    RegLunch?: true
  }

  export type TBEventReg_SEEE_2017CountAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegDate?: true
    RegIP?: true
    RegLunch?: true
    _all?: true
  }

  export type TBEventReg_SEEE_2017AggregateArgs = {
    /**
     * Filter which TBEventReg_SEEE_2017 to aggregate.
     */
    where?: TBEventReg_SEEE_2017WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2017s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2017OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TBEventReg_SEEE_2017WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2017s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2017s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TBEventReg_SEEE_2017s
    **/
    _count?: true | TBEventReg_SEEE_2017CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TBEventReg_SEEE_2017AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TBEventReg_SEEE_2017SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TBEventReg_SEEE_2017MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TBEventReg_SEEE_2017MaxAggregateInputType
  }

  export type GetTBEventReg_SEEE_2017AggregateType<T extends TBEventReg_SEEE_2017AggregateArgs> = {
        [P in keyof T & keyof AggregateTBEventReg_SEEE_2017]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTBEventReg_SEEE_2017[P]>
      : GetScalarType<T[P], AggregateTBEventReg_SEEE_2017[P]>
  }




  export type TBEventReg_SEEE_2017GroupByArgs = {
    where?: TBEventReg_SEEE_2017WhereInput
    orderBy?: Enumerable<TBEventReg_SEEE_2017OrderByWithAggregationInput>
    by: TBEventReg_SEEE_2017ScalarFieldEnum[]
    having?: TBEventReg_SEEE_2017ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TBEventReg_SEEE_2017CountAggregateInputType | true
    _avg?: TBEventReg_SEEE_2017AvgAggregateInputType
    _sum?: TBEventReg_SEEE_2017SumAggregateInputType
    _min?: TBEventReg_SEEE_2017MinAggregateInputType
    _max?: TBEventReg_SEEE_2017MaxAggregateInputType
  }


  export type TBEventReg_SEEE_2017GroupByOutputType = {
    ID: number
    EventTitle: string
    RegName: string
    RegEmail: string
    RegTel: string
    RegAddress: string
    RegDate: Date
    RegIP: string
    RegLunch: string | null
    _count: TBEventReg_SEEE_2017CountAggregateOutputType | null
    _avg: TBEventReg_SEEE_2017AvgAggregateOutputType | null
    _sum: TBEventReg_SEEE_2017SumAggregateOutputType | null
    _min: TBEventReg_SEEE_2017MinAggregateOutputType | null
    _max: TBEventReg_SEEE_2017MaxAggregateOutputType | null
  }

  type GetTBEventReg_SEEE_2017GroupByPayload<T extends TBEventReg_SEEE_2017GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TBEventReg_SEEE_2017GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TBEventReg_SEEE_2017GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TBEventReg_SEEE_2017GroupByOutputType[P]>
            : GetScalarType<T[P], TBEventReg_SEEE_2017GroupByOutputType[P]>
        }
      >
    >


  export type TBEventReg_SEEE_2017Select = {
    ID?: boolean
    EventTitle?: boolean
    RegName?: boolean
    RegEmail?: boolean
    RegTel?: boolean
    RegAddress?: boolean
    RegDate?: boolean
    RegIP?: boolean
    RegLunch?: boolean
  }


  export type TBEventReg_SEEE_2017GetPayload<S extends boolean | null | undefined | TBEventReg_SEEE_2017Args> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TBEventReg_SEEE_2017 :
    S extends undefined ? never :
    S extends { include: any } & (TBEventReg_SEEE_2017Args | TBEventReg_SEEE_2017FindManyArgs)
    ? TBEventReg_SEEE_2017 
    : S extends { select: any } & (TBEventReg_SEEE_2017Args | TBEventReg_SEEE_2017FindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TBEventReg_SEEE_2017 ? TBEventReg_SEEE_2017[P] : never
  } 
      : TBEventReg_SEEE_2017


  type TBEventReg_SEEE_2017CountArgs = 
    Omit<TBEventReg_SEEE_2017FindManyArgs, 'select' | 'include'> & {
      select?: TBEventReg_SEEE_2017CountAggregateInputType | true
    }

  export interface TBEventReg_SEEE_2017Delegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TBEventReg_SEEE_2017 that matches the filter.
     * @param {TBEventReg_SEEE_2017FindUniqueArgs} args - Arguments to find a TBEventReg_SEEE_2017
     * @example
     * // Get one TBEventReg_SEEE_2017
     * const tBEventReg_SEEE_2017 = await prisma.tBEventReg_SEEE_2017.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TBEventReg_SEEE_2017FindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TBEventReg_SEEE_2017FindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TBEventReg_SEEE_2017'> extends True ? Prisma__TBEventReg_SEEE_2017Client<TBEventReg_SEEE_2017GetPayload<T>> : Prisma__TBEventReg_SEEE_2017Client<TBEventReg_SEEE_2017GetPayload<T> | null, null>

    /**
     * Find one TBEventReg_SEEE_2017 that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TBEventReg_SEEE_2017FindUniqueOrThrowArgs} args - Arguments to find a TBEventReg_SEEE_2017
     * @example
     * // Get one TBEventReg_SEEE_2017
     * const tBEventReg_SEEE_2017 = await prisma.tBEventReg_SEEE_2017.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TBEventReg_SEEE_2017FindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2017FindUniqueOrThrowArgs>
    ): Prisma__TBEventReg_SEEE_2017Client<TBEventReg_SEEE_2017GetPayload<T>>

    /**
     * Find the first TBEventReg_SEEE_2017 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2017FindFirstArgs} args - Arguments to find a TBEventReg_SEEE_2017
     * @example
     * // Get one TBEventReg_SEEE_2017
     * const tBEventReg_SEEE_2017 = await prisma.tBEventReg_SEEE_2017.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TBEventReg_SEEE_2017FindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TBEventReg_SEEE_2017FindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TBEventReg_SEEE_2017'> extends True ? Prisma__TBEventReg_SEEE_2017Client<TBEventReg_SEEE_2017GetPayload<T>> : Prisma__TBEventReg_SEEE_2017Client<TBEventReg_SEEE_2017GetPayload<T> | null, null>

    /**
     * Find the first TBEventReg_SEEE_2017 that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2017FindFirstOrThrowArgs} args - Arguments to find a TBEventReg_SEEE_2017
     * @example
     * // Get one TBEventReg_SEEE_2017
     * const tBEventReg_SEEE_2017 = await prisma.tBEventReg_SEEE_2017.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TBEventReg_SEEE_2017FindFirstOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2017FindFirstOrThrowArgs>
    ): Prisma__TBEventReg_SEEE_2017Client<TBEventReg_SEEE_2017GetPayload<T>>

    /**
     * Find zero or more TBEventReg_SEEE_2017s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2017FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TBEventReg_SEEE_2017s
     * const tBEventReg_SEEE_2017s = await prisma.tBEventReg_SEEE_2017.findMany()
     * 
     * // Get first 10 TBEventReg_SEEE_2017s
     * const tBEventReg_SEEE_2017s = await prisma.tBEventReg_SEEE_2017.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tBEventReg_SEEE_2017WithIDOnly = await prisma.tBEventReg_SEEE_2017.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends TBEventReg_SEEE_2017FindManyArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2017FindManyArgs>
    ): Prisma.PrismaPromise<Array<TBEventReg_SEEE_2017GetPayload<T>>>

    /**
     * Create a TBEventReg_SEEE_2017.
     * @param {TBEventReg_SEEE_2017CreateArgs} args - Arguments to create a TBEventReg_SEEE_2017.
     * @example
     * // Create one TBEventReg_SEEE_2017
     * const TBEventReg_SEEE_2017 = await prisma.tBEventReg_SEEE_2017.create({
     *   data: {
     *     // ... data to create a TBEventReg_SEEE_2017
     *   }
     * })
     * 
    **/
    create<T extends TBEventReg_SEEE_2017CreateArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2017CreateArgs>
    ): Prisma__TBEventReg_SEEE_2017Client<TBEventReg_SEEE_2017GetPayload<T>>

    /**
     * Create many TBEventReg_SEEE_2017s.
     *     @param {TBEventReg_SEEE_2017CreateManyArgs} args - Arguments to create many TBEventReg_SEEE_2017s.
     *     @example
     *     // Create many TBEventReg_SEEE_2017s
     *     const tBEventReg_SEEE_2017 = await prisma.tBEventReg_SEEE_2017.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TBEventReg_SEEE_2017CreateManyArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2017CreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TBEventReg_SEEE_2017.
     * @param {TBEventReg_SEEE_2017DeleteArgs} args - Arguments to delete one TBEventReg_SEEE_2017.
     * @example
     * // Delete one TBEventReg_SEEE_2017
     * const TBEventReg_SEEE_2017 = await prisma.tBEventReg_SEEE_2017.delete({
     *   where: {
     *     // ... filter to delete one TBEventReg_SEEE_2017
     *   }
     * })
     * 
    **/
    delete<T extends TBEventReg_SEEE_2017DeleteArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2017DeleteArgs>
    ): Prisma__TBEventReg_SEEE_2017Client<TBEventReg_SEEE_2017GetPayload<T>>

    /**
     * Update one TBEventReg_SEEE_2017.
     * @param {TBEventReg_SEEE_2017UpdateArgs} args - Arguments to update one TBEventReg_SEEE_2017.
     * @example
     * // Update one TBEventReg_SEEE_2017
     * const tBEventReg_SEEE_2017 = await prisma.tBEventReg_SEEE_2017.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TBEventReg_SEEE_2017UpdateArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2017UpdateArgs>
    ): Prisma__TBEventReg_SEEE_2017Client<TBEventReg_SEEE_2017GetPayload<T>>

    /**
     * Delete zero or more TBEventReg_SEEE_2017s.
     * @param {TBEventReg_SEEE_2017DeleteManyArgs} args - Arguments to filter TBEventReg_SEEE_2017s to delete.
     * @example
     * // Delete a few TBEventReg_SEEE_2017s
     * const { count } = await prisma.tBEventReg_SEEE_2017.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TBEventReg_SEEE_2017DeleteManyArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2017DeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TBEventReg_SEEE_2017s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2017UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TBEventReg_SEEE_2017s
     * const tBEventReg_SEEE_2017 = await prisma.tBEventReg_SEEE_2017.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TBEventReg_SEEE_2017UpdateManyArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2017UpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TBEventReg_SEEE_2017.
     * @param {TBEventReg_SEEE_2017UpsertArgs} args - Arguments to update or create a TBEventReg_SEEE_2017.
     * @example
     * // Update or create a TBEventReg_SEEE_2017
     * const tBEventReg_SEEE_2017 = await prisma.tBEventReg_SEEE_2017.upsert({
     *   create: {
     *     // ... data to create a TBEventReg_SEEE_2017
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TBEventReg_SEEE_2017 we want to update
     *   }
     * })
    **/
    upsert<T extends TBEventReg_SEEE_2017UpsertArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2017UpsertArgs>
    ): Prisma__TBEventReg_SEEE_2017Client<TBEventReg_SEEE_2017GetPayload<T>>

    /**
     * Count the number of TBEventReg_SEEE_2017s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2017CountArgs} args - Arguments to filter TBEventReg_SEEE_2017s to count.
     * @example
     * // Count the number of TBEventReg_SEEE_2017s
     * const count = await prisma.tBEventReg_SEEE_2017.count({
     *   where: {
     *     // ... the filter for the TBEventReg_SEEE_2017s we want to count
     *   }
     * })
    **/
    count<T extends TBEventReg_SEEE_2017CountArgs>(
      args?: Subset<T, TBEventReg_SEEE_2017CountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TBEventReg_SEEE_2017CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TBEventReg_SEEE_2017.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2017AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TBEventReg_SEEE_2017AggregateArgs>(args: Subset<T, TBEventReg_SEEE_2017AggregateArgs>): Prisma.PrismaPromise<GetTBEventReg_SEEE_2017AggregateType<T>>

    /**
     * Group by TBEventReg_SEEE_2017.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2017GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TBEventReg_SEEE_2017GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TBEventReg_SEEE_2017GroupByArgs['orderBy'] }
        : { orderBy?: TBEventReg_SEEE_2017GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TBEventReg_SEEE_2017GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTBEventReg_SEEE_2017GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TBEventReg_SEEE_2017.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TBEventReg_SEEE_2017Client<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TBEventReg_SEEE_2017 base type for findUnique actions
   */
  export type TBEventReg_SEEE_2017FindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017
     */
    select?: TBEventReg_SEEE_2017Select | null
    /**
     * Filter, which TBEventReg_SEEE_2017 to fetch.
     */
    where: TBEventReg_SEEE_2017WhereUniqueInput
  }

  /**
   * TBEventReg_SEEE_2017 findUnique
   */
  export interface TBEventReg_SEEE_2017FindUniqueArgs extends TBEventReg_SEEE_2017FindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_SEEE_2017 findUniqueOrThrow
   */
  export type TBEventReg_SEEE_2017FindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017
     */
    select?: TBEventReg_SEEE_2017Select | null
    /**
     * Filter, which TBEventReg_SEEE_2017 to fetch.
     */
    where: TBEventReg_SEEE_2017WhereUniqueInput
  }


  /**
   * TBEventReg_SEEE_2017 base type for findFirst actions
   */
  export type TBEventReg_SEEE_2017FindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017
     */
    select?: TBEventReg_SEEE_2017Select | null
    /**
     * Filter, which TBEventReg_SEEE_2017 to fetch.
     */
    where?: TBEventReg_SEEE_2017WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2017s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2017OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_SEEE_2017s.
     */
    cursor?: TBEventReg_SEEE_2017WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2017s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2017s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_SEEE_2017s.
     */
    distinct?: Enumerable<TBEventReg_SEEE_2017ScalarFieldEnum>
  }

  /**
   * TBEventReg_SEEE_2017 findFirst
   */
  export interface TBEventReg_SEEE_2017FindFirstArgs extends TBEventReg_SEEE_2017FindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_SEEE_2017 findFirstOrThrow
   */
  export type TBEventReg_SEEE_2017FindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017
     */
    select?: TBEventReg_SEEE_2017Select | null
    /**
     * Filter, which TBEventReg_SEEE_2017 to fetch.
     */
    where?: TBEventReg_SEEE_2017WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2017s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2017OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_SEEE_2017s.
     */
    cursor?: TBEventReg_SEEE_2017WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2017s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2017s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_SEEE_2017s.
     */
    distinct?: Enumerable<TBEventReg_SEEE_2017ScalarFieldEnum>
  }


  /**
   * TBEventReg_SEEE_2017 findMany
   */
  export type TBEventReg_SEEE_2017FindManyArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017
     */
    select?: TBEventReg_SEEE_2017Select | null
    /**
     * Filter, which TBEventReg_SEEE_2017s to fetch.
     */
    where?: TBEventReg_SEEE_2017WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2017s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2017OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TBEventReg_SEEE_2017s.
     */
    cursor?: TBEventReg_SEEE_2017WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2017s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2017s.
     */
    skip?: number
    distinct?: Enumerable<TBEventReg_SEEE_2017ScalarFieldEnum>
  }


  /**
   * TBEventReg_SEEE_2017 create
   */
  export type TBEventReg_SEEE_2017CreateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017
     */
    select?: TBEventReg_SEEE_2017Select | null
    /**
     * The data needed to create a TBEventReg_SEEE_2017.
     */
    data: XOR<TBEventReg_SEEE_2017CreateInput, TBEventReg_SEEE_2017UncheckedCreateInput>
  }


  /**
   * TBEventReg_SEEE_2017 createMany
   */
  export type TBEventReg_SEEE_2017CreateManyArgs = {
    /**
     * The data used to create many TBEventReg_SEEE_2017s.
     */
    data: Enumerable<TBEventReg_SEEE_2017CreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TBEventReg_SEEE_2017 update
   */
  export type TBEventReg_SEEE_2017UpdateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017
     */
    select?: TBEventReg_SEEE_2017Select | null
    /**
     * The data needed to update a TBEventReg_SEEE_2017.
     */
    data: XOR<TBEventReg_SEEE_2017UpdateInput, TBEventReg_SEEE_2017UncheckedUpdateInput>
    /**
     * Choose, which TBEventReg_SEEE_2017 to update.
     */
    where: TBEventReg_SEEE_2017WhereUniqueInput
  }


  /**
   * TBEventReg_SEEE_2017 updateMany
   */
  export type TBEventReg_SEEE_2017UpdateManyArgs = {
    /**
     * The data used to update TBEventReg_SEEE_2017s.
     */
    data: XOR<TBEventReg_SEEE_2017UpdateManyMutationInput, TBEventReg_SEEE_2017UncheckedUpdateManyInput>
    /**
     * Filter which TBEventReg_SEEE_2017s to update
     */
    where?: TBEventReg_SEEE_2017WhereInput
  }


  /**
   * TBEventReg_SEEE_2017 upsert
   */
  export type TBEventReg_SEEE_2017UpsertArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017
     */
    select?: TBEventReg_SEEE_2017Select | null
    /**
     * The filter to search for the TBEventReg_SEEE_2017 to update in case it exists.
     */
    where: TBEventReg_SEEE_2017WhereUniqueInput
    /**
     * In case the TBEventReg_SEEE_2017 found by the `where` argument doesn't exist, create a new TBEventReg_SEEE_2017 with this data.
     */
    create: XOR<TBEventReg_SEEE_2017CreateInput, TBEventReg_SEEE_2017UncheckedCreateInput>
    /**
     * In case the TBEventReg_SEEE_2017 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TBEventReg_SEEE_2017UpdateInput, TBEventReg_SEEE_2017UncheckedUpdateInput>
  }


  /**
   * TBEventReg_SEEE_2017 delete
   */
  export type TBEventReg_SEEE_2017DeleteArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017
     */
    select?: TBEventReg_SEEE_2017Select | null
    /**
     * Filter which TBEventReg_SEEE_2017 to delete.
     */
    where: TBEventReg_SEEE_2017WhereUniqueInput
  }


  /**
   * TBEventReg_SEEE_2017 deleteMany
   */
  export type TBEventReg_SEEE_2017DeleteManyArgs = {
    /**
     * Filter which TBEventReg_SEEE_2017s to delete
     */
    where?: TBEventReg_SEEE_2017WhereInput
  }


  /**
   * TBEventReg_SEEE_2017 without action
   */
  export type TBEventReg_SEEE_2017Args = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017
     */
    select?: TBEventReg_SEEE_2017Select | null
  }



  /**
   * Model TBEventReg_SEEE_2017_VenderInfo
   */


  export type AggregateTBEventReg_SEEE_2017_VenderInfo = {
    _count: TBEventReg_SEEE_2017_VenderInfoCountAggregateOutputType | null
    _avg: TBEventReg_SEEE_2017_VenderInfoAvgAggregateOutputType | null
    _sum: TBEventReg_SEEE_2017_VenderInfoSumAggregateOutputType | null
    _min: TBEventReg_SEEE_2017_VenderInfoMinAggregateOutputType | null
    _max: TBEventReg_SEEE_2017_VenderInfoMaxAggregateOutputType | null
  }

  export type TBEventReg_SEEE_2017_VenderInfoAvgAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_SEEE_2017_VenderInfoSumAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_SEEE_2017_VenderInfoMinAggregateOutputType = {
    ID: number | null
    VenderCompTitle: string | null
    VenderResource: string | null
    VenderEmail: string | null
    VenderDescrip: string | null
    VenderBooth: string | null
    VenderTel: string | null
    AMorPM: string | null
    AM1: string | null
    AM2: string | null
    AM3: string | null
    AM4: string | null
    AM5: string | null
    AM6: string | null
    PM1: string | null
    PM2: string | null
    PM3: string | null
    PM4: string | null
    PM5: string | null
    PM6: string | null
  }

  export type TBEventReg_SEEE_2017_VenderInfoMaxAggregateOutputType = {
    ID: number | null
    VenderCompTitle: string | null
    VenderResource: string | null
    VenderEmail: string | null
    VenderDescrip: string | null
    VenderBooth: string | null
    VenderTel: string | null
    AMorPM: string | null
    AM1: string | null
    AM2: string | null
    AM3: string | null
    AM4: string | null
    AM5: string | null
    AM6: string | null
    PM1: string | null
    PM2: string | null
    PM3: string | null
    PM4: string | null
    PM5: string | null
    PM6: string | null
  }

  export type TBEventReg_SEEE_2017_VenderInfoCountAggregateOutputType = {
    ID: number
    VenderCompTitle: number
    VenderResource: number
    VenderEmail: number
    VenderDescrip: number
    VenderBooth: number
    VenderTel: number
    AMorPM: number
    AM1: number
    AM2: number
    AM3: number
    AM4: number
    AM5: number
    AM6: number
    PM1: number
    PM2: number
    PM3: number
    PM4: number
    PM5: number
    PM6: number
    _all: number
  }


  export type TBEventReg_SEEE_2017_VenderInfoAvgAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_SEEE_2017_VenderInfoSumAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_SEEE_2017_VenderInfoMinAggregateInputType = {
    ID?: true
    VenderCompTitle?: true
    VenderResource?: true
    VenderEmail?: true
    VenderDescrip?: true
    VenderBooth?: true
    VenderTel?: true
    AMorPM?: true
    AM1?: true
    AM2?: true
    AM3?: true
    AM4?: true
    AM5?: true
    AM6?: true
    PM1?: true
    PM2?: true
    PM3?: true
    PM4?: true
    PM5?: true
    PM6?: true
  }

  export type TBEventReg_SEEE_2017_VenderInfoMaxAggregateInputType = {
    ID?: true
    VenderCompTitle?: true
    VenderResource?: true
    VenderEmail?: true
    VenderDescrip?: true
    VenderBooth?: true
    VenderTel?: true
    AMorPM?: true
    AM1?: true
    AM2?: true
    AM3?: true
    AM4?: true
    AM5?: true
    AM6?: true
    PM1?: true
    PM2?: true
    PM3?: true
    PM4?: true
    PM5?: true
    PM6?: true
  }

  export type TBEventReg_SEEE_2017_VenderInfoCountAggregateInputType = {
    ID?: true
    VenderCompTitle?: true
    VenderResource?: true
    VenderEmail?: true
    VenderDescrip?: true
    VenderBooth?: true
    VenderTel?: true
    AMorPM?: true
    AM1?: true
    AM2?: true
    AM3?: true
    AM4?: true
    AM5?: true
    AM6?: true
    PM1?: true
    PM2?: true
    PM3?: true
    PM4?: true
    PM5?: true
    PM6?: true
    _all?: true
  }

  export type TBEventReg_SEEE_2017_VenderInfoAggregateArgs = {
    /**
     * Filter which TBEventReg_SEEE_2017_VenderInfo to aggregate.
     */
    where?: TBEventReg_SEEE_2017_VenderInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2017_VenderInfos to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2017_VenderInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TBEventReg_SEEE_2017_VenderInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2017_VenderInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2017_VenderInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TBEventReg_SEEE_2017_VenderInfos
    **/
    _count?: true | TBEventReg_SEEE_2017_VenderInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TBEventReg_SEEE_2017_VenderInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TBEventReg_SEEE_2017_VenderInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TBEventReg_SEEE_2017_VenderInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TBEventReg_SEEE_2017_VenderInfoMaxAggregateInputType
  }

  export type GetTBEventReg_SEEE_2017_VenderInfoAggregateType<T extends TBEventReg_SEEE_2017_VenderInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateTBEventReg_SEEE_2017_VenderInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTBEventReg_SEEE_2017_VenderInfo[P]>
      : GetScalarType<T[P], AggregateTBEventReg_SEEE_2017_VenderInfo[P]>
  }




  export type TBEventReg_SEEE_2017_VenderInfoGroupByArgs = {
    where?: TBEventReg_SEEE_2017_VenderInfoWhereInput
    orderBy?: Enumerable<TBEventReg_SEEE_2017_VenderInfoOrderByWithAggregationInput>
    by: TBEventReg_SEEE_2017_VenderInfoScalarFieldEnum[]
    having?: TBEventReg_SEEE_2017_VenderInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TBEventReg_SEEE_2017_VenderInfoCountAggregateInputType | true
    _avg?: TBEventReg_SEEE_2017_VenderInfoAvgAggregateInputType
    _sum?: TBEventReg_SEEE_2017_VenderInfoSumAggregateInputType
    _min?: TBEventReg_SEEE_2017_VenderInfoMinAggregateInputType
    _max?: TBEventReg_SEEE_2017_VenderInfoMaxAggregateInputType
  }


  export type TBEventReg_SEEE_2017_VenderInfoGroupByOutputType = {
    ID: number
    VenderCompTitle: string
    VenderResource: string
    VenderEmail: string
    VenderDescrip: string
    VenderBooth: string
    VenderTel: string
    AMorPM: string
    AM1: string
    AM2: string
    AM3: string
    AM4: string
    AM5: string
    AM6: string
    PM1: string
    PM2: string
    PM3: string
    PM4: string
    PM5: string
    PM6: string
    _count: TBEventReg_SEEE_2017_VenderInfoCountAggregateOutputType | null
    _avg: TBEventReg_SEEE_2017_VenderInfoAvgAggregateOutputType | null
    _sum: TBEventReg_SEEE_2017_VenderInfoSumAggregateOutputType | null
    _min: TBEventReg_SEEE_2017_VenderInfoMinAggregateOutputType | null
    _max: TBEventReg_SEEE_2017_VenderInfoMaxAggregateOutputType | null
  }

  type GetTBEventReg_SEEE_2017_VenderInfoGroupByPayload<T extends TBEventReg_SEEE_2017_VenderInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TBEventReg_SEEE_2017_VenderInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TBEventReg_SEEE_2017_VenderInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TBEventReg_SEEE_2017_VenderInfoGroupByOutputType[P]>
            : GetScalarType<T[P], TBEventReg_SEEE_2017_VenderInfoGroupByOutputType[P]>
        }
      >
    >


  export type TBEventReg_SEEE_2017_VenderInfoSelect = {
    ID?: boolean
    VenderCompTitle?: boolean
    VenderResource?: boolean
    VenderEmail?: boolean
    VenderDescrip?: boolean
    VenderBooth?: boolean
    VenderTel?: boolean
    AMorPM?: boolean
    AM1?: boolean
    AM2?: boolean
    AM3?: boolean
    AM4?: boolean
    AM5?: boolean
    AM6?: boolean
    PM1?: boolean
    PM2?: boolean
    PM3?: boolean
    PM4?: boolean
    PM5?: boolean
    PM6?: boolean
  }


  export type TBEventReg_SEEE_2017_VenderInfoGetPayload<S extends boolean | null | undefined | TBEventReg_SEEE_2017_VenderInfoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TBEventReg_SEEE_2017_VenderInfo :
    S extends undefined ? never :
    S extends { include: any } & (TBEventReg_SEEE_2017_VenderInfoArgs | TBEventReg_SEEE_2017_VenderInfoFindManyArgs)
    ? TBEventReg_SEEE_2017_VenderInfo 
    : S extends { select: any } & (TBEventReg_SEEE_2017_VenderInfoArgs | TBEventReg_SEEE_2017_VenderInfoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TBEventReg_SEEE_2017_VenderInfo ? TBEventReg_SEEE_2017_VenderInfo[P] : never
  } 
      : TBEventReg_SEEE_2017_VenderInfo


  type TBEventReg_SEEE_2017_VenderInfoCountArgs = 
    Omit<TBEventReg_SEEE_2017_VenderInfoFindManyArgs, 'select' | 'include'> & {
      select?: TBEventReg_SEEE_2017_VenderInfoCountAggregateInputType | true
    }

  export interface TBEventReg_SEEE_2017_VenderInfoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TBEventReg_SEEE_2017_VenderInfo that matches the filter.
     * @param {TBEventReg_SEEE_2017_VenderInfoFindUniqueArgs} args - Arguments to find a TBEventReg_SEEE_2017_VenderInfo
     * @example
     * // Get one TBEventReg_SEEE_2017_VenderInfo
     * const tBEventReg_SEEE_2017_VenderInfo = await prisma.tBEventReg_SEEE_2017_VenderInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TBEventReg_SEEE_2017_VenderInfoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TBEventReg_SEEE_2017_VenderInfoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TBEventReg_SEEE_2017_VenderInfo'> extends True ? Prisma__TBEventReg_SEEE_2017_VenderInfoClient<TBEventReg_SEEE_2017_VenderInfoGetPayload<T>> : Prisma__TBEventReg_SEEE_2017_VenderInfoClient<TBEventReg_SEEE_2017_VenderInfoGetPayload<T> | null, null>

    /**
     * Find one TBEventReg_SEEE_2017_VenderInfo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TBEventReg_SEEE_2017_VenderInfoFindUniqueOrThrowArgs} args - Arguments to find a TBEventReg_SEEE_2017_VenderInfo
     * @example
     * // Get one TBEventReg_SEEE_2017_VenderInfo
     * const tBEventReg_SEEE_2017_VenderInfo = await prisma.tBEventReg_SEEE_2017_VenderInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TBEventReg_SEEE_2017_VenderInfoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2017_VenderInfoFindUniqueOrThrowArgs>
    ): Prisma__TBEventReg_SEEE_2017_VenderInfoClient<TBEventReg_SEEE_2017_VenderInfoGetPayload<T>>

    /**
     * Find the first TBEventReg_SEEE_2017_VenderInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2017_VenderInfoFindFirstArgs} args - Arguments to find a TBEventReg_SEEE_2017_VenderInfo
     * @example
     * // Get one TBEventReg_SEEE_2017_VenderInfo
     * const tBEventReg_SEEE_2017_VenderInfo = await prisma.tBEventReg_SEEE_2017_VenderInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TBEventReg_SEEE_2017_VenderInfoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TBEventReg_SEEE_2017_VenderInfoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TBEventReg_SEEE_2017_VenderInfo'> extends True ? Prisma__TBEventReg_SEEE_2017_VenderInfoClient<TBEventReg_SEEE_2017_VenderInfoGetPayload<T>> : Prisma__TBEventReg_SEEE_2017_VenderInfoClient<TBEventReg_SEEE_2017_VenderInfoGetPayload<T> | null, null>

    /**
     * Find the first TBEventReg_SEEE_2017_VenderInfo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2017_VenderInfoFindFirstOrThrowArgs} args - Arguments to find a TBEventReg_SEEE_2017_VenderInfo
     * @example
     * // Get one TBEventReg_SEEE_2017_VenderInfo
     * const tBEventReg_SEEE_2017_VenderInfo = await prisma.tBEventReg_SEEE_2017_VenderInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TBEventReg_SEEE_2017_VenderInfoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2017_VenderInfoFindFirstOrThrowArgs>
    ): Prisma__TBEventReg_SEEE_2017_VenderInfoClient<TBEventReg_SEEE_2017_VenderInfoGetPayload<T>>

    /**
     * Find zero or more TBEventReg_SEEE_2017_VenderInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2017_VenderInfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TBEventReg_SEEE_2017_VenderInfos
     * const tBEventReg_SEEE_2017_VenderInfos = await prisma.tBEventReg_SEEE_2017_VenderInfo.findMany()
     * 
     * // Get first 10 TBEventReg_SEEE_2017_VenderInfos
     * const tBEventReg_SEEE_2017_VenderInfos = await prisma.tBEventReg_SEEE_2017_VenderInfo.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tBEventReg_SEEE_2017_VenderInfoWithIDOnly = await prisma.tBEventReg_SEEE_2017_VenderInfo.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends TBEventReg_SEEE_2017_VenderInfoFindManyArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2017_VenderInfoFindManyArgs>
    ): Prisma.PrismaPromise<Array<TBEventReg_SEEE_2017_VenderInfoGetPayload<T>>>

    /**
     * Create a TBEventReg_SEEE_2017_VenderInfo.
     * @param {TBEventReg_SEEE_2017_VenderInfoCreateArgs} args - Arguments to create a TBEventReg_SEEE_2017_VenderInfo.
     * @example
     * // Create one TBEventReg_SEEE_2017_VenderInfo
     * const TBEventReg_SEEE_2017_VenderInfo = await prisma.tBEventReg_SEEE_2017_VenderInfo.create({
     *   data: {
     *     // ... data to create a TBEventReg_SEEE_2017_VenderInfo
     *   }
     * })
     * 
    **/
    create<T extends TBEventReg_SEEE_2017_VenderInfoCreateArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2017_VenderInfoCreateArgs>
    ): Prisma__TBEventReg_SEEE_2017_VenderInfoClient<TBEventReg_SEEE_2017_VenderInfoGetPayload<T>>

    /**
     * Create many TBEventReg_SEEE_2017_VenderInfos.
     *     @param {TBEventReg_SEEE_2017_VenderInfoCreateManyArgs} args - Arguments to create many TBEventReg_SEEE_2017_VenderInfos.
     *     @example
     *     // Create many TBEventReg_SEEE_2017_VenderInfos
     *     const tBEventReg_SEEE_2017_VenderInfo = await prisma.tBEventReg_SEEE_2017_VenderInfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TBEventReg_SEEE_2017_VenderInfoCreateManyArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2017_VenderInfoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TBEventReg_SEEE_2017_VenderInfo.
     * @param {TBEventReg_SEEE_2017_VenderInfoDeleteArgs} args - Arguments to delete one TBEventReg_SEEE_2017_VenderInfo.
     * @example
     * // Delete one TBEventReg_SEEE_2017_VenderInfo
     * const TBEventReg_SEEE_2017_VenderInfo = await prisma.tBEventReg_SEEE_2017_VenderInfo.delete({
     *   where: {
     *     // ... filter to delete one TBEventReg_SEEE_2017_VenderInfo
     *   }
     * })
     * 
    **/
    delete<T extends TBEventReg_SEEE_2017_VenderInfoDeleteArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2017_VenderInfoDeleteArgs>
    ): Prisma__TBEventReg_SEEE_2017_VenderInfoClient<TBEventReg_SEEE_2017_VenderInfoGetPayload<T>>

    /**
     * Update one TBEventReg_SEEE_2017_VenderInfo.
     * @param {TBEventReg_SEEE_2017_VenderInfoUpdateArgs} args - Arguments to update one TBEventReg_SEEE_2017_VenderInfo.
     * @example
     * // Update one TBEventReg_SEEE_2017_VenderInfo
     * const tBEventReg_SEEE_2017_VenderInfo = await prisma.tBEventReg_SEEE_2017_VenderInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TBEventReg_SEEE_2017_VenderInfoUpdateArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2017_VenderInfoUpdateArgs>
    ): Prisma__TBEventReg_SEEE_2017_VenderInfoClient<TBEventReg_SEEE_2017_VenderInfoGetPayload<T>>

    /**
     * Delete zero or more TBEventReg_SEEE_2017_VenderInfos.
     * @param {TBEventReg_SEEE_2017_VenderInfoDeleteManyArgs} args - Arguments to filter TBEventReg_SEEE_2017_VenderInfos to delete.
     * @example
     * // Delete a few TBEventReg_SEEE_2017_VenderInfos
     * const { count } = await prisma.tBEventReg_SEEE_2017_VenderInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TBEventReg_SEEE_2017_VenderInfoDeleteManyArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2017_VenderInfoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TBEventReg_SEEE_2017_VenderInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2017_VenderInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TBEventReg_SEEE_2017_VenderInfos
     * const tBEventReg_SEEE_2017_VenderInfo = await prisma.tBEventReg_SEEE_2017_VenderInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TBEventReg_SEEE_2017_VenderInfoUpdateManyArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2017_VenderInfoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TBEventReg_SEEE_2017_VenderInfo.
     * @param {TBEventReg_SEEE_2017_VenderInfoUpsertArgs} args - Arguments to update or create a TBEventReg_SEEE_2017_VenderInfo.
     * @example
     * // Update or create a TBEventReg_SEEE_2017_VenderInfo
     * const tBEventReg_SEEE_2017_VenderInfo = await prisma.tBEventReg_SEEE_2017_VenderInfo.upsert({
     *   create: {
     *     // ... data to create a TBEventReg_SEEE_2017_VenderInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TBEventReg_SEEE_2017_VenderInfo we want to update
     *   }
     * })
    **/
    upsert<T extends TBEventReg_SEEE_2017_VenderInfoUpsertArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2017_VenderInfoUpsertArgs>
    ): Prisma__TBEventReg_SEEE_2017_VenderInfoClient<TBEventReg_SEEE_2017_VenderInfoGetPayload<T>>

    /**
     * Count the number of TBEventReg_SEEE_2017_VenderInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2017_VenderInfoCountArgs} args - Arguments to filter TBEventReg_SEEE_2017_VenderInfos to count.
     * @example
     * // Count the number of TBEventReg_SEEE_2017_VenderInfos
     * const count = await prisma.tBEventReg_SEEE_2017_VenderInfo.count({
     *   where: {
     *     // ... the filter for the TBEventReg_SEEE_2017_VenderInfos we want to count
     *   }
     * })
    **/
    count<T extends TBEventReg_SEEE_2017_VenderInfoCountArgs>(
      args?: Subset<T, TBEventReg_SEEE_2017_VenderInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TBEventReg_SEEE_2017_VenderInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TBEventReg_SEEE_2017_VenderInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2017_VenderInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TBEventReg_SEEE_2017_VenderInfoAggregateArgs>(args: Subset<T, TBEventReg_SEEE_2017_VenderInfoAggregateArgs>): Prisma.PrismaPromise<GetTBEventReg_SEEE_2017_VenderInfoAggregateType<T>>

    /**
     * Group by TBEventReg_SEEE_2017_VenderInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2017_VenderInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TBEventReg_SEEE_2017_VenderInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TBEventReg_SEEE_2017_VenderInfoGroupByArgs['orderBy'] }
        : { orderBy?: TBEventReg_SEEE_2017_VenderInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TBEventReg_SEEE_2017_VenderInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTBEventReg_SEEE_2017_VenderInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TBEventReg_SEEE_2017_VenderInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TBEventReg_SEEE_2017_VenderInfoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TBEventReg_SEEE_2017_VenderInfo base type for findUnique actions
   */
  export type TBEventReg_SEEE_2017_VenderInfoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017_VenderInfo
     */
    select?: TBEventReg_SEEE_2017_VenderInfoSelect | null
    /**
     * Filter, which TBEventReg_SEEE_2017_VenderInfo to fetch.
     */
    where: TBEventReg_SEEE_2017_VenderInfoWhereUniqueInput
  }

  /**
   * TBEventReg_SEEE_2017_VenderInfo findUnique
   */
  export interface TBEventReg_SEEE_2017_VenderInfoFindUniqueArgs extends TBEventReg_SEEE_2017_VenderInfoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_SEEE_2017_VenderInfo findUniqueOrThrow
   */
  export type TBEventReg_SEEE_2017_VenderInfoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017_VenderInfo
     */
    select?: TBEventReg_SEEE_2017_VenderInfoSelect | null
    /**
     * Filter, which TBEventReg_SEEE_2017_VenderInfo to fetch.
     */
    where: TBEventReg_SEEE_2017_VenderInfoWhereUniqueInput
  }


  /**
   * TBEventReg_SEEE_2017_VenderInfo base type for findFirst actions
   */
  export type TBEventReg_SEEE_2017_VenderInfoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017_VenderInfo
     */
    select?: TBEventReg_SEEE_2017_VenderInfoSelect | null
    /**
     * Filter, which TBEventReg_SEEE_2017_VenderInfo to fetch.
     */
    where?: TBEventReg_SEEE_2017_VenderInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2017_VenderInfos to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2017_VenderInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_SEEE_2017_VenderInfos.
     */
    cursor?: TBEventReg_SEEE_2017_VenderInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2017_VenderInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2017_VenderInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_SEEE_2017_VenderInfos.
     */
    distinct?: Enumerable<TBEventReg_SEEE_2017_VenderInfoScalarFieldEnum>
  }

  /**
   * TBEventReg_SEEE_2017_VenderInfo findFirst
   */
  export interface TBEventReg_SEEE_2017_VenderInfoFindFirstArgs extends TBEventReg_SEEE_2017_VenderInfoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_SEEE_2017_VenderInfo findFirstOrThrow
   */
  export type TBEventReg_SEEE_2017_VenderInfoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017_VenderInfo
     */
    select?: TBEventReg_SEEE_2017_VenderInfoSelect | null
    /**
     * Filter, which TBEventReg_SEEE_2017_VenderInfo to fetch.
     */
    where?: TBEventReg_SEEE_2017_VenderInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2017_VenderInfos to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2017_VenderInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_SEEE_2017_VenderInfos.
     */
    cursor?: TBEventReg_SEEE_2017_VenderInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2017_VenderInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2017_VenderInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_SEEE_2017_VenderInfos.
     */
    distinct?: Enumerable<TBEventReg_SEEE_2017_VenderInfoScalarFieldEnum>
  }


  /**
   * TBEventReg_SEEE_2017_VenderInfo findMany
   */
  export type TBEventReg_SEEE_2017_VenderInfoFindManyArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017_VenderInfo
     */
    select?: TBEventReg_SEEE_2017_VenderInfoSelect | null
    /**
     * Filter, which TBEventReg_SEEE_2017_VenderInfos to fetch.
     */
    where?: TBEventReg_SEEE_2017_VenderInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2017_VenderInfos to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2017_VenderInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TBEventReg_SEEE_2017_VenderInfos.
     */
    cursor?: TBEventReg_SEEE_2017_VenderInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2017_VenderInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2017_VenderInfos.
     */
    skip?: number
    distinct?: Enumerable<TBEventReg_SEEE_2017_VenderInfoScalarFieldEnum>
  }


  /**
   * TBEventReg_SEEE_2017_VenderInfo create
   */
  export type TBEventReg_SEEE_2017_VenderInfoCreateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017_VenderInfo
     */
    select?: TBEventReg_SEEE_2017_VenderInfoSelect | null
    /**
     * The data needed to create a TBEventReg_SEEE_2017_VenderInfo.
     */
    data: XOR<TBEventReg_SEEE_2017_VenderInfoCreateInput, TBEventReg_SEEE_2017_VenderInfoUncheckedCreateInput>
  }


  /**
   * TBEventReg_SEEE_2017_VenderInfo createMany
   */
  export type TBEventReg_SEEE_2017_VenderInfoCreateManyArgs = {
    /**
     * The data used to create many TBEventReg_SEEE_2017_VenderInfos.
     */
    data: Enumerable<TBEventReg_SEEE_2017_VenderInfoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TBEventReg_SEEE_2017_VenderInfo update
   */
  export type TBEventReg_SEEE_2017_VenderInfoUpdateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017_VenderInfo
     */
    select?: TBEventReg_SEEE_2017_VenderInfoSelect | null
    /**
     * The data needed to update a TBEventReg_SEEE_2017_VenderInfo.
     */
    data: XOR<TBEventReg_SEEE_2017_VenderInfoUpdateInput, TBEventReg_SEEE_2017_VenderInfoUncheckedUpdateInput>
    /**
     * Choose, which TBEventReg_SEEE_2017_VenderInfo to update.
     */
    where: TBEventReg_SEEE_2017_VenderInfoWhereUniqueInput
  }


  /**
   * TBEventReg_SEEE_2017_VenderInfo updateMany
   */
  export type TBEventReg_SEEE_2017_VenderInfoUpdateManyArgs = {
    /**
     * The data used to update TBEventReg_SEEE_2017_VenderInfos.
     */
    data: XOR<TBEventReg_SEEE_2017_VenderInfoUpdateManyMutationInput, TBEventReg_SEEE_2017_VenderInfoUncheckedUpdateManyInput>
    /**
     * Filter which TBEventReg_SEEE_2017_VenderInfos to update
     */
    where?: TBEventReg_SEEE_2017_VenderInfoWhereInput
  }


  /**
   * TBEventReg_SEEE_2017_VenderInfo upsert
   */
  export type TBEventReg_SEEE_2017_VenderInfoUpsertArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017_VenderInfo
     */
    select?: TBEventReg_SEEE_2017_VenderInfoSelect | null
    /**
     * The filter to search for the TBEventReg_SEEE_2017_VenderInfo to update in case it exists.
     */
    where: TBEventReg_SEEE_2017_VenderInfoWhereUniqueInput
    /**
     * In case the TBEventReg_SEEE_2017_VenderInfo found by the `where` argument doesn't exist, create a new TBEventReg_SEEE_2017_VenderInfo with this data.
     */
    create: XOR<TBEventReg_SEEE_2017_VenderInfoCreateInput, TBEventReg_SEEE_2017_VenderInfoUncheckedCreateInput>
    /**
     * In case the TBEventReg_SEEE_2017_VenderInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TBEventReg_SEEE_2017_VenderInfoUpdateInput, TBEventReg_SEEE_2017_VenderInfoUncheckedUpdateInput>
  }


  /**
   * TBEventReg_SEEE_2017_VenderInfo delete
   */
  export type TBEventReg_SEEE_2017_VenderInfoDeleteArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017_VenderInfo
     */
    select?: TBEventReg_SEEE_2017_VenderInfoSelect | null
    /**
     * Filter which TBEventReg_SEEE_2017_VenderInfo to delete.
     */
    where: TBEventReg_SEEE_2017_VenderInfoWhereUniqueInput
  }


  /**
   * TBEventReg_SEEE_2017_VenderInfo deleteMany
   */
  export type TBEventReg_SEEE_2017_VenderInfoDeleteManyArgs = {
    /**
     * Filter which TBEventReg_SEEE_2017_VenderInfos to delete
     */
    where?: TBEventReg_SEEE_2017_VenderInfoWhereInput
  }


  /**
   * TBEventReg_SEEE_2017_VenderInfo without action
   */
  export type TBEventReg_SEEE_2017_VenderInfoArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2017_VenderInfo
     */
    select?: TBEventReg_SEEE_2017_VenderInfoSelect | null
  }



  /**
   * Model TBEventReg_SEEE_2018
   */


  export type AggregateTBEventReg_SEEE_2018 = {
    _count: TBEventReg_SEEE_2018CountAggregateOutputType | null
    _avg: TBEventReg_SEEE_2018AvgAggregateOutputType | null
    _sum: TBEventReg_SEEE_2018SumAggregateOutputType | null
    _min: TBEventReg_SEEE_2018MinAggregateOutputType | null
    _max: TBEventReg_SEEE_2018MaxAggregateOutputType | null
  }

  export type TBEventReg_SEEE_2018AvgAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_SEEE_2018SumAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_SEEE_2018MinAggregateOutputType = {
    ID: number | null
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegDate: Date | null
    RegIP: string | null
    RegLunch: string | null
  }

  export type TBEventReg_SEEE_2018MaxAggregateOutputType = {
    ID: number | null
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegDate: Date | null
    RegIP: string | null
    RegLunch: string | null
  }

  export type TBEventReg_SEEE_2018CountAggregateOutputType = {
    ID: number
    EventTitle: number
    RegName: number
    RegEmail: number
    RegTel: number
    RegAddress: number
    RegDate: number
    RegIP: number
    RegLunch: number
    _all: number
  }


  export type TBEventReg_SEEE_2018AvgAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_SEEE_2018SumAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_SEEE_2018MinAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegDate?: true
    RegIP?: true
    RegLunch?: true
  }

  export type TBEventReg_SEEE_2018MaxAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegDate?: true
    RegIP?: true
    RegLunch?: true
  }

  export type TBEventReg_SEEE_2018CountAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegDate?: true
    RegIP?: true
    RegLunch?: true
    _all?: true
  }

  export type TBEventReg_SEEE_2018AggregateArgs = {
    /**
     * Filter which TBEventReg_SEEE_2018 to aggregate.
     */
    where?: TBEventReg_SEEE_2018WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2018s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2018OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TBEventReg_SEEE_2018WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2018s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2018s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TBEventReg_SEEE_2018s
    **/
    _count?: true | TBEventReg_SEEE_2018CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TBEventReg_SEEE_2018AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TBEventReg_SEEE_2018SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TBEventReg_SEEE_2018MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TBEventReg_SEEE_2018MaxAggregateInputType
  }

  export type GetTBEventReg_SEEE_2018AggregateType<T extends TBEventReg_SEEE_2018AggregateArgs> = {
        [P in keyof T & keyof AggregateTBEventReg_SEEE_2018]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTBEventReg_SEEE_2018[P]>
      : GetScalarType<T[P], AggregateTBEventReg_SEEE_2018[P]>
  }




  export type TBEventReg_SEEE_2018GroupByArgs = {
    where?: TBEventReg_SEEE_2018WhereInput
    orderBy?: Enumerable<TBEventReg_SEEE_2018OrderByWithAggregationInput>
    by: TBEventReg_SEEE_2018ScalarFieldEnum[]
    having?: TBEventReg_SEEE_2018ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TBEventReg_SEEE_2018CountAggregateInputType | true
    _avg?: TBEventReg_SEEE_2018AvgAggregateInputType
    _sum?: TBEventReg_SEEE_2018SumAggregateInputType
    _min?: TBEventReg_SEEE_2018MinAggregateInputType
    _max?: TBEventReg_SEEE_2018MaxAggregateInputType
  }


  export type TBEventReg_SEEE_2018GroupByOutputType = {
    ID: number
    EventTitle: string
    RegName: string
    RegEmail: string
    RegTel: string
    RegAddress: string
    RegDate: Date
    RegIP: string
    RegLunch: string | null
    _count: TBEventReg_SEEE_2018CountAggregateOutputType | null
    _avg: TBEventReg_SEEE_2018AvgAggregateOutputType | null
    _sum: TBEventReg_SEEE_2018SumAggregateOutputType | null
    _min: TBEventReg_SEEE_2018MinAggregateOutputType | null
    _max: TBEventReg_SEEE_2018MaxAggregateOutputType | null
  }

  type GetTBEventReg_SEEE_2018GroupByPayload<T extends TBEventReg_SEEE_2018GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TBEventReg_SEEE_2018GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TBEventReg_SEEE_2018GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TBEventReg_SEEE_2018GroupByOutputType[P]>
            : GetScalarType<T[P], TBEventReg_SEEE_2018GroupByOutputType[P]>
        }
      >
    >


  export type TBEventReg_SEEE_2018Select = {
    ID?: boolean
    EventTitle?: boolean
    RegName?: boolean
    RegEmail?: boolean
    RegTel?: boolean
    RegAddress?: boolean
    RegDate?: boolean
    RegIP?: boolean
    RegLunch?: boolean
  }


  export type TBEventReg_SEEE_2018GetPayload<S extends boolean | null | undefined | TBEventReg_SEEE_2018Args> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TBEventReg_SEEE_2018 :
    S extends undefined ? never :
    S extends { include: any } & (TBEventReg_SEEE_2018Args | TBEventReg_SEEE_2018FindManyArgs)
    ? TBEventReg_SEEE_2018 
    : S extends { select: any } & (TBEventReg_SEEE_2018Args | TBEventReg_SEEE_2018FindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TBEventReg_SEEE_2018 ? TBEventReg_SEEE_2018[P] : never
  } 
      : TBEventReg_SEEE_2018


  type TBEventReg_SEEE_2018CountArgs = 
    Omit<TBEventReg_SEEE_2018FindManyArgs, 'select' | 'include'> & {
      select?: TBEventReg_SEEE_2018CountAggregateInputType | true
    }

  export interface TBEventReg_SEEE_2018Delegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TBEventReg_SEEE_2018 that matches the filter.
     * @param {TBEventReg_SEEE_2018FindUniqueArgs} args - Arguments to find a TBEventReg_SEEE_2018
     * @example
     * // Get one TBEventReg_SEEE_2018
     * const tBEventReg_SEEE_2018 = await prisma.tBEventReg_SEEE_2018.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TBEventReg_SEEE_2018FindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TBEventReg_SEEE_2018FindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TBEventReg_SEEE_2018'> extends True ? Prisma__TBEventReg_SEEE_2018Client<TBEventReg_SEEE_2018GetPayload<T>> : Prisma__TBEventReg_SEEE_2018Client<TBEventReg_SEEE_2018GetPayload<T> | null, null>

    /**
     * Find one TBEventReg_SEEE_2018 that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TBEventReg_SEEE_2018FindUniqueOrThrowArgs} args - Arguments to find a TBEventReg_SEEE_2018
     * @example
     * // Get one TBEventReg_SEEE_2018
     * const tBEventReg_SEEE_2018 = await prisma.tBEventReg_SEEE_2018.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TBEventReg_SEEE_2018FindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2018FindUniqueOrThrowArgs>
    ): Prisma__TBEventReg_SEEE_2018Client<TBEventReg_SEEE_2018GetPayload<T>>

    /**
     * Find the first TBEventReg_SEEE_2018 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2018FindFirstArgs} args - Arguments to find a TBEventReg_SEEE_2018
     * @example
     * // Get one TBEventReg_SEEE_2018
     * const tBEventReg_SEEE_2018 = await prisma.tBEventReg_SEEE_2018.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TBEventReg_SEEE_2018FindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TBEventReg_SEEE_2018FindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TBEventReg_SEEE_2018'> extends True ? Prisma__TBEventReg_SEEE_2018Client<TBEventReg_SEEE_2018GetPayload<T>> : Prisma__TBEventReg_SEEE_2018Client<TBEventReg_SEEE_2018GetPayload<T> | null, null>

    /**
     * Find the first TBEventReg_SEEE_2018 that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2018FindFirstOrThrowArgs} args - Arguments to find a TBEventReg_SEEE_2018
     * @example
     * // Get one TBEventReg_SEEE_2018
     * const tBEventReg_SEEE_2018 = await prisma.tBEventReg_SEEE_2018.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TBEventReg_SEEE_2018FindFirstOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2018FindFirstOrThrowArgs>
    ): Prisma__TBEventReg_SEEE_2018Client<TBEventReg_SEEE_2018GetPayload<T>>

    /**
     * Find zero or more TBEventReg_SEEE_2018s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2018FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TBEventReg_SEEE_2018s
     * const tBEventReg_SEEE_2018s = await prisma.tBEventReg_SEEE_2018.findMany()
     * 
     * // Get first 10 TBEventReg_SEEE_2018s
     * const tBEventReg_SEEE_2018s = await prisma.tBEventReg_SEEE_2018.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tBEventReg_SEEE_2018WithIDOnly = await prisma.tBEventReg_SEEE_2018.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends TBEventReg_SEEE_2018FindManyArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2018FindManyArgs>
    ): Prisma.PrismaPromise<Array<TBEventReg_SEEE_2018GetPayload<T>>>

    /**
     * Create a TBEventReg_SEEE_2018.
     * @param {TBEventReg_SEEE_2018CreateArgs} args - Arguments to create a TBEventReg_SEEE_2018.
     * @example
     * // Create one TBEventReg_SEEE_2018
     * const TBEventReg_SEEE_2018 = await prisma.tBEventReg_SEEE_2018.create({
     *   data: {
     *     // ... data to create a TBEventReg_SEEE_2018
     *   }
     * })
     * 
    **/
    create<T extends TBEventReg_SEEE_2018CreateArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2018CreateArgs>
    ): Prisma__TBEventReg_SEEE_2018Client<TBEventReg_SEEE_2018GetPayload<T>>

    /**
     * Create many TBEventReg_SEEE_2018s.
     *     @param {TBEventReg_SEEE_2018CreateManyArgs} args - Arguments to create many TBEventReg_SEEE_2018s.
     *     @example
     *     // Create many TBEventReg_SEEE_2018s
     *     const tBEventReg_SEEE_2018 = await prisma.tBEventReg_SEEE_2018.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TBEventReg_SEEE_2018CreateManyArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2018CreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TBEventReg_SEEE_2018.
     * @param {TBEventReg_SEEE_2018DeleteArgs} args - Arguments to delete one TBEventReg_SEEE_2018.
     * @example
     * // Delete one TBEventReg_SEEE_2018
     * const TBEventReg_SEEE_2018 = await prisma.tBEventReg_SEEE_2018.delete({
     *   where: {
     *     // ... filter to delete one TBEventReg_SEEE_2018
     *   }
     * })
     * 
    **/
    delete<T extends TBEventReg_SEEE_2018DeleteArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2018DeleteArgs>
    ): Prisma__TBEventReg_SEEE_2018Client<TBEventReg_SEEE_2018GetPayload<T>>

    /**
     * Update one TBEventReg_SEEE_2018.
     * @param {TBEventReg_SEEE_2018UpdateArgs} args - Arguments to update one TBEventReg_SEEE_2018.
     * @example
     * // Update one TBEventReg_SEEE_2018
     * const tBEventReg_SEEE_2018 = await prisma.tBEventReg_SEEE_2018.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TBEventReg_SEEE_2018UpdateArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2018UpdateArgs>
    ): Prisma__TBEventReg_SEEE_2018Client<TBEventReg_SEEE_2018GetPayload<T>>

    /**
     * Delete zero or more TBEventReg_SEEE_2018s.
     * @param {TBEventReg_SEEE_2018DeleteManyArgs} args - Arguments to filter TBEventReg_SEEE_2018s to delete.
     * @example
     * // Delete a few TBEventReg_SEEE_2018s
     * const { count } = await prisma.tBEventReg_SEEE_2018.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TBEventReg_SEEE_2018DeleteManyArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2018DeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TBEventReg_SEEE_2018s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2018UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TBEventReg_SEEE_2018s
     * const tBEventReg_SEEE_2018 = await prisma.tBEventReg_SEEE_2018.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TBEventReg_SEEE_2018UpdateManyArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2018UpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TBEventReg_SEEE_2018.
     * @param {TBEventReg_SEEE_2018UpsertArgs} args - Arguments to update or create a TBEventReg_SEEE_2018.
     * @example
     * // Update or create a TBEventReg_SEEE_2018
     * const tBEventReg_SEEE_2018 = await prisma.tBEventReg_SEEE_2018.upsert({
     *   create: {
     *     // ... data to create a TBEventReg_SEEE_2018
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TBEventReg_SEEE_2018 we want to update
     *   }
     * })
    **/
    upsert<T extends TBEventReg_SEEE_2018UpsertArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2018UpsertArgs>
    ): Prisma__TBEventReg_SEEE_2018Client<TBEventReg_SEEE_2018GetPayload<T>>

    /**
     * Count the number of TBEventReg_SEEE_2018s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2018CountArgs} args - Arguments to filter TBEventReg_SEEE_2018s to count.
     * @example
     * // Count the number of TBEventReg_SEEE_2018s
     * const count = await prisma.tBEventReg_SEEE_2018.count({
     *   where: {
     *     // ... the filter for the TBEventReg_SEEE_2018s we want to count
     *   }
     * })
    **/
    count<T extends TBEventReg_SEEE_2018CountArgs>(
      args?: Subset<T, TBEventReg_SEEE_2018CountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TBEventReg_SEEE_2018CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TBEventReg_SEEE_2018.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2018AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TBEventReg_SEEE_2018AggregateArgs>(args: Subset<T, TBEventReg_SEEE_2018AggregateArgs>): Prisma.PrismaPromise<GetTBEventReg_SEEE_2018AggregateType<T>>

    /**
     * Group by TBEventReg_SEEE_2018.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2018GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TBEventReg_SEEE_2018GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TBEventReg_SEEE_2018GroupByArgs['orderBy'] }
        : { orderBy?: TBEventReg_SEEE_2018GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TBEventReg_SEEE_2018GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTBEventReg_SEEE_2018GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TBEventReg_SEEE_2018.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TBEventReg_SEEE_2018Client<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TBEventReg_SEEE_2018 base type for findUnique actions
   */
  export type TBEventReg_SEEE_2018FindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018
     */
    select?: TBEventReg_SEEE_2018Select | null
    /**
     * Filter, which TBEventReg_SEEE_2018 to fetch.
     */
    where: TBEventReg_SEEE_2018WhereUniqueInput
  }

  /**
   * TBEventReg_SEEE_2018 findUnique
   */
  export interface TBEventReg_SEEE_2018FindUniqueArgs extends TBEventReg_SEEE_2018FindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_SEEE_2018 findUniqueOrThrow
   */
  export type TBEventReg_SEEE_2018FindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018
     */
    select?: TBEventReg_SEEE_2018Select | null
    /**
     * Filter, which TBEventReg_SEEE_2018 to fetch.
     */
    where: TBEventReg_SEEE_2018WhereUniqueInput
  }


  /**
   * TBEventReg_SEEE_2018 base type for findFirst actions
   */
  export type TBEventReg_SEEE_2018FindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018
     */
    select?: TBEventReg_SEEE_2018Select | null
    /**
     * Filter, which TBEventReg_SEEE_2018 to fetch.
     */
    where?: TBEventReg_SEEE_2018WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2018s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2018OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_SEEE_2018s.
     */
    cursor?: TBEventReg_SEEE_2018WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2018s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2018s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_SEEE_2018s.
     */
    distinct?: Enumerable<TBEventReg_SEEE_2018ScalarFieldEnum>
  }

  /**
   * TBEventReg_SEEE_2018 findFirst
   */
  export interface TBEventReg_SEEE_2018FindFirstArgs extends TBEventReg_SEEE_2018FindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_SEEE_2018 findFirstOrThrow
   */
  export type TBEventReg_SEEE_2018FindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018
     */
    select?: TBEventReg_SEEE_2018Select | null
    /**
     * Filter, which TBEventReg_SEEE_2018 to fetch.
     */
    where?: TBEventReg_SEEE_2018WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2018s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2018OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_SEEE_2018s.
     */
    cursor?: TBEventReg_SEEE_2018WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2018s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2018s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_SEEE_2018s.
     */
    distinct?: Enumerable<TBEventReg_SEEE_2018ScalarFieldEnum>
  }


  /**
   * TBEventReg_SEEE_2018 findMany
   */
  export type TBEventReg_SEEE_2018FindManyArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018
     */
    select?: TBEventReg_SEEE_2018Select | null
    /**
     * Filter, which TBEventReg_SEEE_2018s to fetch.
     */
    where?: TBEventReg_SEEE_2018WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2018s to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2018OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TBEventReg_SEEE_2018s.
     */
    cursor?: TBEventReg_SEEE_2018WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2018s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2018s.
     */
    skip?: number
    distinct?: Enumerable<TBEventReg_SEEE_2018ScalarFieldEnum>
  }


  /**
   * TBEventReg_SEEE_2018 create
   */
  export type TBEventReg_SEEE_2018CreateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018
     */
    select?: TBEventReg_SEEE_2018Select | null
    /**
     * The data needed to create a TBEventReg_SEEE_2018.
     */
    data: XOR<TBEventReg_SEEE_2018CreateInput, TBEventReg_SEEE_2018UncheckedCreateInput>
  }


  /**
   * TBEventReg_SEEE_2018 createMany
   */
  export type TBEventReg_SEEE_2018CreateManyArgs = {
    /**
     * The data used to create many TBEventReg_SEEE_2018s.
     */
    data: Enumerable<TBEventReg_SEEE_2018CreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TBEventReg_SEEE_2018 update
   */
  export type TBEventReg_SEEE_2018UpdateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018
     */
    select?: TBEventReg_SEEE_2018Select | null
    /**
     * The data needed to update a TBEventReg_SEEE_2018.
     */
    data: XOR<TBEventReg_SEEE_2018UpdateInput, TBEventReg_SEEE_2018UncheckedUpdateInput>
    /**
     * Choose, which TBEventReg_SEEE_2018 to update.
     */
    where: TBEventReg_SEEE_2018WhereUniqueInput
  }


  /**
   * TBEventReg_SEEE_2018 updateMany
   */
  export type TBEventReg_SEEE_2018UpdateManyArgs = {
    /**
     * The data used to update TBEventReg_SEEE_2018s.
     */
    data: XOR<TBEventReg_SEEE_2018UpdateManyMutationInput, TBEventReg_SEEE_2018UncheckedUpdateManyInput>
    /**
     * Filter which TBEventReg_SEEE_2018s to update
     */
    where?: TBEventReg_SEEE_2018WhereInput
  }


  /**
   * TBEventReg_SEEE_2018 upsert
   */
  export type TBEventReg_SEEE_2018UpsertArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018
     */
    select?: TBEventReg_SEEE_2018Select | null
    /**
     * The filter to search for the TBEventReg_SEEE_2018 to update in case it exists.
     */
    where: TBEventReg_SEEE_2018WhereUniqueInput
    /**
     * In case the TBEventReg_SEEE_2018 found by the `where` argument doesn't exist, create a new TBEventReg_SEEE_2018 with this data.
     */
    create: XOR<TBEventReg_SEEE_2018CreateInput, TBEventReg_SEEE_2018UncheckedCreateInput>
    /**
     * In case the TBEventReg_SEEE_2018 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TBEventReg_SEEE_2018UpdateInput, TBEventReg_SEEE_2018UncheckedUpdateInput>
  }


  /**
   * TBEventReg_SEEE_2018 delete
   */
  export type TBEventReg_SEEE_2018DeleteArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018
     */
    select?: TBEventReg_SEEE_2018Select | null
    /**
     * Filter which TBEventReg_SEEE_2018 to delete.
     */
    where: TBEventReg_SEEE_2018WhereUniqueInput
  }


  /**
   * TBEventReg_SEEE_2018 deleteMany
   */
  export type TBEventReg_SEEE_2018DeleteManyArgs = {
    /**
     * Filter which TBEventReg_SEEE_2018s to delete
     */
    where?: TBEventReg_SEEE_2018WhereInput
  }


  /**
   * TBEventReg_SEEE_2018 without action
   */
  export type TBEventReg_SEEE_2018Args = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018
     */
    select?: TBEventReg_SEEE_2018Select | null
  }



  /**
   * Model TBEventReg_SEEE_2018_VenderInfo
   */


  export type AggregateTBEventReg_SEEE_2018_VenderInfo = {
    _count: TBEventReg_SEEE_2018_VenderInfoCountAggregateOutputType | null
    _avg: TBEventReg_SEEE_2018_VenderInfoAvgAggregateOutputType | null
    _sum: TBEventReg_SEEE_2018_VenderInfoSumAggregateOutputType | null
    _min: TBEventReg_SEEE_2018_VenderInfoMinAggregateOutputType | null
    _max: TBEventReg_SEEE_2018_VenderInfoMaxAggregateOutputType | null
  }

  export type TBEventReg_SEEE_2018_VenderInfoAvgAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_SEEE_2018_VenderInfoSumAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_SEEE_2018_VenderInfoMinAggregateOutputType = {
    ID: number | null
    VenderCompTitle: string | null
    VenderContactPerson: string | null
    VenderResource: string | null
    VenderEmail: string | null
    VenderDescrip: string | null
    VenderBooth: string | null
    VenderTel: string | null
    TimeSlot1: string | null
    TimeSlot2: string | null
    TimeSlot3: string | null
    TimeSlot4: string | null
    TimeSlot5: string | null
    TimeSlot6: string | null
    TimeSlot7: string | null
    TimeSlot8: string | null
    TimeSlot9: string | null
    TimeSlot10: string | null
  }

  export type TBEventReg_SEEE_2018_VenderInfoMaxAggregateOutputType = {
    ID: number | null
    VenderCompTitle: string | null
    VenderContactPerson: string | null
    VenderResource: string | null
    VenderEmail: string | null
    VenderDescrip: string | null
    VenderBooth: string | null
    VenderTel: string | null
    TimeSlot1: string | null
    TimeSlot2: string | null
    TimeSlot3: string | null
    TimeSlot4: string | null
    TimeSlot5: string | null
    TimeSlot6: string | null
    TimeSlot7: string | null
    TimeSlot8: string | null
    TimeSlot9: string | null
    TimeSlot10: string | null
  }

  export type TBEventReg_SEEE_2018_VenderInfoCountAggregateOutputType = {
    ID: number
    VenderCompTitle: number
    VenderContactPerson: number
    VenderResource: number
    VenderEmail: number
    VenderDescrip: number
    VenderBooth: number
    VenderTel: number
    TimeSlot1: number
    TimeSlot2: number
    TimeSlot3: number
    TimeSlot4: number
    TimeSlot5: number
    TimeSlot6: number
    TimeSlot7: number
    TimeSlot8: number
    TimeSlot9: number
    TimeSlot10: number
    _all: number
  }


  export type TBEventReg_SEEE_2018_VenderInfoAvgAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_SEEE_2018_VenderInfoSumAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_SEEE_2018_VenderInfoMinAggregateInputType = {
    ID?: true
    VenderCompTitle?: true
    VenderContactPerson?: true
    VenderResource?: true
    VenderEmail?: true
    VenderDescrip?: true
    VenderBooth?: true
    VenderTel?: true
    TimeSlot1?: true
    TimeSlot2?: true
    TimeSlot3?: true
    TimeSlot4?: true
    TimeSlot5?: true
    TimeSlot6?: true
    TimeSlot7?: true
    TimeSlot8?: true
    TimeSlot9?: true
    TimeSlot10?: true
  }

  export type TBEventReg_SEEE_2018_VenderInfoMaxAggregateInputType = {
    ID?: true
    VenderCompTitle?: true
    VenderContactPerson?: true
    VenderResource?: true
    VenderEmail?: true
    VenderDescrip?: true
    VenderBooth?: true
    VenderTel?: true
    TimeSlot1?: true
    TimeSlot2?: true
    TimeSlot3?: true
    TimeSlot4?: true
    TimeSlot5?: true
    TimeSlot6?: true
    TimeSlot7?: true
    TimeSlot8?: true
    TimeSlot9?: true
    TimeSlot10?: true
  }

  export type TBEventReg_SEEE_2018_VenderInfoCountAggregateInputType = {
    ID?: true
    VenderCompTitle?: true
    VenderContactPerson?: true
    VenderResource?: true
    VenderEmail?: true
    VenderDescrip?: true
    VenderBooth?: true
    VenderTel?: true
    TimeSlot1?: true
    TimeSlot2?: true
    TimeSlot3?: true
    TimeSlot4?: true
    TimeSlot5?: true
    TimeSlot6?: true
    TimeSlot7?: true
    TimeSlot8?: true
    TimeSlot9?: true
    TimeSlot10?: true
    _all?: true
  }

  export type TBEventReg_SEEE_2018_VenderInfoAggregateArgs = {
    /**
     * Filter which TBEventReg_SEEE_2018_VenderInfo to aggregate.
     */
    where?: TBEventReg_SEEE_2018_VenderInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2018_VenderInfos to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2018_VenderInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TBEventReg_SEEE_2018_VenderInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2018_VenderInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2018_VenderInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TBEventReg_SEEE_2018_VenderInfos
    **/
    _count?: true | TBEventReg_SEEE_2018_VenderInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TBEventReg_SEEE_2018_VenderInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TBEventReg_SEEE_2018_VenderInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TBEventReg_SEEE_2018_VenderInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TBEventReg_SEEE_2018_VenderInfoMaxAggregateInputType
  }

  export type GetTBEventReg_SEEE_2018_VenderInfoAggregateType<T extends TBEventReg_SEEE_2018_VenderInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateTBEventReg_SEEE_2018_VenderInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTBEventReg_SEEE_2018_VenderInfo[P]>
      : GetScalarType<T[P], AggregateTBEventReg_SEEE_2018_VenderInfo[P]>
  }




  export type TBEventReg_SEEE_2018_VenderInfoGroupByArgs = {
    where?: TBEventReg_SEEE_2018_VenderInfoWhereInput
    orderBy?: Enumerable<TBEventReg_SEEE_2018_VenderInfoOrderByWithAggregationInput>
    by: TBEventReg_SEEE_2018_VenderInfoScalarFieldEnum[]
    having?: TBEventReg_SEEE_2018_VenderInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TBEventReg_SEEE_2018_VenderInfoCountAggregateInputType | true
    _avg?: TBEventReg_SEEE_2018_VenderInfoAvgAggregateInputType
    _sum?: TBEventReg_SEEE_2018_VenderInfoSumAggregateInputType
    _min?: TBEventReg_SEEE_2018_VenderInfoMinAggregateInputType
    _max?: TBEventReg_SEEE_2018_VenderInfoMaxAggregateInputType
  }


  export type TBEventReg_SEEE_2018_VenderInfoGroupByOutputType = {
    ID: number
    VenderCompTitle: string
    VenderContactPerson: string
    VenderResource: string
    VenderEmail: string
    VenderDescrip: string
    VenderBooth: string
    VenderTel: string
    TimeSlot1: string
    TimeSlot2: string
    TimeSlot3: string
    TimeSlot4: string
    TimeSlot5: string
    TimeSlot6: string
    TimeSlot7: string
    TimeSlot8: string
    TimeSlot9: string
    TimeSlot10: string
    _count: TBEventReg_SEEE_2018_VenderInfoCountAggregateOutputType | null
    _avg: TBEventReg_SEEE_2018_VenderInfoAvgAggregateOutputType | null
    _sum: TBEventReg_SEEE_2018_VenderInfoSumAggregateOutputType | null
    _min: TBEventReg_SEEE_2018_VenderInfoMinAggregateOutputType | null
    _max: TBEventReg_SEEE_2018_VenderInfoMaxAggregateOutputType | null
  }

  type GetTBEventReg_SEEE_2018_VenderInfoGroupByPayload<T extends TBEventReg_SEEE_2018_VenderInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TBEventReg_SEEE_2018_VenderInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TBEventReg_SEEE_2018_VenderInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TBEventReg_SEEE_2018_VenderInfoGroupByOutputType[P]>
            : GetScalarType<T[P], TBEventReg_SEEE_2018_VenderInfoGroupByOutputType[P]>
        }
      >
    >


  export type TBEventReg_SEEE_2018_VenderInfoSelect = {
    ID?: boolean
    VenderCompTitle?: boolean
    VenderContactPerson?: boolean
    VenderResource?: boolean
    VenderEmail?: boolean
    VenderDescrip?: boolean
    VenderBooth?: boolean
    VenderTel?: boolean
    TimeSlot1?: boolean
    TimeSlot2?: boolean
    TimeSlot3?: boolean
    TimeSlot4?: boolean
    TimeSlot5?: boolean
    TimeSlot6?: boolean
    TimeSlot7?: boolean
    TimeSlot8?: boolean
    TimeSlot9?: boolean
    TimeSlot10?: boolean
  }


  export type TBEventReg_SEEE_2018_VenderInfoGetPayload<S extends boolean | null | undefined | TBEventReg_SEEE_2018_VenderInfoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TBEventReg_SEEE_2018_VenderInfo :
    S extends undefined ? never :
    S extends { include: any } & (TBEventReg_SEEE_2018_VenderInfoArgs | TBEventReg_SEEE_2018_VenderInfoFindManyArgs)
    ? TBEventReg_SEEE_2018_VenderInfo 
    : S extends { select: any } & (TBEventReg_SEEE_2018_VenderInfoArgs | TBEventReg_SEEE_2018_VenderInfoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TBEventReg_SEEE_2018_VenderInfo ? TBEventReg_SEEE_2018_VenderInfo[P] : never
  } 
      : TBEventReg_SEEE_2018_VenderInfo


  type TBEventReg_SEEE_2018_VenderInfoCountArgs = 
    Omit<TBEventReg_SEEE_2018_VenderInfoFindManyArgs, 'select' | 'include'> & {
      select?: TBEventReg_SEEE_2018_VenderInfoCountAggregateInputType | true
    }

  export interface TBEventReg_SEEE_2018_VenderInfoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TBEventReg_SEEE_2018_VenderInfo that matches the filter.
     * @param {TBEventReg_SEEE_2018_VenderInfoFindUniqueArgs} args - Arguments to find a TBEventReg_SEEE_2018_VenderInfo
     * @example
     * // Get one TBEventReg_SEEE_2018_VenderInfo
     * const tBEventReg_SEEE_2018_VenderInfo = await prisma.tBEventReg_SEEE_2018_VenderInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TBEventReg_SEEE_2018_VenderInfoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TBEventReg_SEEE_2018_VenderInfoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TBEventReg_SEEE_2018_VenderInfo'> extends True ? Prisma__TBEventReg_SEEE_2018_VenderInfoClient<TBEventReg_SEEE_2018_VenderInfoGetPayload<T>> : Prisma__TBEventReg_SEEE_2018_VenderInfoClient<TBEventReg_SEEE_2018_VenderInfoGetPayload<T> | null, null>

    /**
     * Find one TBEventReg_SEEE_2018_VenderInfo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TBEventReg_SEEE_2018_VenderInfoFindUniqueOrThrowArgs} args - Arguments to find a TBEventReg_SEEE_2018_VenderInfo
     * @example
     * // Get one TBEventReg_SEEE_2018_VenderInfo
     * const tBEventReg_SEEE_2018_VenderInfo = await prisma.tBEventReg_SEEE_2018_VenderInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TBEventReg_SEEE_2018_VenderInfoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2018_VenderInfoFindUniqueOrThrowArgs>
    ): Prisma__TBEventReg_SEEE_2018_VenderInfoClient<TBEventReg_SEEE_2018_VenderInfoGetPayload<T>>

    /**
     * Find the first TBEventReg_SEEE_2018_VenderInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2018_VenderInfoFindFirstArgs} args - Arguments to find a TBEventReg_SEEE_2018_VenderInfo
     * @example
     * // Get one TBEventReg_SEEE_2018_VenderInfo
     * const tBEventReg_SEEE_2018_VenderInfo = await prisma.tBEventReg_SEEE_2018_VenderInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TBEventReg_SEEE_2018_VenderInfoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TBEventReg_SEEE_2018_VenderInfoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TBEventReg_SEEE_2018_VenderInfo'> extends True ? Prisma__TBEventReg_SEEE_2018_VenderInfoClient<TBEventReg_SEEE_2018_VenderInfoGetPayload<T>> : Prisma__TBEventReg_SEEE_2018_VenderInfoClient<TBEventReg_SEEE_2018_VenderInfoGetPayload<T> | null, null>

    /**
     * Find the first TBEventReg_SEEE_2018_VenderInfo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2018_VenderInfoFindFirstOrThrowArgs} args - Arguments to find a TBEventReg_SEEE_2018_VenderInfo
     * @example
     * // Get one TBEventReg_SEEE_2018_VenderInfo
     * const tBEventReg_SEEE_2018_VenderInfo = await prisma.tBEventReg_SEEE_2018_VenderInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TBEventReg_SEEE_2018_VenderInfoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2018_VenderInfoFindFirstOrThrowArgs>
    ): Prisma__TBEventReg_SEEE_2018_VenderInfoClient<TBEventReg_SEEE_2018_VenderInfoGetPayload<T>>

    /**
     * Find zero or more TBEventReg_SEEE_2018_VenderInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2018_VenderInfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TBEventReg_SEEE_2018_VenderInfos
     * const tBEventReg_SEEE_2018_VenderInfos = await prisma.tBEventReg_SEEE_2018_VenderInfo.findMany()
     * 
     * // Get first 10 TBEventReg_SEEE_2018_VenderInfos
     * const tBEventReg_SEEE_2018_VenderInfos = await prisma.tBEventReg_SEEE_2018_VenderInfo.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tBEventReg_SEEE_2018_VenderInfoWithIDOnly = await prisma.tBEventReg_SEEE_2018_VenderInfo.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends TBEventReg_SEEE_2018_VenderInfoFindManyArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2018_VenderInfoFindManyArgs>
    ): Prisma.PrismaPromise<Array<TBEventReg_SEEE_2018_VenderInfoGetPayload<T>>>

    /**
     * Create a TBEventReg_SEEE_2018_VenderInfo.
     * @param {TBEventReg_SEEE_2018_VenderInfoCreateArgs} args - Arguments to create a TBEventReg_SEEE_2018_VenderInfo.
     * @example
     * // Create one TBEventReg_SEEE_2018_VenderInfo
     * const TBEventReg_SEEE_2018_VenderInfo = await prisma.tBEventReg_SEEE_2018_VenderInfo.create({
     *   data: {
     *     // ... data to create a TBEventReg_SEEE_2018_VenderInfo
     *   }
     * })
     * 
    **/
    create<T extends TBEventReg_SEEE_2018_VenderInfoCreateArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2018_VenderInfoCreateArgs>
    ): Prisma__TBEventReg_SEEE_2018_VenderInfoClient<TBEventReg_SEEE_2018_VenderInfoGetPayload<T>>

    /**
     * Create many TBEventReg_SEEE_2018_VenderInfos.
     *     @param {TBEventReg_SEEE_2018_VenderInfoCreateManyArgs} args - Arguments to create many TBEventReg_SEEE_2018_VenderInfos.
     *     @example
     *     // Create many TBEventReg_SEEE_2018_VenderInfos
     *     const tBEventReg_SEEE_2018_VenderInfo = await prisma.tBEventReg_SEEE_2018_VenderInfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TBEventReg_SEEE_2018_VenderInfoCreateManyArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2018_VenderInfoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TBEventReg_SEEE_2018_VenderInfo.
     * @param {TBEventReg_SEEE_2018_VenderInfoDeleteArgs} args - Arguments to delete one TBEventReg_SEEE_2018_VenderInfo.
     * @example
     * // Delete one TBEventReg_SEEE_2018_VenderInfo
     * const TBEventReg_SEEE_2018_VenderInfo = await prisma.tBEventReg_SEEE_2018_VenderInfo.delete({
     *   where: {
     *     // ... filter to delete one TBEventReg_SEEE_2018_VenderInfo
     *   }
     * })
     * 
    **/
    delete<T extends TBEventReg_SEEE_2018_VenderInfoDeleteArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2018_VenderInfoDeleteArgs>
    ): Prisma__TBEventReg_SEEE_2018_VenderInfoClient<TBEventReg_SEEE_2018_VenderInfoGetPayload<T>>

    /**
     * Update one TBEventReg_SEEE_2018_VenderInfo.
     * @param {TBEventReg_SEEE_2018_VenderInfoUpdateArgs} args - Arguments to update one TBEventReg_SEEE_2018_VenderInfo.
     * @example
     * // Update one TBEventReg_SEEE_2018_VenderInfo
     * const tBEventReg_SEEE_2018_VenderInfo = await prisma.tBEventReg_SEEE_2018_VenderInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TBEventReg_SEEE_2018_VenderInfoUpdateArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2018_VenderInfoUpdateArgs>
    ): Prisma__TBEventReg_SEEE_2018_VenderInfoClient<TBEventReg_SEEE_2018_VenderInfoGetPayload<T>>

    /**
     * Delete zero or more TBEventReg_SEEE_2018_VenderInfos.
     * @param {TBEventReg_SEEE_2018_VenderInfoDeleteManyArgs} args - Arguments to filter TBEventReg_SEEE_2018_VenderInfos to delete.
     * @example
     * // Delete a few TBEventReg_SEEE_2018_VenderInfos
     * const { count } = await prisma.tBEventReg_SEEE_2018_VenderInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TBEventReg_SEEE_2018_VenderInfoDeleteManyArgs>(
      args?: SelectSubset<T, TBEventReg_SEEE_2018_VenderInfoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TBEventReg_SEEE_2018_VenderInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2018_VenderInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TBEventReg_SEEE_2018_VenderInfos
     * const tBEventReg_SEEE_2018_VenderInfo = await prisma.tBEventReg_SEEE_2018_VenderInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TBEventReg_SEEE_2018_VenderInfoUpdateManyArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2018_VenderInfoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TBEventReg_SEEE_2018_VenderInfo.
     * @param {TBEventReg_SEEE_2018_VenderInfoUpsertArgs} args - Arguments to update or create a TBEventReg_SEEE_2018_VenderInfo.
     * @example
     * // Update or create a TBEventReg_SEEE_2018_VenderInfo
     * const tBEventReg_SEEE_2018_VenderInfo = await prisma.tBEventReg_SEEE_2018_VenderInfo.upsert({
     *   create: {
     *     // ... data to create a TBEventReg_SEEE_2018_VenderInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TBEventReg_SEEE_2018_VenderInfo we want to update
     *   }
     * })
    **/
    upsert<T extends TBEventReg_SEEE_2018_VenderInfoUpsertArgs>(
      args: SelectSubset<T, TBEventReg_SEEE_2018_VenderInfoUpsertArgs>
    ): Prisma__TBEventReg_SEEE_2018_VenderInfoClient<TBEventReg_SEEE_2018_VenderInfoGetPayload<T>>

    /**
     * Count the number of TBEventReg_SEEE_2018_VenderInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2018_VenderInfoCountArgs} args - Arguments to filter TBEventReg_SEEE_2018_VenderInfos to count.
     * @example
     * // Count the number of TBEventReg_SEEE_2018_VenderInfos
     * const count = await prisma.tBEventReg_SEEE_2018_VenderInfo.count({
     *   where: {
     *     // ... the filter for the TBEventReg_SEEE_2018_VenderInfos we want to count
     *   }
     * })
    **/
    count<T extends TBEventReg_SEEE_2018_VenderInfoCountArgs>(
      args?: Subset<T, TBEventReg_SEEE_2018_VenderInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TBEventReg_SEEE_2018_VenderInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TBEventReg_SEEE_2018_VenderInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2018_VenderInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TBEventReg_SEEE_2018_VenderInfoAggregateArgs>(args: Subset<T, TBEventReg_SEEE_2018_VenderInfoAggregateArgs>): Prisma.PrismaPromise<GetTBEventReg_SEEE_2018_VenderInfoAggregateType<T>>

    /**
     * Group by TBEventReg_SEEE_2018_VenderInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SEEE_2018_VenderInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TBEventReg_SEEE_2018_VenderInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TBEventReg_SEEE_2018_VenderInfoGroupByArgs['orderBy'] }
        : { orderBy?: TBEventReg_SEEE_2018_VenderInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TBEventReg_SEEE_2018_VenderInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTBEventReg_SEEE_2018_VenderInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TBEventReg_SEEE_2018_VenderInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TBEventReg_SEEE_2018_VenderInfoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TBEventReg_SEEE_2018_VenderInfo base type for findUnique actions
   */
  export type TBEventReg_SEEE_2018_VenderInfoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018_VenderInfo
     */
    select?: TBEventReg_SEEE_2018_VenderInfoSelect | null
    /**
     * Filter, which TBEventReg_SEEE_2018_VenderInfo to fetch.
     */
    where: TBEventReg_SEEE_2018_VenderInfoWhereUniqueInput
  }

  /**
   * TBEventReg_SEEE_2018_VenderInfo findUnique
   */
  export interface TBEventReg_SEEE_2018_VenderInfoFindUniqueArgs extends TBEventReg_SEEE_2018_VenderInfoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_SEEE_2018_VenderInfo findUniqueOrThrow
   */
  export type TBEventReg_SEEE_2018_VenderInfoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018_VenderInfo
     */
    select?: TBEventReg_SEEE_2018_VenderInfoSelect | null
    /**
     * Filter, which TBEventReg_SEEE_2018_VenderInfo to fetch.
     */
    where: TBEventReg_SEEE_2018_VenderInfoWhereUniqueInput
  }


  /**
   * TBEventReg_SEEE_2018_VenderInfo base type for findFirst actions
   */
  export type TBEventReg_SEEE_2018_VenderInfoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018_VenderInfo
     */
    select?: TBEventReg_SEEE_2018_VenderInfoSelect | null
    /**
     * Filter, which TBEventReg_SEEE_2018_VenderInfo to fetch.
     */
    where?: TBEventReg_SEEE_2018_VenderInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2018_VenderInfos to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2018_VenderInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_SEEE_2018_VenderInfos.
     */
    cursor?: TBEventReg_SEEE_2018_VenderInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2018_VenderInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2018_VenderInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_SEEE_2018_VenderInfos.
     */
    distinct?: Enumerable<TBEventReg_SEEE_2018_VenderInfoScalarFieldEnum>
  }

  /**
   * TBEventReg_SEEE_2018_VenderInfo findFirst
   */
  export interface TBEventReg_SEEE_2018_VenderInfoFindFirstArgs extends TBEventReg_SEEE_2018_VenderInfoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_SEEE_2018_VenderInfo findFirstOrThrow
   */
  export type TBEventReg_SEEE_2018_VenderInfoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018_VenderInfo
     */
    select?: TBEventReg_SEEE_2018_VenderInfoSelect | null
    /**
     * Filter, which TBEventReg_SEEE_2018_VenderInfo to fetch.
     */
    where?: TBEventReg_SEEE_2018_VenderInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2018_VenderInfos to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2018_VenderInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_SEEE_2018_VenderInfos.
     */
    cursor?: TBEventReg_SEEE_2018_VenderInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2018_VenderInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2018_VenderInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_SEEE_2018_VenderInfos.
     */
    distinct?: Enumerable<TBEventReg_SEEE_2018_VenderInfoScalarFieldEnum>
  }


  /**
   * TBEventReg_SEEE_2018_VenderInfo findMany
   */
  export type TBEventReg_SEEE_2018_VenderInfoFindManyArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018_VenderInfo
     */
    select?: TBEventReg_SEEE_2018_VenderInfoSelect | null
    /**
     * Filter, which TBEventReg_SEEE_2018_VenderInfos to fetch.
     */
    where?: TBEventReg_SEEE_2018_VenderInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SEEE_2018_VenderInfos to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SEEE_2018_VenderInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TBEventReg_SEEE_2018_VenderInfos.
     */
    cursor?: TBEventReg_SEEE_2018_VenderInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SEEE_2018_VenderInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SEEE_2018_VenderInfos.
     */
    skip?: number
    distinct?: Enumerable<TBEventReg_SEEE_2018_VenderInfoScalarFieldEnum>
  }


  /**
   * TBEventReg_SEEE_2018_VenderInfo create
   */
  export type TBEventReg_SEEE_2018_VenderInfoCreateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018_VenderInfo
     */
    select?: TBEventReg_SEEE_2018_VenderInfoSelect | null
    /**
     * The data needed to create a TBEventReg_SEEE_2018_VenderInfo.
     */
    data: XOR<TBEventReg_SEEE_2018_VenderInfoCreateInput, TBEventReg_SEEE_2018_VenderInfoUncheckedCreateInput>
  }


  /**
   * TBEventReg_SEEE_2018_VenderInfo createMany
   */
  export type TBEventReg_SEEE_2018_VenderInfoCreateManyArgs = {
    /**
     * The data used to create many TBEventReg_SEEE_2018_VenderInfos.
     */
    data: Enumerable<TBEventReg_SEEE_2018_VenderInfoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TBEventReg_SEEE_2018_VenderInfo update
   */
  export type TBEventReg_SEEE_2018_VenderInfoUpdateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018_VenderInfo
     */
    select?: TBEventReg_SEEE_2018_VenderInfoSelect | null
    /**
     * The data needed to update a TBEventReg_SEEE_2018_VenderInfo.
     */
    data: XOR<TBEventReg_SEEE_2018_VenderInfoUpdateInput, TBEventReg_SEEE_2018_VenderInfoUncheckedUpdateInput>
    /**
     * Choose, which TBEventReg_SEEE_2018_VenderInfo to update.
     */
    where: TBEventReg_SEEE_2018_VenderInfoWhereUniqueInput
  }


  /**
   * TBEventReg_SEEE_2018_VenderInfo updateMany
   */
  export type TBEventReg_SEEE_2018_VenderInfoUpdateManyArgs = {
    /**
     * The data used to update TBEventReg_SEEE_2018_VenderInfos.
     */
    data: XOR<TBEventReg_SEEE_2018_VenderInfoUpdateManyMutationInput, TBEventReg_SEEE_2018_VenderInfoUncheckedUpdateManyInput>
    /**
     * Filter which TBEventReg_SEEE_2018_VenderInfos to update
     */
    where?: TBEventReg_SEEE_2018_VenderInfoWhereInput
  }


  /**
   * TBEventReg_SEEE_2018_VenderInfo upsert
   */
  export type TBEventReg_SEEE_2018_VenderInfoUpsertArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018_VenderInfo
     */
    select?: TBEventReg_SEEE_2018_VenderInfoSelect | null
    /**
     * The filter to search for the TBEventReg_SEEE_2018_VenderInfo to update in case it exists.
     */
    where: TBEventReg_SEEE_2018_VenderInfoWhereUniqueInput
    /**
     * In case the TBEventReg_SEEE_2018_VenderInfo found by the `where` argument doesn't exist, create a new TBEventReg_SEEE_2018_VenderInfo with this data.
     */
    create: XOR<TBEventReg_SEEE_2018_VenderInfoCreateInput, TBEventReg_SEEE_2018_VenderInfoUncheckedCreateInput>
    /**
     * In case the TBEventReg_SEEE_2018_VenderInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TBEventReg_SEEE_2018_VenderInfoUpdateInput, TBEventReg_SEEE_2018_VenderInfoUncheckedUpdateInput>
  }


  /**
   * TBEventReg_SEEE_2018_VenderInfo delete
   */
  export type TBEventReg_SEEE_2018_VenderInfoDeleteArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018_VenderInfo
     */
    select?: TBEventReg_SEEE_2018_VenderInfoSelect | null
    /**
     * Filter which TBEventReg_SEEE_2018_VenderInfo to delete.
     */
    where: TBEventReg_SEEE_2018_VenderInfoWhereUniqueInput
  }


  /**
   * TBEventReg_SEEE_2018_VenderInfo deleteMany
   */
  export type TBEventReg_SEEE_2018_VenderInfoDeleteManyArgs = {
    /**
     * Filter which TBEventReg_SEEE_2018_VenderInfos to delete
     */
    where?: TBEventReg_SEEE_2018_VenderInfoWhereInput
  }


  /**
   * TBEventReg_SEEE_2018_VenderInfo without action
   */
  export type TBEventReg_SEEE_2018_VenderInfoArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SEEE_2018_VenderInfo
     */
    select?: TBEventReg_SEEE_2018_VenderInfoSelect | null
  }



  /**
   * Model TBEventReg_SpringIntoAction
   */


  export type AggregateTBEventReg_SpringIntoAction = {
    _count: TBEventReg_SpringIntoActionCountAggregateOutputType | null
    _avg: TBEventReg_SpringIntoActionAvgAggregateOutputType | null
    _sum: TBEventReg_SpringIntoActionSumAggregateOutputType | null
    _min: TBEventReg_SpringIntoActionMinAggregateOutputType | null
    _max: TBEventReg_SpringIntoActionMaxAggregateOutputType | null
  }

  export type TBEventReg_SpringIntoActionAvgAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_SpringIntoActionSumAggregateOutputType = {
    ID: number | null
  }

  export type TBEventReg_SpringIntoActionMinAggregateOutputType = {
    ID: number | null
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegDate: Date | null
    RegIP: string | null
  }

  export type TBEventReg_SpringIntoActionMaxAggregateOutputType = {
    ID: number | null
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegDate: Date | null
    RegIP: string | null
  }

  export type TBEventReg_SpringIntoActionCountAggregateOutputType = {
    ID: number
    EventTitle: number
    RegName: number
    RegEmail: number
    RegTel: number
    RegAddress: number
    RegDate: number
    RegIP: number
    _all: number
  }


  export type TBEventReg_SpringIntoActionAvgAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_SpringIntoActionSumAggregateInputType = {
    ID?: true
  }

  export type TBEventReg_SpringIntoActionMinAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegDate?: true
    RegIP?: true
  }

  export type TBEventReg_SpringIntoActionMaxAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegDate?: true
    RegIP?: true
  }

  export type TBEventReg_SpringIntoActionCountAggregateInputType = {
    ID?: true
    EventTitle?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    RegAddress?: true
    RegDate?: true
    RegIP?: true
    _all?: true
  }

  export type TBEventReg_SpringIntoActionAggregateArgs = {
    /**
     * Filter which TBEventReg_SpringIntoAction to aggregate.
     */
    where?: TBEventReg_SpringIntoActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SpringIntoActions to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SpringIntoActionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TBEventReg_SpringIntoActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SpringIntoActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SpringIntoActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TBEventReg_SpringIntoActions
    **/
    _count?: true | TBEventReg_SpringIntoActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TBEventReg_SpringIntoActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TBEventReg_SpringIntoActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TBEventReg_SpringIntoActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TBEventReg_SpringIntoActionMaxAggregateInputType
  }

  export type GetTBEventReg_SpringIntoActionAggregateType<T extends TBEventReg_SpringIntoActionAggregateArgs> = {
        [P in keyof T & keyof AggregateTBEventReg_SpringIntoAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTBEventReg_SpringIntoAction[P]>
      : GetScalarType<T[P], AggregateTBEventReg_SpringIntoAction[P]>
  }




  export type TBEventReg_SpringIntoActionGroupByArgs = {
    where?: TBEventReg_SpringIntoActionWhereInput
    orderBy?: Enumerable<TBEventReg_SpringIntoActionOrderByWithAggregationInput>
    by: TBEventReg_SpringIntoActionScalarFieldEnum[]
    having?: TBEventReg_SpringIntoActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TBEventReg_SpringIntoActionCountAggregateInputType | true
    _avg?: TBEventReg_SpringIntoActionAvgAggregateInputType
    _sum?: TBEventReg_SpringIntoActionSumAggregateInputType
    _min?: TBEventReg_SpringIntoActionMinAggregateInputType
    _max?: TBEventReg_SpringIntoActionMaxAggregateInputType
  }


  export type TBEventReg_SpringIntoActionGroupByOutputType = {
    ID: number
    EventTitle: string | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    RegAddress: string | null
    RegDate: Date | null
    RegIP: string
    _count: TBEventReg_SpringIntoActionCountAggregateOutputType | null
    _avg: TBEventReg_SpringIntoActionAvgAggregateOutputType | null
    _sum: TBEventReg_SpringIntoActionSumAggregateOutputType | null
    _min: TBEventReg_SpringIntoActionMinAggregateOutputType | null
    _max: TBEventReg_SpringIntoActionMaxAggregateOutputType | null
  }

  type GetTBEventReg_SpringIntoActionGroupByPayload<T extends TBEventReg_SpringIntoActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TBEventReg_SpringIntoActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TBEventReg_SpringIntoActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TBEventReg_SpringIntoActionGroupByOutputType[P]>
            : GetScalarType<T[P], TBEventReg_SpringIntoActionGroupByOutputType[P]>
        }
      >
    >


  export type TBEventReg_SpringIntoActionSelect = {
    ID?: boolean
    EventTitle?: boolean
    RegName?: boolean
    RegEmail?: boolean
    RegTel?: boolean
    RegAddress?: boolean
    RegDate?: boolean
    RegIP?: boolean
  }


  export type TBEventReg_SpringIntoActionGetPayload<S extends boolean | null | undefined | TBEventReg_SpringIntoActionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TBEventReg_SpringIntoAction :
    S extends undefined ? never :
    S extends { include: any } & (TBEventReg_SpringIntoActionArgs | TBEventReg_SpringIntoActionFindManyArgs)
    ? TBEventReg_SpringIntoAction 
    : S extends { select: any } & (TBEventReg_SpringIntoActionArgs | TBEventReg_SpringIntoActionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TBEventReg_SpringIntoAction ? TBEventReg_SpringIntoAction[P] : never
  } 
      : TBEventReg_SpringIntoAction


  type TBEventReg_SpringIntoActionCountArgs = 
    Omit<TBEventReg_SpringIntoActionFindManyArgs, 'select' | 'include'> & {
      select?: TBEventReg_SpringIntoActionCountAggregateInputType | true
    }

  export interface TBEventReg_SpringIntoActionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TBEventReg_SpringIntoAction that matches the filter.
     * @param {TBEventReg_SpringIntoActionFindUniqueArgs} args - Arguments to find a TBEventReg_SpringIntoAction
     * @example
     * // Get one TBEventReg_SpringIntoAction
     * const tBEventReg_SpringIntoAction = await prisma.tBEventReg_SpringIntoAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TBEventReg_SpringIntoActionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TBEventReg_SpringIntoActionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TBEventReg_SpringIntoAction'> extends True ? Prisma__TBEventReg_SpringIntoActionClient<TBEventReg_SpringIntoActionGetPayload<T>> : Prisma__TBEventReg_SpringIntoActionClient<TBEventReg_SpringIntoActionGetPayload<T> | null, null>

    /**
     * Find one TBEventReg_SpringIntoAction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TBEventReg_SpringIntoActionFindUniqueOrThrowArgs} args - Arguments to find a TBEventReg_SpringIntoAction
     * @example
     * // Get one TBEventReg_SpringIntoAction
     * const tBEventReg_SpringIntoAction = await prisma.tBEventReg_SpringIntoAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TBEventReg_SpringIntoActionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_SpringIntoActionFindUniqueOrThrowArgs>
    ): Prisma__TBEventReg_SpringIntoActionClient<TBEventReg_SpringIntoActionGetPayload<T>>

    /**
     * Find the first TBEventReg_SpringIntoAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SpringIntoActionFindFirstArgs} args - Arguments to find a TBEventReg_SpringIntoAction
     * @example
     * // Get one TBEventReg_SpringIntoAction
     * const tBEventReg_SpringIntoAction = await prisma.tBEventReg_SpringIntoAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TBEventReg_SpringIntoActionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TBEventReg_SpringIntoActionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TBEventReg_SpringIntoAction'> extends True ? Prisma__TBEventReg_SpringIntoActionClient<TBEventReg_SpringIntoActionGetPayload<T>> : Prisma__TBEventReg_SpringIntoActionClient<TBEventReg_SpringIntoActionGetPayload<T> | null, null>

    /**
     * Find the first TBEventReg_SpringIntoAction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SpringIntoActionFindFirstOrThrowArgs} args - Arguments to find a TBEventReg_SpringIntoAction
     * @example
     * // Get one TBEventReg_SpringIntoAction
     * const tBEventReg_SpringIntoAction = await prisma.tBEventReg_SpringIntoAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TBEventReg_SpringIntoActionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TBEventReg_SpringIntoActionFindFirstOrThrowArgs>
    ): Prisma__TBEventReg_SpringIntoActionClient<TBEventReg_SpringIntoActionGetPayload<T>>

    /**
     * Find zero or more TBEventReg_SpringIntoActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SpringIntoActionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TBEventReg_SpringIntoActions
     * const tBEventReg_SpringIntoActions = await prisma.tBEventReg_SpringIntoAction.findMany()
     * 
     * // Get first 10 TBEventReg_SpringIntoActions
     * const tBEventReg_SpringIntoActions = await prisma.tBEventReg_SpringIntoAction.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tBEventReg_SpringIntoActionWithIDOnly = await prisma.tBEventReg_SpringIntoAction.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends TBEventReg_SpringIntoActionFindManyArgs>(
      args?: SelectSubset<T, TBEventReg_SpringIntoActionFindManyArgs>
    ): Prisma.PrismaPromise<Array<TBEventReg_SpringIntoActionGetPayload<T>>>

    /**
     * Create a TBEventReg_SpringIntoAction.
     * @param {TBEventReg_SpringIntoActionCreateArgs} args - Arguments to create a TBEventReg_SpringIntoAction.
     * @example
     * // Create one TBEventReg_SpringIntoAction
     * const TBEventReg_SpringIntoAction = await prisma.tBEventReg_SpringIntoAction.create({
     *   data: {
     *     // ... data to create a TBEventReg_SpringIntoAction
     *   }
     * })
     * 
    **/
    create<T extends TBEventReg_SpringIntoActionCreateArgs>(
      args: SelectSubset<T, TBEventReg_SpringIntoActionCreateArgs>
    ): Prisma__TBEventReg_SpringIntoActionClient<TBEventReg_SpringIntoActionGetPayload<T>>

    /**
     * Create many TBEventReg_SpringIntoActions.
     *     @param {TBEventReg_SpringIntoActionCreateManyArgs} args - Arguments to create many TBEventReg_SpringIntoActions.
     *     @example
     *     // Create many TBEventReg_SpringIntoActions
     *     const tBEventReg_SpringIntoAction = await prisma.tBEventReg_SpringIntoAction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TBEventReg_SpringIntoActionCreateManyArgs>(
      args?: SelectSubset<T, TBEventReg_SpringIntoActionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TBEventReg_SpringIntoAction.
     * @param {TBEventReg_SpringIntoActionDeleteArgs} args - Arguments to delete one TBEventReg_SpringIntoAction.
     * @example
     * // Delete one TBEventReg_SpringIntoAction
     * const TBEventReg_SpringIntoAction = await prisma.tBEventReg_SpringIntoAction.delete({
     *   where: {
     *     // ... filter to delete one TBEventReg_SpringIntoAction
     *   }
     * })
     * 
    **/
    delete<T extends TBEventReg_SpringIntoActionDeleteArgs>(
      args: SelectSubset<T, TBEventReg_SpringIntoActionDeleteArgs>
    ): Prisma__TBEventReg_SpringIntoActionClient<TBEventReg_SpringIntoActionGetPayload<T>>

    /**
     * Update one TBEventReg_SpringIntoAction.
     * @param {TBEventReg_SpringIntoActionUpdateArgs} args - Arguments to update one TBEventReg_SpringIntoAction.
     * @example
     * // Update one TBEventReg_SpringIntoAction
     * const tBEventReg_SpringIntoAction = await prisma.tBEventReg_SpringIntoAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TBEventReg_SpringIntoActionUpdateArgs>(
      args: SelectSubset<T, TBEventReg_SpringIntoActionUpdateArgs>
    ): Prisma__TBEventReg_SpringIntoActionClient<TBEventReg_SpringIntoActionGetPayload<T>>

    /**
     * Delete zero or more TBEventReg_SpringIntoActions.
     * @param {TBEventReg_SpringIntoActionDeleteManyArgs} args - Arguments to filter TBEventReg_SpringIntoActions to delete.
     * @example
     * // Delete a few TBEventReg_SpringIntoActions
     * const { count } = await prisma.tBEventReg_SpringIntoAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TBEventReg_SpringIntoActionDeleteManyArgs>(
      args?: SelectSubset<T, TBEventReg_SpringIntoActionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TBEventReg_SpringIntoActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SpringIntoActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TBEventReg_SpringIntoActions
     * const tBEventReg_SpringIntoAction = await prisma.tBEventReg_SpringIntoAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TBEventReg_SpringIntoActionUpdateManyArgs>(
      args: SelectSubset<T, TBEventReg_SpringIntoActionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TBEventReg_SpringIntoAction.
     * @param {TBEventReg_SpringIntoActionUpsertArgs} args - Arguments to update or create a TBEventReg_SpringIntoAction.
     * @example
     * // Update or create a TBEventReg_SpringIntoAction
     * const tBEventReg_SpringIntoAction = await prisma.tBEventReg_SpringIntoAction.upsert({
     *   create: {
     *     // ... data to create a TBEventReg_SpringIntoAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TBEventReg_SpringIntoAction we want to update
     *   }
     * })
    **/
    upsert<T extends TBEventReg_SpringIntoActionUpsertArgs>(
      args: SelectSubset<T, TBEventReg_SpringIntoActionUpsertArgs>
    ): Prisma__TBEventReg_SpringIntoActionClient<TBEventReg_SpringIntoActionGetPayload<T>>

    /**
     * Count the number of TBEventReg_SpringIntoActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SpringIntoActionCountArgs} args - Arguments to filter TBEventReg_SpringIntoActions to count.
     * @example
     * // Count the number of TBEventReg_SpringIntoActions
     * const count = await prisma.tBEventReg_SpringIntoAction.count({
     *   where: {
     *     // ... the filter for the TBEventReg_SpringIntoActions we want to count
     *   }
     * })
    **/
    count<T extends TBEventReg_SpringIntoActionCountArgs>(
      args?: Subset<T, TBEventReg_SpringIntoActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TBEventReg_SpringIntoActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TBEventReg_SpringIntoAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SpringIntoActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TBEventReg_SpringIntoActionAggregateArgs>(args: Subset<T, TBEventReg_SpringIntoActionAggregateArgs>): Prisma.PrismaPromise<GetTBEventReg_SpringIntoActionAggregateType<T>>

    /**
     * Group by TBEventReg_SpringIntoAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBEventReg_SpringIntoActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TBEventReg_SpringIntoActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TBEventReg_SpringIntoActionGroupByArgs['orderBy'] }
        : { orderBy?: TBEventReg_SpringIntoActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TBEventReg_SpringIntoActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTBEventReg_SpringIntoActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TBEventReg_SpringIntoAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TBEventReg_SpringIntoActionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TBEventReg_SpringIntoAction base type for findUnique actions
   */
  export type TBEventReg_SpringIntoActionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_SpringIntoAction
     */
    select?: TBEventReg_SpringIntoActionSelect | null
    /**
     * Filter, which TBEventReg_SpringIntoAction to fetch.
     */
    where: TBEventReg_SpringIntoActionWhereUniqueInput
  }

  /**
   * TBEventReg_SpringIntoAction findUnique
   */
  export interface TBEventReg_SpringIntoActionFindUniqueArgs extends TBEventReg_SpringIntoActionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_SpringIntoAction findUniqueOrThrow
   */
  export type TBEventReg_SpringIntoActionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SpringIntoAction
     */
    select?: TBEventReg_SpringIntoActionSelect | null
    /**
     * Filter, which TBEventReg_SpringIntoAction to fetch.
     */
    where: TBEventReg_SpringIntoActionWhereUniqueInput
  }


  /**
   * TBEventReg_SpringIntoAction base type for findFirst actions
   */
  export type TBEventReg_SpringIntoActionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TBEventReg_SpringIntoAction
     */
    select?: TBEventReg_SpringIntoActionSelect | null
    /**
     * Filter, which TBEventReg_SpringIntoAction to fetch.
     */
    where?: TBEventReg_SpringIntoActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SpringIntoActions to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SpringIntoActionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_SpringIntoActions.
     */
    cursor?: TBEventReg_SpringIntoActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SpringIntoActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SpringIntoActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_SpringIntoActions.
     */
    distinct?: Enumerable<TBEventReg_SpringIntoActionScalarFieldEnum>
  }

  /**
   * TBEventReg_SpringIntoAction findFirst
   */
  export interface TBEventReg_SpringIntoActionFindFirstArgs extends TBEventReg_SpringIntoActionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBEventReg_SpringIntoAction findFirstOrThrow
   */
  export type TBEventReg_SpringIntoActionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SpringIntoAction
     */
    select?: TBEventReg_SpringIntoActionSelect | null
    /**
     * Filter, which TBEventReg_SpringIntoAction to fetch.
     */
    where?: TBEventReg_SpringIntoActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SpringIntoActions to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SpringIntoActionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBEventReg_SpringIntoActions.
     */
    cursor?: TBEventReg_SpringIntoActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SpringIntoActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SpringIntoActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBEventReg_SpringIntoActions.
     */
    distinct?: Enumerable<TBEventReg_SpringIntoActionScalarFieldEnum>
  }


  /**
   * TBEventReg_SpringIntoAction findMany
   */
  export type TBEventReg_SpringIntoActionFindManyArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SpringIntoAction
     */
    select?: TBEventReg_SpringIntoActionSelect | null
    /**
     * Filter, which TBEventReg_SpringIntoActions to fetch.
     */
    where?: TBEventReg_SpringIntoActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBEventReg_SpringIntoActions to fetch.
     */
    orderBy?: Enumerable<TBEventReg_SpringIntoActionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TBEventReg_SpringIntoActions.
     */
    cursor?: TBEventReg_SpringIntoActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBEventReg_SpringIntoActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBEventReg_SpringIntoActions.
     */
    skip?: number
    distinct?: Enumerable<TBEventReg_SpringIntoActionScalarFieldEnum>
  }


  /**
   * TBEventReg_SpringIntoAction create
   */
  export type TBEventReg_SpringIntoActionCreateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SpringIntoAction
     */
    select?: TBEventReg_SpringIntoActionSelect | null
    /**
     * The data needed to create a TBEventReg_SpringIntoAction.
     */
    data: XOR<TBEventReg_SpringIntoActionCreateInput, TBEventReg_SpringIntoActionUncheckedCreateInput>
  }


  /**
   * TBEventReg_SpringIntoAction createMany
   */
  export type TBEventReg_SpringIntoActionCreateManyArgs = {
    /**
     * The data used to create many TBEventReg_SpringIntoActions.
     */
    data: Enumerable<TBEventReg_SpringIntoActionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TBEventReg_SpringIntoAction update
   */
  export type TBEventReg_SpringIntoActionUpdateArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SpringIntoAction
     */
    select?: TBEventReg_SpringIntoActionSelect | null
    /**
     * The data needed to update a TBEventReg_SpringIntoAction.
     */
    data: XOR<TBEventReg_SpringIntoActionUpdateInput, TBEventReg_SpringIntoActionUncheckedUpdateInput>
    /**
     * Choose, which TBEventReg_SpringIntoAction to update.
     */
    where: TBEventReg_SpringIntoActionWhereUniqueInput
  }


  /**
   * TBEventReg_SpringIntoAction updateMany
   */
  export type TBEventReg_SpringIntoActionUpdateManyArgs = {
    /**
     * The data used to update TBEventReg_SpringIntoActions.
     */
    data: XOR<TBEventReg_SpringIntoActionUpdateManyMutationInput, TBEventReg_SpringIntoActionUncheckedUpdateManyInput>
    /**
     * Filter which TBEventReg_SpringIntoActions to update
     */
    where?: TBEventReg_SpringIntoActionWhereInput
  }


  /**
   * TBEventReg_SpringIntoAction upsert
   */
  export type TBEventReg_SpringIntoActionUpsertArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SpringIntoAction
     */
    select?: TBEventReg_SpringIntoActionSelect | null
    /**
     * The filter to search for the TBEventReg_SpringIntoAction to update in case it exists.
     */
    where: TBEventReg_SpringIntoActionWhereUniqueInput
    /**
     * In case the TBEventReg_SpringIntoAction found by the `where` argument doesn't exist, create a new TBEventReg_SpringIntoAction with this data.
     */
    create: XOR<TBEventReg_SpringIntoActionCreateInput, TBEventReg_SpringIntoActionUncheckedCreateInput>
    /**
     * In case the TBEventReg_SpringIntoAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TBEventReg_SpringIntoActionUpdateInput, TBEventReg_SpringIntoActionUncheckedUpdateInput>
  }


  /**
   * TBEventReg_SpringIntoAction delete
   */
  export type TBEventReg_SpringIntoActionDeleteArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SpringIntoAction
     */
    select?: TBEventReg_SpringIntoActionSelect | null
    /**
     * Filter which TBEventReg_SpringIntoAction to delete.
     */
    where: TBEventReg_SpringIntoActionWhereUniqueInput
  }


  /**
   * TBEventReg_SpringIntoAction deleteMany
   */
  export type TBEventReg_SpringIntoActionDeleteManyArgs = {
    /**
     * Filter which TBEventReg_SpringIntoActions to delete
     */
    where?: TBEventReg_SpringIntoActionWhereInput
  }


  /**
   * TBEventReg_SpringIntoAction without action
   */
  export type TBEventReg_SpringIntoActionArgs = {
    /**
     * Select specific fields to fetch from the TBEventReg_SpringIntoAction
     */
    select?: TBEventReg_SpringIntoActionSelect | null
  }



  /**
   * Model TBInvisibleIllness2019
   */


  export type AggregateTBInvisibleIllness2019 = {
    _count: TBInvisibleIllness2019CountAggregateOutputType | null
    _avg: TBInvisibleIllness2019AvgAggregateOutputType | null
    _sum: TBInvisibleIllness2019SumAggregateOutputType | null
    _min: TBInvisibleIllness2019MinAggregateOutputType | null
    _max: TBInvisibleIllness2019MaxAggregateOutputType | null
  }

  export type TBInvisibleIllness2019AvgAggregateOutputType = {
    IndexID: number | null
  }

  export type TBInvisibleIllness2019SumAggregateOutputType = {
    IndexID: number | null
  }

  export type TBInvisibleIllness2019MinAggregateOutputType = {
    IndexID: number | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    IfRCDMember: string | null
    RegDate: Date | null
    RegIP: string | null
  }

  export type TBInvisibleIllness2019MaxAggregateOutputType = {
    IndexID: number | null
    RegName: string | null
    RegEmail: string | null
    RegTel: string | null
    IfRCDMember: string | null
    RegDate: Date | null
    RegIP: string | null
  }

  export type TBInvisibleIllness2019CountAggregateOutputType = {
    IndexID: number
    RegName: number
    RegEmail: number
    RegTel: number
    IfRCDMember: number
    RegDate: number
    RegIP: number
    _all: number
  }


  export type TBInvisibleIllness2019AvgAggregateInputType = {
    IndexID?: true
  }

  export type TBInvisibleIllness2019SumAggregateInputType = {
    IndexID?: true
  }

  export type TBInvisibleIllness2019MinAggregateInputType = {
    IndexID?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    IfRCDMember?: true
    RegDate?: true
    RegIP?: true
  }

  export type TBInvisibleIllness2019MaxAggregateInputType = {
    IndexID?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    IfRCDMember?: true
    RegDate?: true
    RegIP?: true
  }

  export type TBInvisibleIllness2019CountAggregateInputType = {
    IndexID?: true
    RegName?: true
    RegEmail?: true
    RegTel?: true
    IfRCDMember?: true
    RegDate?: true
    RegIP?: true
    _all?: true
  }

  export type TBInvisibleIllness2019AggregateArgs = {
    /**
     * Filter which TBInvisibleIllness2019 to aggregate.
     */
    where?: TBInvisibleIllness2019WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBInvisibleIllness2019s to fetch.
     */
    orderBy?: Enumerable<TBInvisibleIllness2019OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TBInvisibleIllness2019WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBInvisibleIllness2019s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBInvisibleIllness2019s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TBInvisibleIllness2019s
    **/
    _count?: true | TBInvisibleIllness2019CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TBInvisibleIllness2019AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TBInvisibleIllness2019SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TBInvisibleIllness2019MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TBInvisibleIllness2019MaxAggregateInputType
  }

  export type GetTBInvisibleIllness2019AggregateType<T extends TBInvisibleIllness2019AggregateArgs> = {
        [P in keyof T & keyof AggregateTBInvisibleIllness2019]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTBInvisibleIllness2019[P]>
      : GetScalarType<T[P], AggregateTBInvisibleIllness2019[P]>
  }




  export type TBInvisibleIllness2019GroupByArgs = {
    where?: TBInvisibleIllness2019WhereInput
    orderBy?: Enumerable<TBInvisibleIllness2019OrderByWithAggregationInput>
    by: TBInvisibleIllness2019ScalarFieldEnum[]
    having?: TBInvisibleIllness2019ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TBInvisibleIllness2019CountAggregateInputType | true
    _avg?: TBInvisibleIllness2019AvgAggregateInputType
    _sum?: TBInvisibleIllness2019SumAggregateInputType
    _min?: TBInvisibleIllness2019MinAggregateInputType
    _max?: TBInvisibleIllness2019MaxAggregateInputType
  }


  export type TBInvisibleIllness2019GroupByOutputType = {
    IndexID: number
    RegName: string
    RegEmail: string
    RegTel: string
    IfRCDMember: string
    RegDate: Date
    RegIP: string
    _count: TBInvisibleIllness2019CountAggregateOutputType | null
    _avg: TBInvisibleIllness2019AvgAggregateOutputType | null
    _sum: TBInvisibleIllness2019SumAggregateOutputType | null
    _min: TBInvisibleIllness2019MinAggregateOutputType | null
    _max: TBInvisibleIllness2019MaxAggregateOutputType | null
  }

  type GetTBInvisibleIllness2019GroupByPayload<T extends TBInvisibleIllness2019GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TBInvisibleIllness2019GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TBInvisibleIllness2019GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TBInvisibleIllness2019GroupByOutputType[P]>
            : GetScalarType<T[P], TBInvisibleIllness2019GroupByOutputType[P]>
        }
      >
    >


  export type TBInvisibleIllness2019Select = {
    IndexID?: boolean
    RegName?: boolean
    RegEmail?: boolean
    RegTel?: boolean
    IfRCDMember?: boolean
    RegDate?: boolean
    RegIP?: boolean
  }


  export type TBInvisibleIllness2019GetPayload<S extends boolean | null | undefined | TBInvisibleIllness2019Args> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TBInvisibleIllness2019 :
    S extends undefined ? never :
    S extends { include: any } & (TBInvisibleIllness2019Args | TBInvisibleIllness2019FindManyArgs)
    ? TBInvisibleIllness2019 
    : S extends { select: any } & (TBInvisibleIllness2019Args | TBInvisibleIllness2019FindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TBInvisibleIllness2019 ? TBInvisibleIllness2019[P] : never
  } 
      : TBInvisibleIllness2019


  type TBInvisibleIllness2019CountArgs = 
    Omit<TBInvisibleIllness2019FindManyArgs, 'select' | 'include'> & {
      select?: TBInvisibleIllness2019CountAggregateInputType | true
    }

  export interface TBInvisibleIllness2019Delegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TBInvisibleIllness2019 that matches the filter.
     * @param {TBInvisibleIllness2019FindUniqueArgs} args - Arguments to find a TBInvisibleIllness2019
     * @example
     * // Get one TBInvisibleIllness2019
     * const tBInvisibleIllness2019 = await prisma.tBInvisibleIllness2019.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TBInvisibleIllness2019FindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TBInvisibleIllness2019FindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TBInvisibleIllness2019'> extends True ? Prisma__TBInvisibleIllness2019Client<TBInvisibleIllness2019GetPayload<T>> : Prisma__TBInvisibleIllness2019Client<TBInvisibleIllness2019GetPayload<T> | null, null>

    /**
     * Find one TBInvisibleIllness2019 that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TBInvisibleIllness2019FindUniqueOrThrowArgs} args - Arguments to find a TBInvisibleIllness2019
     * @example
     * // Get one TBInvisibleIllness2019
     * const tBInvisibleIllness2019 = await prisma.tBInvisibleIllness2019.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TBInvisibleIllness2019FindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TBInvisibleIllness2019FindUniqueOrThrowArgs>
    ): Prisma__TBInvisibleIllness2019Client<TBInvisibleIllness2019GetPayload<T>>

    /**
     * Find the first TBInvisibleIllness2019 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBInvisibleIllness2019FindFirstArgs} args - Arguments to find a TBInvisibleIllness2019
     * @example
     * // Get one TBInvisibleIllness2019
     * const tBInvisibleIllness2019 = await prisma.tBInvisibleIllness2019.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TBInvisibleIllness2019FindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TBInvisibleIllness2019FindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TBInvisibleIllness2019'> extends True ? Prisma__TBInvisibleIllness2019Client<TBInvisibleIllness2019GetPayload<T>> : Prisma__TBInvisibleIllness2019Client<TBInvisibleIllness2019GetPayload<T> | null, null>

    /**
     * Find the first TBInvisibleIllness2019 that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBInvisibleIllness2019FindFirstOrThrowArgs} args - Arguments to find a TBInvisibleIllness2019
     * @example
     * // Get one TBInvisibleIllness2019
     * const tBInvisibleIllness2019 = await prisma.tBInvisibleIllness2019.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TBInvisibleIllness2019FindFirstOrThrowArgs>(
      args?: SelectSubset<T, TBInvisibleIllness2019FindFirstOrThrowArgs>
    ): Prisma__TBInvisibleIllness2019Client<TBInvisibleIllness2019GetPayload<T>>

    /**
     * Find zero or more TBInvisibleIllness2019s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBInvisibleIllness2019FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TBInvisibleIllness2019s
     * const tBInvisibleIllness2019s = await prisma.tBInvisibleIllness2019.findMany()
     * 
     * // Get first 10 TBInvisibleIllness2019s
     * const tBInvisibleIllness2019s = await prisma.tBInvisibleIllness2019.findMany({ take: 10 })
     * 
     * // Only select the `IndexID`
     * const tBInvisibleIllness2019WithIndexIDOnly = await prisma.tBInvisibleIllness2019.findMany({ select: { IndexID: true } })
     * 
    **/
    findMany<T extends TBInvisibleIllness2019FindManyArgs>(
      args?: SelectSubset<T, TBInvisibleIllness2019FindManyArgs>
    ): Prisma.PrismaPromise<Array<TBInvisibleIllness2019GetPayload<T>>>

    /**
     * Create a TBInvisibleIllness2019.
     * @param {TBInvisibleIllness2019CreateArgs} args - Arguments to create a TBInvisibleIllness2019.
     * @example
     * // Create one TBInvisibleIllness2019
     * const TBInvisibleIllness2019 = await prisma.tBInvisibleIllness2019.create({
     *   data: {
     *     // ... data to create a TBInvisibleIllness2019
     *   }
     * })
     * 
    **/
    create<T extends TBInvisibleIllness2019CreateArgs>(
      args: SelectSubset<T, TBInvisibleIllness2019CreateArgs>
    ): Prisma__TBInvisibleIllness2019Client<TBInvisibleIllness2019GetPayload<T>>

    /**
     * Create many TBInvisibleIllness2019s.
     *     @param {TBInvisibleIllness2019CreateManyArgs} args - Arguments to create many TBInvisibleIllness2019s.
     *     @example
     *     // Create many TBInvisibleIllness2019s
     *     const tBInvisibleIllness2019 = await prisma.tBInvisibleIllness2019.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TBInvisibleIllness2019CreateManyArgs>(
      args?: SelectSubset<T, TBInvisibleIllness2019CreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TBInvisibleIllness2019.
     * @param {TBInvisibleIllness2019DeleteArgs} args - Arguments to delete one TBInvisibleIllness2019.
     * @example
     * // Delete one TBInvisibleIllness2019
     * const TBInvisibleIllness2019 = await prisma.tBInvisibleIllness2019.delete({
     *   where: {
     *     // ... filter to delete one TBInvisibleIllness2019
     *   }
     * })
     * 
    **/
    delete<T extends TBInvisibleIllness2019DeleteArgs>(
      args: SelectSubset<T, TBInvisibleIllness2019DeleteArgs>
    ): Prisma__TBInvisibleIllness2019Client<TBInvisibleIllness2019GetPayload<T>>

    /**
     * Update one TBInvisibleIllness2019.
     * @param {TBInvisibleIllness2019UpdateArgs} args - Arguments to update one TBInvisibleIllness2019.
     * @example
     * // Update one TBInvisibleIllness2019
     * const tBInvisibleIllness2019 = await prisma.tBInvisibleIllness2019.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TBInvisibleIllness2019UpdateArgs>(
      args: SelectSubset<T, TBInvisibleIllness2019UpdateArgs>
    ): Prisma__TBInvisibleIllness2019Client<TBInvisibleIllness2019GetPayload<T>>

    /**
     * Delete zero or more TBInvisibleIllness2019s.
     * @param {TBInvisibleIllness2019DeleteManyArgs} args - Arguments to filter TBInvisibleIllness2019s to delete.
     * @example
     * // Delete a few TBInvisibleIllness2019s
     * const { count } = await prisma.tBInvisibleIllness2019.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TBInvisibleIllness2019DeleteManyArgs>(
      args?: SelectSubset<T, TBInvisibleIllness2019DeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TBInvisibleIllness2019s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBInvisibleIllness2019UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TBInvisibleIllness2019s
     * const tBInvisibleIllness2019 = await prisma.tBInvisibleIllness2019.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TBInvisibleIllness2019UpdateManyArgs>(
      args: SelectSubset<T, TBInvisibleIllness2019UpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TBInvisibleIllness2019.
     * @param {TBInvisibleIllness2019UpsertArgs} args - Arguments to update or create a TBInvisibleIllness2019.
     * @example
     * // Update or create a TBInvisibleIllness2019
     * const tBInvisibleIllness2019 = await prisma.tBInvisibleIllness2019.upsert({
     *   create: {
     *     // ... data to create a TBInvisibleIllness2019
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TBInvisibleIllness2019 we want to update
     *   }
     * })
    **/
    upsert<T extends TBInvisibleIllness2019UpsertArgs>(
      args: SelectSubset<T, TBInvisibleIllness2019UpsertArgs>
    ): Prisma__TBInvisibleIllness2019Client<TBInvisibleIllness2019GetPayload<T>>

    /**
     * Count the number of TBInvisibleIllness2019s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBInvisibleIllness2019CountArgs} args - Arguments to filter TBInvisibleIllness2019s to count.
     * @example
     * // Count the number of TBInvisibleIllness2019s
     * const count = await prisma.tBInvisibleIllness2019.count({
     *   where: {
     *     // ... the filter for the TBInvisibleIllness2019s we want to count
     *   }
     * })
    **/
    count<T extends TBInvisibleIllness2019CountArgs>(
      args?: Subset<T, TBInvisibleIllness2019CountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TBInvisibleIllness2019CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TBInvisibleIllness2019.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBInvisibleIllness2019AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TBInvisibleIllness2019AggregateArgs>(args: Subset<T, TBInvisibleIllness2019AggregateArgs>): Prisma.PrismaPromise<GetTBInvisibleIllness2019AggregateType<T>>

    /**
     * Group by TBInvisibleIllness2019.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TBInvisibleIllness2019GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TBInvisibleIllness2019GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TBInvisibleIllness2019GroupByArgs['orderBy'] }
        : { orderBy?: TBInvisibleIllness2019GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TBInvisibleIllness2019GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTBInvisibleIllness2019GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TBInvisibleIllness2019.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TBInvisibleIllness2019Client<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TBInvisibleIllness2019 base type for findUnique actions
   */
  export type TBInvisibleIllness2019FindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TBInvisibleIllness2019
     */
    select?: TBInvisibleIllness2019Select | null
    /**
     * Filter, which TBInvisibleIllness2019 to fetch.
     */
    where: TBInvisibleIllness2019WhereUniqueInput
  }

  /**
   * TBInvisibleIllness2019 findUnique
   */
  export interface TBInvisibleIllness2019FindUniqueArgs extends TBInvisibleIllness2019FindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBInvisibleIllness2019 findUniqueOrThrow
   */
  export type TBInvisibleIllness2019FindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBInvisibleIllness2019
     */
    select?: TBInvisibleIllness2019Select | null
    /**
     * Filter, which TBInvisibleIllness2019 to fetch.
     */
    where: TBInvisibleIllness2019WhereUniqueInput
  }


  /**
   * TBInvisibleIllness2019 base type for findFirst actions
   */
  export type TBInvisibleIllness2019FindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TBInvisibleIllness2019
     */
    select?: TBInvisibleIllness2019Select | null
    /**
     * Filter, which TBInvisibleIllness2019 to fetch.
     */
    where?: TBInvisibleIllness2019WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBInvisibleIllness2019s to fetch.
     */
    orderBy?: Enumerable<TBInvisibleIllness2019OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBInvisibleIllness2019s.
     */
    cursor?: TBInvisibleIllness2019WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBInvisibleIllness2019s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBInvisibleIllness2019s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBInvisibleIllness2019s.
     */
    distinct?: Enumerable<TBInvisibleIllness2019ScalarFieldEnum>
  }

  /**
   * TBInvisibleIllness2019 findFirst
   */
  export interface TBInvisibleIllness2019FindFirstArgs extends TBInvisibleIllness2019FindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TBInvisibleIllness2019 findFirstOrThrow
   */
  export type TBInvisibleIllness2019FindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TBInvisibleIllness2019
     */
    select?: TBInvisibleIllness2019Select | null
    /**
     * Filter, which TBInvisibleIllness2019 to fetch.
     */
    where?: TBInvisibleIllness2019WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBInvisibleIllness2019s to fetch.
     */
    orderBy?: Enumerable<TBInvisibleIllness2019OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TBInvisibleIllness2019s.
     */
    cursor?: TBInvisibleIllness2019WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBInvisibleIllness2019s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBInvisibleIllness2019s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TBInvisibleIllness2019s.
     */
    distinct?: Enumerable<TBInvisibleIllness2019ScalarFieldEnum>
  }


  /**
   * TBInvisibleIllness2019 findMany
   */
  export type TBInvisibleIllness2019FindManyArgs = {
    /**
     * Select specific fields to fetch from the TBInvisibleIllness2019
     */
    select?: TBInvisibleIllness2019Select | null
    /**
     * Filter, which TBInvisibleIllness2019s to fetch.
     */
    where?: TBInvisibleIllness2019WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TBInvisibleIllness2019s to fetch.
     */
    orderBy?: Enumerable<TBInvisibleIllness2019OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TBInvisibleIllness2019s.
     */
    cursor?: TBInvisibleIllness2019WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TBInvisibleIllness2019s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TBInvisibleIllness2019s.
     */
    skip?: number
    distinct?: Enumerable<TBInvisibleIllness2019ScalarFieldEnum>
  }


  /**
   * TBInvisibleIllness2019 create
   */
  export type TBInvisibleIllness2019CreateArgs = {
    /**
     * Select specific fields to fetch from the TBInvisibleIllness2019
     */
    select?: TBInvisibleIllness2019Select | null
    /**
     * The data needed to create a TBInvisibleIllness2019.
     */
    data: XOR<TBInvisibleIllness2019CreateInput, TBInvisibleIllness2019UncheckedCreateInput>
  }


  /**
   * TBInvisibleIllness2019 createMany
   */
  export type TBInvisibleIllness2019CreateManyArgs = {
    /**
     * The data used to create many TBInvisibleIllness2019s.
     */
    data: Enumerable<TBInvisibleIllness2019CreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TBInvisibleIllness2019 update
   */
  export type TBInvisibleIllness2019UpdateArgs = {
    /**
     * Select specific fields to fetch from the TBInvisibleIllness2019
     */
    select?: TBInvisibleIllness2019Select | null
    /**
     * The data needed to update a TBInvisibleIllness2019.
     */
    data: XOR<TBInvisibleIllness2019UpdateInput, TBInvisibleIllness2019UncheckedUpdateInput>
    /**
     * Choose, which TBInvisibleIllness2019 to update.
     */
    where: TBInvisibleIllness2019WhereUniqueInput
  }


  /**
   * TBInvisibleIllness2019 updateMany
   */
  export type TBInvisibleIllness2019UpdateManyArgs = {
    /**
     * The data used to update TBInvisibleIllness2019s.
     */
    data: XOR<TBInvisibleIllness2019UpdateManyMutationInput, TBInvisibleIllness2019UncheckedUpdateManyInput>
    /**
     * Filter which TBInvisibleIllness2019s to update
     */
    where?: TBInvisibleIllness2019WhereInput
  }


  /**
   * TBInvisibleIllness2019 upsert
   */
  export type TBInvisibleIllness2019UpsertArgs = {
    /**
     * Select specific fields to fetch from the TBInvisibleIllness2019
     */
    select?: TBInvisibleIllness2019Select | null
    /**
     * The filter to search for the TBInvisibleIllness2019 to update in case it exists.
     */
    where: TBInvisibleIllness2019WhereUniqueInput
    /**
     * In case the TBInvisibleIllness2019 found by the `where` argument doesn't exist, create a new TBInvisibleIllness2019 with this data.
     */
    create: XOR<TBInvisibleIllness2019CreateInput, TBInvisibleIllness2019UncheckedCreateInput>
    /**
     * In case the TBInvisibleIllness2019 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TBInvisibleIllness2019UpdateInput, TBInvisibleIllness2019UncheckedUpdateInput>
  }


  /**
   * TBInvisibleIllness2019 delete
   */
  export type TBInvisibleIllness2019DeleteArgs = {
    /**
     * Select specific fields to fetch from the TBInvisibleIllness2019
     */
    select?: TBInvisibleIllness2019Select | null
    /**
     * Filter which TBInvisibleIllness2019 to delete.
     */
    where: TBInvisibleIllness2019WhereUniqueInput
  }


  /**
   * TBInvisibleIllness2019 deleteMany
   */
  export type TBInvisibleIllness2019DeleteManyArgs = {
    /**
     * Filter which TBInvisibleIllness2019s to delete
     */
    where?: TBInvisibleIllness2019WhereInput
  }


  /**
   * TBInvisibleIllness2019 without action
   */
  export type TBInvisibleIllness2019Args = {
    /**
     * Select specific fields to fetch from the TBInvisibleIllness2019
     */
    select?: TBInvisibleIllness2019Select | null
  }



  /**
   * Model TB_2017Gala_Karaoka
   */


  export type AggregateTB_2017Gala_Karaoka = {
    _count: TB_2017Gala_KaraokaCountAggregateOutputType | null
    _avg: TB_2017Gala_KaraokaAvgAggregateOutputType | null
    _sum: TB_2017Gala_KaraokaSumAggregateOutputType | null
    _min: TB_2017Gala_KaraokaMinAggregateOutputType | null
    _max: TB_2017Gala_KaraokaMaxAggregateOutputType | null
  }

  export type TB_2017Gala_KaraokaAvgAggregateOutputType = {
    ID: number | null
  }

  export type TB_2017Gala_KaraokaSumAggregateOutputType = {
    ID: number | null
  }

  export type TB_2017Gala_KaraokaMinAggregateOutputType = {
    ID: number | null
    NominatorName: string | null
    NominatorTelEmail: string | null
    NomineeName: string | null
    NomineeTelEmail: string | null
    KaraokeName: string | null
    BringCD: string | null
    RegDateTime: Date | null
  }

  export type TB_2017Gala_KaraokaMaxAggregateOutputType = {
    ID: number | null
    NominatorName: string | null
    NominatorTelEmail: string | null
    NomineeName: string | null
    NomineeTelEmail: string | null
    KaraokeName: string | null
    BringCD: string | null
    RegDateTime: Date | null
  }

  export type TB_2017Gala_KaraokaCountAggregateOutputType = {
    ID: number
    NominatorName: number
    NominatorTelEmail: number
    NomineeName: number
    NomineeTelEmail: number
    KaraokeName: number
    BringCD: number
    RegDateTime: number
    _all: number
  }


  export type TB_2017Gala_KaraokaAvgAggregateInputType = {
    ID?: true
  }

  export type TB_2017Gala_KaraokaSumAggregateInputType = {
    ID?: true
  }

  export type TB_2017Gala_KaraokaMinAggregateInputType = {
    ID?: true
    NominatorName?: true
    NominatorTelEmail?: true
    NomineeName?: true
    NomineeTelEmail?: true
    KaraokeName?: true
    BringCD?: true
    RegDateTime?: true
  }

  export type TB_2017Gala_KaraokaMaxAggregateInputType = {
    ID?: true
    NominatorName?: true
    NominatorTelEmail?: true
    NomineeName?: true
    NomineeTelEmail?: true
    KaraokeName?: true
    BringCD?: true
    RegDateTime?: true
  }

  export type TB_2017Gala_KaraokaCountAggregateInputType = {
    ID?: true
    NominatorName?: true
    NominatorTelEmail?: true
    NomineeName?: true
    NomineeTelEmail?: true
    KaraokeName?: true
    BringCD?: true
    RegDateTime?: true
    _all?: true
  }

  export type TB_2017Gala_KaraokaAggregateArgs = {
    /**
     * Filter which TB_2017Gala_Karaoka to aggregate.
     */
    where?: TB_2017Gala_KaraokaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TB_2017Gala_Karaokas to fetch.
     */
    orderBy?: Enumerable<TB_2017Gala_KaraokaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TB_2017Gala_KaraokaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TB_2017Gala_Karaokas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TB_2017Gala_Karaokas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TB_2017Gala_Karaokas
    **/
    _count?: true | TB_2017Gala_KaraokaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TB_2017Gala_KaraokaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TB_2017Gala_KaraokaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TB_2017Gala_KaraokaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TB_2017Gala_KaraokaMaxAggregateInputType
  }

  export type GetTB_2017Gala_KaraokaAggregateType<T extends TB_2017Gala_KaraokaAggregateArgs> = {
        [P in keyof T & keyof AggregateTB_2017Gala_Karaoka]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTB_2017Gala_Karaoka[P]>
      : GetScalarType<T[P], AggregateTB_2017Gala_Karaoka[P]>
  }




  export type TB_2017Gala_KaraokaGroupByArgs = {
    where?: TB_2017Gala_KaraokaWhereInput
    orderBy?: Enumerable<TB_2017Gala_KaraokaOrderByWithAggregationInput>
    by: TB_2017Gala_KaraokaScalarFieldEnum[]
    having?: TB_2017Gala_KaraokaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TB_2017Gala_KaraokaCountAggregateInputType | true
    _avg?: TB_2017Gala_KaraokaAvgAggregateInputType
    _sum?: TB_2017Gala_KaraokaSumAggregateInputType
    _min?: TB_2017Gala_KaraokaMinAggregateInputType
    _max?: TB_2017Gala_KaraokaMaxAggregateInputType
  }


  export type TB_2017Gala_KaraokaGroupByOutputType = {
    ID: number
    NominatorName: string
    NominatorTelEmail: string
    NomineeName: string
    NomineeTelEmail: string
    KaraokeName: string
    BringCD: string
    RegDateTime: Date
    _count: TB_2017Gala_KaraokaCountAggregateOutputType | null
    _avg: TB_2017Gala_KaraokaAvgAggregateOutputType | null
    _sum: TB_2017Gala_KaraokaSumAggregateOutputType | null
    _min: TB_2017Gala_KaraokaMinAggregateOutputType | null
    _max: TB_2017Gala_KaraokaMaxAggregateOutputType | null
  }

  type GetTB_2017Gala_KaraokaGroupByPayload<T extends TB_2017Gala_KaraokaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TB_2017Gala_KaraokaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TB_2017Gala_KaraokaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TB_2017Gala_KaraokaGroupByOutputType[P]>
            : GetScalarType<T[P], TB_2017Gala_KaraokaGroupByOutputType[P]>
        }
      >
    >


  export type TB_2017Gala_KaraokaSelect = {
    ID?: boolean
    NominatorName?: boolean
    NominatorTelEmail?: boolean
    NomineeName?: boolean
    NomineeTelEmail?: boolean
    KaraokeName?: boolean
    BringCD?: boolean
    RegDateTime?: boolean
  }


  export type TB_2017Gala_KaraokaGetPayload<S extends boolean | null | undefined | TB_2017Gala_KaraokaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TB_2017Gala_Karaoka :
    S extends undefined ? never :
    S extends { include: any } & (TB_2017Gala_KaraokaArgs | TB_2017Gala_KaraokaFindManyArgs)
    ? TB_2017Gala_Karaoka 
    : S extends { select: any } & (TB_2017Gala_KaraokaArgs | TB_2017Gala_KaraokaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TB_2017Gala_Karaoka ? TB_2017Gala_Karaoka[P] : never
  } 
      : TB_2017Gala_Karaoka


  type TB_2017Gala_KaraokaCountArgs = 
    Omit<TB_2017Gala_KaraokaFindManyArgs, 'select' | 'include'> & {
      select?: TB_2017Gala_KaraokaCountAggregateInputType | true
    }

  export interface TB_2017Gala_KaraokaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TB_2017Gala_Karaoka that matches the filter.
     * @param {TB_2017Gala_KaraokaFindUniqueArgs} args - Arguments to find a TB_2017Gala_Karaoka
     * @example
     * // Get one TB_2017Gala_Karaoka
     * const tB_2017Gala_Karaoka = await prisma.tB_2017Gala_Karaoka.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TB_2017Gala_KaraokaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TB_2017Gala_KaraokaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TB_2017Gala_Karaoka'> extends True ? Prisma__TB_2017Gala_KaraokaClient<TB_2017Gala_KaraokaGetPayload<T>> : Prisma__TB_2017Gala_KaraokaClient<TB_2017Gala_KaraokaGetPayload<T> | null, null>

    /**
     * Find one TB_2017Gala_Karaoka that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TB_2017Gala_KaraokaFindUniqueOrThrowArgs} args - Arguments to find a TB_2017Gala_Karaoka
     * @example
     * // Get one TB_2017Gala_Karaoka
     * const tB_2017Gala_Karaoka = await prisma.tB_2017Gala_Karaoka.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TB_2017Gala_KaraokaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TB_2017Gala_KaraokaFindUniqueOrThrowArgs>
    ): Prisma__TB_2017Gala_KaraokaClient<TB_2017Gala_KaraokaGetPayload<T>>

    /**
     * Find the first TB_2017Gala_Karaoka that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TB_2017Gala_KaraokaFindFirstArgs} args - Arguments to find a TB_2017Gala_Karaoka
     * @example
     * // Get one TB_2017Gala_Karaoka
     * const tB_2017Gala_Karaoka = await prisma.tB_2017Gala_Karaoka.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TB_2017Gala_KaraokaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TB_2017Gala_KaraokaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TB_2017Gala_Karaoka'> extends True ? Prisma__TB_2017Gala_KaraokaClient<TB_2017Gala_KaraokaGetPayload<T>> : Prisma__TB_2017Gala_KaraokaClient<TB_2017Gala_KaraokaGetPayload<T> | null, null>

    /**
     * Find the first TB_2017Gala_Karaoka that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TB_2017Gala_KaraokaFindFirstOrThrowArgs} args - Arguments to find a TB_2017Gala_Karaoka
     * @example
     * // Get one TB_2017Gala_Karaoka
     * const tB_2017Gala_Karaoka = await prisma.tB_2017Gala_Karaoka.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TB_2017Gala_KaraokaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TB_2017Gala_KaraokaFindFirstOrThrowArgs>
    ): Prisma__TB_2017Gala_KaraokaClient<TB_2017Gala_KaraokaGetPayload<T>>

    /**
     * Find zero or more TB_2017Gala_Karaokas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TB_2017Gala_KaraokaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TB_2017Gala_Karaokas
     * const tB_2017Gala_Karaokas = await prisma.tB_2017Gala_Karaoka.findMany()
     * 
     * // Get first 10 TB_2017Gala_Karaokas
     * const tB_2017Gala_Karaokas = await prisma.tB_2017Gala_Karaoka.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tB_2017Gala_KaraokaWithIDOnly = await prisma.tB_2017Gala_Karaoka.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends TB_2017Gala_KaraokaFindManyArgs>(
      args?: SelectSubset<T, TB_2017Gala_KaraokaFindManyArgs>
    ): Prisma.PrismaPromise<Array<TB_2017Gala_KaraokaGetPayload<T>>>

    /**
     * Create a TB_2017Gala_Karaoka.
     * @param {TB_2017Gala_KaraokaCreateArgs} args - Arguments to create a TB_2017Gala_Karaoka.
     * @example
     * // Create one TB_2017Gala_Karaoka
     * const TB_2017Gala_Karaoka = await prisma.tB_2017Gala_Karaoka.create({
     *   data: {
     *     // ... data to create a TB_2017Gala_Karaoka
     *   }
     * })
     * 
    **/
    create<T extends TB_2017Gala_KaraokaCreateArgs>(
      args: SelectSubset<T, TB_2017Gala_KaraokaCreateArgs>
    ): Prisma__TB_2017Gala_KaraokaClient<TB_2017Gala_KaraokaGetPayload<T>>

    /**
     * Create many TB_2017Gala_Karaokas.
     *     @param {TB_2017Gala_KaraokaCreateManyArgs} args - Arguments to create many TB_2017Gala_Karaokas.
     *     @example
     *     // Create many TB_2017Gala_Karaokas
     *     const tB_2017Gala_Karaoka = await prisma.tB_2017Gala_Karaoka.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TB_2017Gala_KaraokaCreateManyArgs>(
      args?: SelectSubset<T, TB_2017Gala_KaraokaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TB_2017Gala_Karaoka.
     * @param {TB_2017Gala_KaraokaDeleteArgs} args - Arguments to delete one TB_2017Gala_Karaoka.
     * @example
     * // Delete one TB_2017Gala_Karaoka
     * const TB_2017Gala_Karaoka = await prisma.tB_2017Gala_Karaoka.delete({
     *   where: {
     *     // ... filter to delete one TB_2017Gala_Karaoka
     *   }
     * })
     * 
    **/
    delete<T extends TB_2017Gala_KaraokaDeleteArgs>(
      args: SelectSubset<T, TB_2017Gala_KaraokaDeleteArgs>
    ): Prisma__TB_2017Gala_KaraokaClient<TB_2017Gala_KaraokaGetPayload<T>>

    /**
     * Update one TB_2017Gala_Karaoka.
     * @param {TB_2017Gala_KaraokaUpdateArgs} args - Arguments to update one TB_2017Gala_Karaoka.
     * @example
     * // Update one TB_2017Gala_Karaoka
     * const tB_2017Gala_Karaoka = await prisma.tB_2017Gala_Karaoka.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TB_2017Gala_KaraokaUpdateArgs>(
      args: SelectSubset<T, TB_2017Gala_KaraokaUpdateArgs>
    ): Prisma__TB_2017Gala_KaraokaClient<TB_2017Gala_KaraokaGetPayload<T>>

    /**
     * Delete zero or more TB_2017Gala_Karaokas.
     * @param {TB_2017Gala_KaraokaDeleteManyArgs} args - Arguments to filter TB_2017Gala_Karaokas to delete.
     * @example
     * // Delete a few TB_2017Gala_Karaokas
     * const { count } = await prisma.tB_2017Gala_Karaoka.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TB_2017Gala_KaraokaDeleteManyArgs>(
      args?: SelectSubset<T, TB_2017Gala_KaraokaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TB_2017Gala_Karaokas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TB_2017Gala_KaraokaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TB_2017Gala_Karaokas
     * const tB_2017Gala_Karaoka = await prisma.tB_2017Gala_Karaoka.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TB_2017Gala_KaraokaUpdateManyArgs>(
      args: SelectSubset<T, TB_2017Gala_KaraokaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TB_2017Gala_Karaoka.
     * @param {TB_2017Gala_KaraokaUpsertArgs} args - Arguments to update or create a TB_2017Gala_Karaoka.
     * @example
     * // Update or create a TB_2017Gala_Karaoka
     * const tB_2017Gala_Karaoka = await prisma.tB_2017Gala_Karaoka.upsert({
     *   create: {
     *     // ... data to create a TB_2017Gala_Karaoka
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TB_2017Gala_Karaoka we want to update
     *   }
     * })
    **/
    upsert<T extends TB_2017Gala_KaraokaUpsertArgs>(
      args: SelectSubset<T, TB_2017Gala_KaraokaUpsertArgs>
    ): Prisma__TB_2017Gala_KaraokaClient<TB_2017Gala_KaraokaGetPayload<T>>

    /**
     * Count the number of TB_2017Gala_Karaokas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TB_2017Gala_KaraokaCountArgs} args - Arguments to filter TB_2017Gala_Karaokas to count.
     * @example
     * // Count the number of TB_2017Gala_Karaokas
     * const count = await prisma.tB_2017Gala_Karaoka.count({
     *   where: {
     *     // ... the filter for the TB_2017Gala_Karaokas we want to count
     *   }
     * })
    **/
    count<T extends TB_2017Gala_KaraokaCountArgs>(
      args?: Subset<T, TB_2017Gala_KaraokaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TB_2017Gala_KaraokaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TB_2017Gala_Karaoka.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TB_2017Gala_KaraokaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TB_2017Gala_KaraokaAggregateArgs>(args: Subset<T, TB_2017Gala_KaraokaAggregateArgs>): Prisma.PrismaPromise<GetTB_2017Gala_KaraokaAggregateType<T>>

    /**
     * Group by TB_2017Gala_Karaoka.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TB_2017Gala_KaraokaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TB_2017Gala_KaraokaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TB_2017Gala_KaraokaGroupByArgs['orderBy'] }
        : { orderBy?: TB_2017Gala_KaraokaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TB_2017Gala_KaraokaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTB_2017Gala_KaraokaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TB_2017Gala_Karaoka.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TB_2017Gala_KaraokaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TB_2017Gala_Karaoka base type for findUnique actions
   */
  export type TB_2017Gala_KaraokaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TB_2017Gala_Karaoka
     */
    select?: TB_2017Gala_KaraokaSelect | null
    /**
     * Filter, which TB_2017Gala_Karaoka to fetch.
     */
    where: TB_2017Gala_KaraokaWhereUniqueInput
  }

  /**
   * TB_2017Gala_Karaoka findUnique
   */
  export interface TB_2017Gala_KaraokaFindUniqueArgs extends TB_2017Gala_KaraokaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TB_2017Gala_Karaoka findUniqueOrThrow
   */
  export type TB_2017Gala_KaraokaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TB_2017Gala_Karaoka
     */
    select?: TB_2017Gala_KaraokaSelect | null
    /**
     * Filter, which TB_2017Gala_Karaoka to fetch.
     */
    where: TB_2017Gala_KaraokaWhereUniqueInput
  }


  /**
   * TB_2017Gala_Karaoka base type for findFirst actions
   */
  export type TB_2017Gala_KaraokaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TB_2017Gala_Karaoka
     */
    select?: TB_2017Gala_KaraokaSelect | null
    /**
     * Filter, which TB_2017Gala_Karaoka to fetch.
     */
    where?: TB_2017Gala_KaraokaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TB_2017Gala_Karaokas to fetch.
     */
    orderBy?: Enumerable<TB_2017Gala_KaraokaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TB_2017Gala_Karaokas.
     */
    cursor?: TB_2017Gala_KaraokaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TB_2017Gala_Karaokas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TB_2017Gala_Karaokas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TB_2017Gala_Karaokas.
     */
    distinct?: Enumerable<TB_2017Gala_KaraokaScalarFieldEnum>
  }

  /**
   * TB_2017Gala_Karaoka findFirst
   */
  export interface TB_2017Gala_KaraokaFindFirstArgs extends TB_2017Gala_KaraokaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TB_2017Gala_Karaoka findFirstOrThrow
   */
  export type TB_2017Gala_KaraokaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TB_2017Gala_Karaoka
     */
    select?: TB_2017Gala_KaraokaSelect | null
    /**
     * Filter, which TB_2017Gala_Karaoka to fetch.
     */
    where?: TB_2017Gala_KaraokaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TB_2017Gala_Karaokas to fetch.
     */
    orderBy?: Enumerable<TB_2017Gala_KaraokaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TB_2017Gala_Karaokas.
     */
    cursor?: TB_2017Gala_KaraokaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TB_2017Gala_Karaokas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TB_2017Gala_Karaokas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TB_2017Gala_Karaokas.
     */
    distinct?: Enumerable<TB_2017Gala_KaraokaScalarFieldEnum>
  }


  /**
   * TB_2017Gala_Karaoka findMany
   */
  export type TB_2017Gala_KaraokaFindManyArgs = {
    /**
     * Select specific fields to fetch from the TB_2017Gala_Karaoka
     */
    select?: TB_2017Gala_KaraokaSelect | null
    /**
     * Filter, which TB_2017Gala_Karaokas to fetch.
     */
    where?: TB_2017Gala_KaraokaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TB_2017Gala_Karaokas to fetch.
     */
    orderBy?: Enumerable<TB_2017Gala_KaraokaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TB_2017Gala_Karaokas.
     */
    cursor?: TB_2017Gala_KaraokaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TB_2017Gala_Karaokas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TB_2017Gala_Karaokas.
     */
    skip?: number
    distinct?: Enumerable<TB_2017Gala_KaraokaScalarFieldEnum>
  }


  /**
   * TB_2017Gala_Karaoka create
   */
  export type TB_2017Gala_KaraokaCreateArgs = {
    /**
     * Select specific fields to fetch from the TB_2017Gala_Karaoka
     */
    select?: TB_2017Gala_KaraokaSelect | null
    /**
     * The data needed to create a TB_2017Gala_Karaoka.
     */
    data: XOR<TB_2017Gala_KaraokaCreateInput, TB_2017Gala_KaraokaUncheckedCreateInput>
  }


  /**
   * TB_2017Gala_Karaoka createMany
   */
  export type TB_2017Gala_KaraokaCreateManyArgs = {
    /**
     * The data used to create many TB_2017Gala_Karaokas.
     */
    data: Enumerable<TB_2017Gala_KaraokaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TB_2017Gala_Karaoka update
   */
  export type TB_2017Gala_KaraokaUpdateArgs = {
    /**
     * Select specific fields to fetch from the TB_2017Gala_Karaoka
     */
    select?: TB_2017Gala_KaraokaSelect | null
    /**
     * The data needed to update a TB_2017Gala_Karaoka.
     */
    data: XOR<TB_2017Gala_KaraokaUpdateInput, TB_2017Gala_KaraokaUncheckedUpdateInput>
    /**
     * Choose, which TB_2017Gala_Karaoka to update.
     */
    where: TB_2017Gala_KaraokaWhereUniqueInput
  }


  /**
   * TB_2017Gala_Karaoka updateMany
   */
  export type TB_2017Gala_KaraokaUpdateManyArgs = {
    /**
     * The data used to update TB_2017Gala_Karaokas.
     */
    data: XOR<TB_2017Gala_KaraokaUpdateManyMutationInput, TB_2017Gala_KaraokaUncheckedUpdateManyInput>
    /**
     * Filter which TB_2017Gala_Karaokas to update
     */
    where?: TB_2017Gala_KaraokaWhereInput
  }


  /**
   * TB_2017Gala_Karaoka upsert
   */
  export type TB_2017Gala_KaraokaUpsertArgs = {
    /**
     * Select specific fields to fetch from the TB_2017Gala_Karaoka
     */
    select?: TB_2017Gala_KaraokaSelect | null
    /**
     * The filter to search for the TB_2017Gala_Karaoka to update in case it exists.
     */
    where: TB_2017Gala_KaraokaWhereUniqueInput
    /**
     * In case the TB_2017Gala_Karaoka found by the `where` argument doesn't exist, create a new TB_2017Gala_Karaoka with this data.
     */
    create: XOR<TB_2017Gala_KaraokaCreateInput, TB_2017Gala_KaraokaUncheckedCreateInput>
    /**
     * In case the TB_2017Gala_Karaoka was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TB_2017Gala_KaraokaUpdateInput, TB_2017Gala_KaraokaUncheckedUpdateInput>
  }


  /**
   * TB_2017Gala_Karaoka delete
   */
  export type TB_2017Gala_KaraokaDeleteArgs = {
    /**
     * Select specific fields to fetch from the TB_2017Gala_Karaoka
     */
    select?: TB_2017Gala_KaraokaSelect | null
    /**
     * Filter which TB_2017Gala_Karaoka to delete.
     */
    where: TB_2017Gala_KaraokaWhereUniqueInput
  }


  /**
   * TB_2017Gala_Karaoka deleteMany
   */
  export type TB_2017Gala_KaraokaDeleteManyArgs = {
    /**
     * Filter which TB_2017Gala_Karaokas to delete
     */
    where?: TB_2017Gala_KaraokaWhereInput
  }


  /**
   * TB_2017Gala_Karaoka without action
   */
  export type TB_2017Gala_KaraokaArgs = {
    /**
     * Select specific fields to fetch from the TB_2017Gala_Karaoka
     */
    select?: TB_2017Gala_KaraokaSelect | null
  }



  /**
   * Model Tbl_barrage_ILAcrossCanadaDay2023
   */


  export type AggregateTbl_barrage_ILAcrossCanadaDay2023 = {
    _count: Tbl_barrage_ILAcrossCanadaDay2023CountAggregateOutputType | null
    _avg: Tbl_barrage_ILAcrossCanadaDay2023AvgAggregateOutputType | null
    _sum: Tbl_barrage_ILAcrossCanadaDay2023SumAggregateOutputType | null
    _min: Tbl_barrage_ILAcrossCanadaDay2023MinAggregateOutputType | null
    _max: Tbl_barrage_ILAcrossCanadaDay2023MaxAggregateOutputType | null
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023AvgAggregateOutputType = {
    barrage_id: number | null
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023SumAggregateOutputType = {
    barrage_id: number | null
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023MinAggregateOutputType = {
    barrage_id: number | null
    barrage_content: string | null
    createdAt: Date | null
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023MaxAggregateOutputType = {
    barrage_id: number | null
    barrage_content: string | null
    createdAt: Date | null
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023CountAggregateOutputType = {
    barrage_id: number
    barrage_content: number
    createdAt: number
    _all: number
  }


  export type Tbl_barrage_ILAcrossCanadaDay2023AvgAggregateInputType = {
    barrage_id?: true
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023SumAggregateInputType = {
    barrage_id?: true
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023MinAggregateInputType = {
    barrage_id?: true
    barrage_content?: true
    createdAt?: true
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023MaxAggregateInputType = {
    barrage_id?: true
    barrage_content?: true
    createdAt?: true
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023CountAggregateInputType = {
    barrage_id?: true
    barrage_content?: true
    createdAt?: true
    _all?: true
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023AggregateArgs = {
    /**
     * Filter which Tbl_barrage_ILAcrossCanadaDay2023 to aggregate.
     */
    where?: Tbl_barrage_ILAcrossCanadaDay2023WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tbl_barrage_ILAcrossCanadaDay2023s to fetch.
     */
    orderBy?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tbl_barrage_ILAcrossCanadaDay2023WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tbl_barrage_ILAcrossCanadaDay2023s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tbl_barrage_ILAcrossCanadaDay2023s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tbl_barrage_ILAcrossCanadaDay2023s
    **/
    _count?: true | Tbl_barrage_ILAcrossCanadaDay2023CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tbl_barrage_ILAcrossCanadaDay2023AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tbl_barrage_ILAcrossCanadaDay2023SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tbl_barrage_ILAcrossCanadaDay2023MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tbl_barrage_ILAcrossCanadaDay2023MaxAggregateInputType
  }

  export type GetTbl_barrage_ILAcrossCanadaDay2023AggregateType<T extends Tbl_barrage_ILAcrossCanadaDay2023AggregateArgs> = {
        [P in keyof T & keyof AggregateTbl_barrage_ILAcrossCanadaDay2023]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTbl_barrage_ILAcrossCanadaDay2023[P]>
      : GetScalarType<T[P], AggregateTbl_barrage_ILAcrossCanadaDay2023[P]>
  }




  export type Tbl_barrage_ILAcrossCanadaDay2023GroupByArgs = {
    where?: Tbl_barrage_ILAcrossCanadaDay2023WhereInput
    orderBy?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023OrderByWithAggregationInput>
    by: Tbl_barrage_ILAcrossCanadaDay2023ScalarFieldEnum[]
    having?: Tbl_barrage_ILAcrossCanadaDay2023ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tbl_barrage_ILAcrossCanadaDay2023CountAggregateInputType | true
    _avg?: Tbl_barrage_ILAcrossCanadaDay2023AvgAggregateInputType
    _sum?: Tbl_barrage_ILAcrossCanadaDay2023SumAggregateInputType
    _min?: Tbl_barrage_ILAcrossCanadaDay2023MinAggregateInputType
    _max?: Tbl_barrage_ILAcrossCanadaDay2023MaxAggregateInputType
  }


  export type Tbl_barrage_ILAcrossCanadaDay2023GroupByOutputType = {
    barrage_id: number
    barrage_content: string
    createdAt: Date
    _count: Tbl_barrage_ILAcrossCanadaDay2023CountAggregateOutputType | null
    _avg: Tbl_barrage_ILAcrossCanadaDay2023AvgAggregateOutputType | null
    _sum: Tbl_barrage_ILAcrossCanadaDay2023SumAggregateOutputType | null
    _min: Tbl_barrage_ILAcrossCanadaDay2023MinAggregateOutputType | null
    _max: Tbl_barrage_ILAcrossCanadaDay2023MaxAggregateOutputType | null
  }

  type GetTbl_barrage_ILAcrossCanadaDay2023GroupByPayload<T extends Tbl_barrage_ILAcrossCanadaDay2023GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Tbl_barrage_ILAcrossCanadaDay2023GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tbl_barrage_ILAcrossCanadaDay2023GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tbl_barrage_ILAcrossCanadaDay2023GroupByOutputType[P]>
            : GetScalarType<T[P], Tbl_barrage_ILAcrossCanadaDay2023GroupByOutputType[P]>
        }
      >
    >


  export type Tbl_barrage_ILAcrossCanadaDay2023Select = {
    barrage_id?: boolean
    barrage_content?: boolean
    createdAt?: boolean
  }


  export type Tbl_barrage_ILAcrossCanadaDay2023GetPayload<S extends boolean | null | undefined | Tbl_barrage_ILAcrossCanadaDay2023Args> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Tbl_barrage_ILAcrossCanadaDay2023 :
    S extends undefined ? never :
    S extends { include: any } & (Tbl_barrage_ILAcrossCanadaDay2023Args | Tbl_barrage_ILAcrossCanadaDay2023FindManyArgs)
    ? Tbl_barrage_ILAcrossCanadaDay2023 
    : S extends { select: any } & (Tbl_barrage_ILAcrossCanadaDay2023Args | Tbl_barrage_ILAcrossCanadaDay2023FindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Tbl_barrage_ILAcrossCanadaDay2023 ? Tbl_barrage_ILAcrossCanadaDay2023[P] : never
  } 
      : Tbl_barrage_ILAcrossCanadaDay2023


  type Tbl_barrage_ILAcrossCanadaDay2023CountArgs = 
    Omit<Tbl_barrage_ILAcrossCanadaDay2023FindManyArgs, 'select' | 'include'> & {
      select?: Tbl_barrage_ILAcrossCanadaDay2023CountAggregateInputType | true
    }

  export interface Tbl_barrage_ILAcrossCanadaDay2023Delegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tbl_barrage_ILAcrossCanadaDay2023 that matches the filter.
     * @param {Tbl_barrage_ILAcrossCanadaDay2023FindUniqueArgs} args - Arguments to find a Tbl_barrage_ILAcrossCanadaDay2023
     * @example
     * // Get one Tbl_barrage_ILAcrossCanadaDay2023
     * const tbl_barrage_ILAcrossCanadaDay2023 = await prisma.tbl_barrage_ILAcrossCanadaDay2023.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Tbl_barrage_ILAcrossCanadaDay2023FindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Tbl_barrage_ILAcrossCanadaDay2023FindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tbl_barrage_ILAcrossCanadaDay2023'> extends True ? Prisma__Tbl_barrage_ILAcrossCanadaDay2023Client<Tbl_barrage_ILAcrossCanadaDay2023GetPayload<T>> : Prisma__Tbl_barrage_ILAcrossCanadaDay2023Client<Tbl_barrage_ILAcrossCanadaDay2023GetPayload<T> | null, null>

    /**
     * Find one Tbl_barrage_ILAcrossCanadaDay2023 that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Tbl_barrage_ILAcrossCanadaDay2023FindUniqueOrThrowArgs} args - Arguments to find a Tbl_barrage_ILAcrossCanadaDay2023
     * @example
     * // Get one Tbl_barrage_ILAcrossCanadaDay2023
     * const tbl_barrage_ILAcrossCanadaDay2023 = await prisma.tbl_barrage_ILAcrossCanadaDay2023.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Tbl_barrage_ILAcrossCanadaDay2023FindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Tbl_barrage_ILAcrossCanadaDay2023FindUniqueOrThrowArgs>
    ): Prisma__Tbl_barrage_ILAcrossCanadaDay2023Client<Tbl_barrage_ILAcrossCanadaDay2023GetPayload<T>>

    /**
     * Find the first Tbl_barrage_ILAcrossCanadaDay2023 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_barrage_ILAcrossCanadaDay2023FindFirstArgs} args - Arguments to find a Tbl_barrage_ILAcrossCanadaDay2023
     * @example
     * // Get one Tbl_barrage_ILAcrossCanadaDay2023
     * const tbl_barrage_ILAcrossCanadaDay2023 = await prisma.tbl_barrage_ILAcrossCanadaDay2023.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Tbl_barrage_ILAcrossCanadaDay2023FindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Tbl_barrage_ILAcrossCanadaDay2023FindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tbl_barrage_ILAcrossCanadaDay2023'> extends True ? Prisma__Tbl_barrage_ILAcrossCanadaDay2023Client<Tbl_barrage_ILAcrossCanadaDay2023GetPayload<T>> : Prisma__Tbl_barrage_ILAcrossCanadaDay2023Client<Tbl_barrage_ILAcrossCanadaDay2023GetPayload<T> | null, null>

    /**
     * Find the first Tbl_barrage_ILAcrossCanadaDay2023 that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_barrage_ILAcrossCanadaDay2023FindFirstOrThrowArgs} args - Arguments to find a Tbl_barrage_ILAcrossCanadaDay2023
     * @example
     * // Get one Tbl_barrage_ILAcrossCanadaDay2023
     * const tbl_barrage_ILAcrossCanadaDay2023 = await prisma.tbl_barrage_ILAcrossCanadaDay2023.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Tbl_barrage_ILAcrossCanadaDay2023FindFirstOrThrowArgs>(
      args?: SelectSubset<T, Tbl_barrage_ILAcrossCanadaDay2023FindFirstOrThrowArgs>
    ): Prisma__Tbl_barrage_ILAcrossCanadaDay2023Client<Tbl_barrage_ILAcrossCanadaDay2023GetPayload<T>>

    /**
     * Find zero or more Tbl_barrage_ILAcrossCanadaDay2023s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_barrage_ILAcrossCanadaDay2023FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tbl_barrage_ILAcrossCanadaDay2023s
     * const tbl_barrage_ILAcrossCanadaDay2023s = await prisma.tbl_barrage_ILAcrossCanadaDay2023.findMany()
     * 
     * // Get first 10 Tbl_barrage_ILAcrossCanadaDay2023s
     * const tbl_barrage_ILAcrossCanadaDay2023s = await prisma.tbl_barrage_ILAcrossCanadaDay2023.findMany({ take: 10 })
     * 
     * // Only select the `barrage_id`
     * const tbl_barrage_ILAcrossCanadaDay2023WithBarrage_idOnly = await prisma.tbl_barrage_ILAcrossCanadaDay2023.findMany({ select: { barrage_id: true } })
     * 
    **/
    findMany<T extends Tbl_barrage_ILAcrossCanadaDay2023FindManyArgs>(
      args?: SelectSubset<T, Tbl_barrage_ILAcrossCanadaDay2023FindManyArgs>
    ): Prisma.PrismaPromise<Array<Tbl_barrage_ILAcrossCanadaDay2023GetPayload<T>>>

    /**
     * Create a Tbl_barrage_ILAcrossCanadaDay2023.
     * @param {Tbl_barrage_ILAcrossCanadaDay2023CreateArgs} args - Arguments to create a Tbl_barrage_ILAcrossCanadaDay2023.
     * @example
     * // Create one Tbl_barrage_ILAcrossCanadaDay2023
     * const Tbl_barrage_ILAcrossCanadaDay2023 = await prisma.tbl_barrage_ILAcrossCanadaDay2023.create({
     *   data: {
     *     // ... data to create a Tbl_barrage_ILAcrossCanadaDay2023
     *   }
     * })
     * 
    **/
    create<T extends Tbl_barrage_ILAcrossCanadaDay2023CreateArgs>(
      args: SelectSubset<T, Tbl_barrage_ILAcrossCanadaDay2023CreateArgs>
    ): Prisma__Tbl_barrage_ILAcrossCanadaDay2023Client<Tbl_barrage_ILAcrossCanadaDay2023GetPayload<T>>

    /**
     * Create many Tbl_barrage_ILAcrossCanadaDay2023s.
     *     @param {Tbl_barrage_ILAcrossCanadaDay2023CreateManyArgs} args - Arguments to create many Tbl_barrage_ILAcrossCanadaDay2023s.
     *     @example
     *     // Create many Tbl_barrage_ILAcrossCanadaDay2023s
     *     const tbl_barrage_ILAcrossCanadaDay2023 = await prisma.tbl_barrage_ILAcrossCanadaDay2023.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Tbl_barrage_ILAcrossCanadaDay2023CreateManyArgs>(
      args?: SelectSubset<T, Tbl_barrage_ILAcrossCanadaDay2023CreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tbl_barrage_ILAcrossCanadaDay2023.
     * @param {Tbl_barrage_ILAcrossCanadaDay2023DeleteArgs} args - Arguments to delete one Tbl_barrage_ILAcrossCanadaDay2023.
     * @example
     * // Delete one Tbl_barrage_ILAcrossCanadaDay2023
     * const Tbl_barrage_ILAcrossCanadaDay2023 = await prisma.tbl_barrage_ILAcrossCanadaDay2023.delete({
     *   where: {
     *     // ... filter to delete one Tbl_barrage_ILAcrossCanadaDay2023
     *   }
     * })
     * 
    **/
    delete<T extends Tbl_barrage_ILAcrossCanadaDay2023DeleteArgs>(
      args: SelectSubset<T, Tbl_barrage_ILAcrossCanadaDay2023DeleteArgs>
    ): Prisma__Tbl_barrage_ILAcrossCanadaDay2023Client<Tbl_barrage_ILAcrossCanadaDay2023GetPayload<T>>

    /**
     * Update one Tbl_barrage_ILAcrossCanadaDay2023.
     * @param {Tbl_barrage_ILAcrossCanadaDay2023UpdateArgs} args - Arguments to update one Tbl_barrage_ILAcrossCanadaDay2023.
     * @example
     * // Update one Tbl_barrage_ILAcrossCanadaDay2023
     * const tbl_barrage_ILAcrossCanadaDay2023 = await prisma.tbl_barrage_ILAcrossCanadaDay2023.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Tbl_barrage_ILAcrossCanadaDay2023UpdateArgs>(
      args: SelectSubset<T, Tbl_barrage_ILAcrossCanadaDay2023UpdateArgs>
    ): Prisma__Tbl_barrage_ILAcrossCanadaDay2023Client<Tbl_barrage_ILAcrossCanadaDay2023GetPayload<T>>

    /**
     * Delete zero or more Tbl_barrage_ILAcrossCanadaDay2023s.
     * @param {Tbl_barrage_ILAcrossCanadaDay2023DeleteManyArgs} args - Arguments to filter Tbl_barrage_ILAcrossCanadaDay2023s to delete.
     * @example
     * // Delete a few Tbl_barrage_ILAcrossCanadaDay2023s
     * const { count } = await prisma.tbl_barrage_ILAcrossCanadaDay2023.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Tbl_barrage_ILAcrossCanadaDay2023DeleteManyArgs>(
      args?: SelectSubset<T, Tbl_barrage_ILAcrossCanadaDay2023DeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tbl_barrage_ILAcrossCanadaDay2023s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_barrage_ILAcrossCanadaDay2023UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tbl_barrage_ILAcrossCanadaDay2023s
     * const tbl_barrage_ILAcrossCanadaDay2023 = await prisma.tbl_barrage_ILAcrossCanadaDay2023.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Tbl_barrage_ILAcrossCanadaDay2023UpdateManyArgs>(
      args: SelectSubset<T, Tbl_barrage_ILAcrossCanadaDay2023UpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tbl_barrage_ILAcrossCanadaDay2023.
     * @param {Tbl_barrage_ILAcrossCanadaDay2023UpsertArgs} args - Arguments to update or create a Tbl_barrage_ILAcrossCanadaDay2023.
     * @example
     * // Update or create a Tbl_barrage_ILAcrossCanadaDay2023
     * const tbl_barrage_ILAcrossCanadaDay2023 = await prisma.tbl_barrage_ILAcrossCanadaDay2023.upsert({
     *   create: {
     *     // ... data to create a Tbl_barrage_ILAcrossCanadaDay2023
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tbl_barrage_ILAcrossCanadaDay2023 we want to update
     *   }
     * })
    **/
    upsert<T extends Tbl_barrage_ILAcrossCanadaDay2023UpsertArgs>(
      args: SelectSubset<T, Tbl_barrage_ILAcrossCanadaDay2023UpsertArgs>
    ): Prisma__Tbl_barrage_ILAcrossCanadaDay2023Client<Tbl_barrage_ILAcrossCanadaDay2023GetPayload<T>>

    /**
     * Count the number of Tbl_barrage_ILAcrossCanadaDay2023s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_barrage_ILAcrossCanadaDay2023CountArgs} args - Arguments to filter Tbl_barrage_ILAcrossCanadaDay2023s to count.
     * @example
     * // Count the number of Tbl_barrage_ILAcrossCanadaDay2023s
     * const count = await prisma.tbl_barrage_ILAcrossCanadaDay2023.count({
     *   where: {
     *     // ... the filter for the Tbl_barrage_ILAcrossCanadaDay2023s we want to count
     *   }
     * })
    **/
    count<T extends Tbl_barrage_ILAcrossCanadaDay2023CountArgs>(
      args?: Subset<T, Tbl_barrage_ILAcrossCanadaDay2023CountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tbl_barrage_ILAcrossCanadaDay2023CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tbl_barrage_ILAcrossCanadaDay2023.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_barrage_ILAcrossCanadaDay2023AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tbl_barrage_ILAcrossCanadaDay2023AggregateArgs>(args: Subset<T, Tbl_barrage_ILAcrossCanadaDay2023AggregateArgs>): Prisma.PrismaPromise<GetTbl_barrage_ILAcrossCanadaDay2023AggregateType<T>>

    /**
     * Group by Tbl_barrage_ILAcrossCanadaDay2023.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_barrage_ILAcrossCanadaDay2023GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tbl_barrage_ILAcrossCanadaDay2023GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tbl_barrage_ILAcrossCanadaDay2023GroupByArgs['orderBy'] }
        : { orderBy?: Tbl_barrage_ILAcrossCanadaDay2023GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tbl_barrage_ILAcrossCanadaDay2023GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTbl_barrage_ILAcrossCanadaDay2023GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Tbl_barrage_ILAcrossCanadaDay2023.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Tbl_barrage_ILAcrossCanadaDay2023Client<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Tbl_barrage_ILAcrossCanadaDay2023 base type for findUnique actions
   */
  export type Tbl_barrage_ILAcrossCanadaDay2023FindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Tbl_barrage_ILAcrossCanadaDay2023
     */
    select?: Tbl_barrage_ILAcrossCanadaDay2023Select | null
    /**
     * Filter, which Tbl_barrage_ILAcrossCanadaDay2023 to fetch.
     */
    where: Tbl_barrage_ILAcrossCanadaDay2023WhereUniqueInput
  }

  /**
   * Tbl_barrage_ILAcrossCanadaDay2023 findUnique
   */
  export interface Tbl_barrage_ILAcrossCanadaDay2023FindUniqueArgs extends Tbl_barrage_ILAcrossCanadaDay2023FindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tbl_barrage_ILAcrossCanadaDay2023 findUniqueOrThrow
   */
  export type Tbl_barrage_ILAcrossCanadaDay2023FindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tbl_barrage_ILAcrossCanadaDay2023
     */
    select?: Tbl_barrage_ILAcrossCanadaDay2023Select | null
    /**
     * Filter, which Tbl_barrage_ILAcrossCanadaDay2023 to fetch.
     */
    where: Tbl_barrage_ILAcrossCanadaDay2023WhereUniqueInput
  }


  /**
   * Tbl_barrage_ILAcrossCanadaDay2023 base type for findFirst actions
   */
  export type Tbl_barrage_ILAcrossCanadaDay2023FindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Tbl_barrage_ILAcrossCanadaDay2023
     */
    select?: Tbl_barrage_ILAcrossCanadaDay2023Select | null
    /**
     * Filter, which Tbl_barrage_ILAcrossCanadaDay2023 to fetch.
     */
    where?: Tbl_barrage_ILAcrossCanadaDay2023WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tbl_barrage_ILAcrossCanadaDay2023s to fetch.
     */
    orderBy?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tbl_barrage_ILAcrossCanadaDay2023s.
     */
    cursor?: Tbl_barrage_ILAcrossCanadaDay2023WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tbl_barrage_ILAcrossCanadaDay2023s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tbl_barrage_ILAcrossCanadaDay2023s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tbl_barrage_ILAcrossCanadaDay2023s.
     */
    distinct?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023ScalarFieldEnum>
  }

  /**
   * Tbl_barrage_ILAcrossCanadaDay2023 findFirst
   */
  export interface Tbl_barrage_ILAcrossCanadaDay2023FindFirstArgs extends Tbl_barrage_ILAcrossCanadaDay2023FindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tbl_barrage_ILAcrossCanadaDay2023 findFirstOrThrow
   */
  export type Tbl_barrage_ILAcrossCanadaDay2023FindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tbl_barrage_ILAcrossCanadaDay2023
     */
    select?: Tbl_barrage_ILAcrossCanadaDay2023Select | null
    /**
     * Filter, which Tbl_barrage_ILAcrossCanadaDay2023 to fetch.
     */
    where?: Tbl_barrage_ILAcrossCanadaDay2023WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tbl_barrage_ILAcrossCanadaDay2023s to fetch.
     */
    orderBy?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tbl_barrage_ILAcrossCanadaDay2023s.
     */
    cursor?: Tbl_barrage_ILAcrossCanadaDay2023WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tbl_barrage_ILAcrossCanadaDay2023s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tbl_barrage_ILAcrossCanadaDay2023s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tbl_barrage_ILAcrossCanadaDay2023s.
     */
    distinct?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023ScalarFieldEnum>
  }


  /**
   * Tbl_barrage_ILAcrossCanadaDay2023 findMany
   */
  export type Tbl_barrage_ILAcrossCanadaDay2023FindManyArgs = {
    /**
     * Select specific fields to fetch from the Tbl_barrage_ILAcrossCanadaDay2023
     */
    select?: Tbl_barrage_ILAcrossCanadaDay2023Select | null
    /**
     * Filter, which Tbl_barrage_ILAcrossCanadaDay2023s to fetch.
     */
    where?: Tbl_barrage_ILAcrossCanadaDay2023WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tbl_barrage_ILAcrossCanadaDay2023s to fetch.
     */
    orderBy?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tbl_barrage_ILAcrossCanadaDay2023s.
     */
    cursor?: Tbl_barrage_ILAcrossCanadaDay2023WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tbl_barrage_ILAcrossCanadaDay2023s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tbl_barrage_ILAcrossCanadaDay2023s.
     */
    skip?: number
    distinct?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023ScalarFieldEnum>
  }


  /**
   * Tbl_barrage_ILAcrossCanadaDay2023 create
   */
  export type Tbl_barrage_ILAcrossCanadaDay2023CreateArgs = {
    /**
     * Select specific fields to fetch from the Tbl_barrage_ILAcrossCanadaDay2023
     */
    select?: Tbl_barrage_ILAcrossCanadaDay2023Select | null
    /**
     * The data needed to create a Tbl_barrage_ILAcrossCanadaDay2023.
     */
    data: XOR<Tbl_barrage_ILAcrossCanadaDay2023CreateInput, Tbl_barrage_ILAcrossCanadaDay2023UncheckedCreateInput>
  }


  /**
   * Tbl_barrage_ILAcrossCanadaDay2023 createMany
   */
  export type Tbl_barrage_ILAcrossCanadaDay2023CreateManyArgs = {
    /**
     * The data used to create many Tbl_barrage_ILAcrossCanadaDay2023s.
     */
    data: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023CreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tbl_barrage_ILAcrossCanadaDay2023 update
   */
  export type Tbl_barrage_ILAcrossCanadaDay2023UpdateArgs = {
    /**
     * Select specific fields to fetch from the Tbl_barrage_ILAcrossCanadaDay2023
     */
    select?: Tbl_barrage_ILAcrossCanadaDay2023Select | null
    /**
     * The data needed to update a Tbl_barrage_ILAcrossCanadaDay2023.
     */
    data: XOR<Tbl_barrage_ILAcrossCanadaDay2023UpdateInput, Tbl_barrage_ILAcrossCanadaDay2023UncheckedUpdateInput>
    /**
     * Choose, which Tbl_barrage_ILAcrossCanadaDay2023 to update.
     */
    where: Tbl_barrage_ILAcrossCanadaDay2023WhereUniqueInput
  }


  /**
   * Tbl_barrage_ILAcrossCanadaDay2023 updateMany
   */
  export type Tbl_barrage_ILAcrossCanadaDay2023UpdateManyArgs = {
    /**
     * The data used to update Tbl_barrage_ILAcrossCanadaDay2023s.
     */
    data: XOR<Tbl_barrage_ILAcrossCanadaDay2023UpdateManyMutationInput, Tbl_barrage_ILAcrossCanadaDay2023UncheckedUpdateManyInput>
    /**
     * Filter which Tbl_barrage_ILAcrossCanadaDay2023s to update
     */
    where?: Tbl_barrage_ILAcrossCanadaDay2023WhereInput
  }


  /**
   * Tbl_barrage_ILAcrossCanadaDay2023 upsert
   */
  export type Tbl_barrage_ILAcrossCanadaDay2023UpsertArgs = {
    /**
     * Select specific fields to fetch from the Tbl_barrage_ILAcrossCanadaDay2023
     */
    select?: Tbl_barrage_ILAcrossCanadaDay2023Select | null
    /**
     * The filter to search for the Tbl_barrage_ILAcrossCanadaDay2023 to update in case it exists.
     */
    where: Tbl_barrage_ILAcrossCanadaDay2023WhereUniqueInput
    /**
     * In case the Tbl_barrage_ILAcrossCanadaDay2023 found by the `where` argument doesn't exist, create a new Tbl_barrage_ILAcrossCanadaDay2023 with this data.
     */
    create: XOR<Tbl_barrage_ILAcrossCanadaDay2023CreateInput, Tbl_barrage_ILAcrossCanadaDay2023UncheckedCreateInput>
    /**
     * In case the Tbl_barrage_ILAcrossCanadaDay2023 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tbl_barrage_ILAcrossCanadaDay2023UpdateInput, Tbl_barrage_ILAcrossCanadaDay2023UncheckedUpdateInput>
  }


  /**
   * Tbl_barrage_ILAcrossCanadaDay2023 delete
   */
  export type Tbl_barrage_ILAcrossCanadaDay2023DeleteArgs = {
    /**
     * Select specific fields to fetch from the Tbl_barrage_ILAcrossCanadaDay2023
     */
    select?: Tbl_barrage_ILAcrossCanadaDay2023Select | null
    /**
     * Filter which Tbl_barrage_ILAcrossCanadaDay2023 to delete.
     */
    where: Tbl_barrage_ILAcrossCanadaDay2023WhereUniqueInput
  }


  /**
   * Tbl_barrage_ILAcrossCanadaDay2023 deleteMany
   */
  export type Tbl_barrage_ILAcrossCanadaDay2023DeleteManyArgs = {
    /**
     * Filter which Tbl_barrage_ILAcrossCanadaDay2023s to delete
     */
    where?: Tbl_barrage_ILAcrossCanadaDay2023WhereInput
  }


  /**
   * Tbl_barrage_ILAcrossCanadaDay2023 without action
   */
  export type Tbl_barrage_ILAcrossCanadaDay2023Args = {
    /**
     * Select specific fields to fetch from the Tbl_barrage_ILAcrossCanadaDay2023
     */
    select?: Tbl_barrage_ILAcrossCanadaDay2023Select | null
  }



  /**
   * Model auth_group
   */


  export type AggregateAuth_group = {
    _count: Auth_groupCountAggregateOutputType | null
    _avg: Auth_groupAvgAggregateOutputType | null
    _sum: Auth_groupSumAggregateOutputType | null
    _min: Auth_groupMinAggregateOutputType | null
    _max: Auth_groupMaxAggregateOutputType | null
  }

  export type Auth_groupAvgAggregateOutputType = {
    id: number | null
  }

  export type Auth_groupSumAggregateOutputType = {
    id: number | null
  }

  export type Auth_groupMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Auth_groupMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Auth_groupCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Auth_groupAvgAggregateInputType = {
    id?: true
  }

  export type Auth_groupSumAggregateInputType = {
    id?: true
  }

  export type Auth_groupMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Auth_groupMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Auth_groupCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Auth_groupAggregateArgs = {
    /**
     * Filter which auth_group to aggregate.
     */
    where?: auth_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_groups to fetch.
     */
    orderBy?: Enumerable<auth_groupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auth_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auth_groups
    **/
    _count?: true | Auth_groupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Auth_groupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Auth_groupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auth_groupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auth_groupMaxAggregateInputType
  }

  export type GetAuth_groupAggregateType<T extends Auth_groupAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth_group]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth_group[P]>
      : GetScalarType<T[P], AggregateAuth_group[P]>
  }




  export type Auth_groupGroupByArgs = {
    where?: auth_groupWhereInput
    orderBy?: Enumerable<auth_groupOrderByWithAggregationInput>
    by: Auth_groupScalarFieldEnum[]
    having?: auth_groupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auth_groupCountAggregateInputType | true
    _avg?: Auth_groupAvgAggregateInputType
    _sum?: Auth_groupSumAggregateInputType
    _min?: Auth_groupMinAggregateInputType
    _max?: Auth_groupMaxAggregateInputType
  }


  export type Auth_groupGroupByOutputType = {
    id: number
    name: string
    _count: Auth_groupCountAggregateOutputType | null
    _avg: Auth_groupAvgAggregateOutputType | null
    _sum: Auth_groupSumAggregateOutputType | null
    _min: Auth_groupMinAggregateOutputType | null
    _max: Auth_groupMaxAggregateOutputType | null
  }

  type GetAuth_groupGroupByPayload<T extends Auth_groupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Auth_groupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auth_groupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auth_groupGroupByOutputType[P]>
            : GetScalarType<T[P], Auth_groupGroupByOutputType[P]>
        }
      >
    >


  export type auth_groupSelect = {
    id?: boolean
    name?: boolean
    auth_group_permissions?: boolean | auth_group$auth_group_permissionsArgs
    auth_user_groups?: boolean | auth_group$auth_user_groupsArgs
    _count?: boolean | Auth_groupCountOutputTypeArgs
  }


  export type auth_groupInclude = {
    auth_group_permissions?: boolean | auth_group$auth_group_permissionsArgs
    auth_user_groups?: boolean | auth_group$auth_user_groupsArgs
    _count?: boolean | Auth_groupCountOutputTypeArgs
  }

  export type auth_groupGetPayload<S extends boolean | null | undefined | auth_groupArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? auth_group :
    S extends undefined ? never :
    S extends { include: any } & (auth_groupArgs | auth_groupFindManyArgs)
    ? auth_group  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'auth_group_permissions' ? Array < auth_group_permissionsGetPayload<S['include'][P]>>  :
        P extends 'auth_user_groups' ? Array < auth_user_groupsGetPayload<S['include'][P]>>  :
        P extends '_count' ? Auth_groupCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (auth_groupArgs | auth_groupFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'auth_group_permissions' ? Array < auth_group_permissionsGetPayload<S['select'][P]>>  :
        P extends 'auth_user_groups' ? Array < auth_user_groupsGetPayload<S['select'][P]>>  :
        P extends '_count' ? Auth_groupCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof auth_group ? auth_group[P] : never
  } 
      : auth_group


  type auth_groupCountArgs = 
    Omit<auth_groupFindManyArgs, 'select' | 'include'> & {
      select?: Auth_groupCountAggregateInputType | true
    }

  export interface auth_groupDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Auth_group that matches the filter.
     * @param {auth_groupFindUniqueArgs} args - Arguments to find a Auth_group
     * @example
     * // Get one Auth_group
     * const auth_group = await prisma.auth_group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends auth_groupFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, auth_groupFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'auth_group'> extends True ? Prisma__auth_groupClient<auth_groupGetPayload<T>> : Prisma__auth_groupClient<auth_groupGetPayload<T> | null, null>

    /**
     * Find one Auth_group that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {auth_groupFindUniqueOrThrowArgs} args - Arguments to find a Auth_group
     * @example
     * // Get one Auth_group
     * const auth_group = await prisma.auth_group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends auth_groupFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, auth_groupFindUniqueOrThrowArgs>
    ): Prisma__auth_groupClient<auth_groupGetPayload<T>>

    /**
     * Find the first Auth_group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_groupFindFirstArgs} args - Arguments to find a Auth_group
     * @example
     * // Get one Auth_group
     * const auth_group = await prisma.auth_group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends auth_groupFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, auth_groupFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'auth_group'> extends True ? Prisma__auth_groupClient<auth_groupGetPayload<T>> : Prisma__auth_groupClient<auth_groupGetPayload<T> | null, null>

    /**
     * Find the first Auth_group that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_groupFindFirstOrThrowArgs} args - Arguments to find a Auth_group
     * @example
     * // Get one Auth_group
     * const auth_group = await prisma.auth_group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends auth_groupFindFirstOrThrowArgs>(
      args?: SelectSubset<T, auth_groupFindFirstOrThrowArgs>
    ): Prisma__auth_groupClient<auth_groupGetPayload<T>>

    /**
     * Find zero or more Auth_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_groupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auth_groups
     * const auth_groups = await prisma.auth_group.findMany()
     * 
     * // Get first 10 Auth_groups
     * const auth_groups = await prisma.auth_group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auth_groupWithIdOnly = await prisma.auth_group.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends auth_groupFindManyArgs>(
      args?: SelectSubset<T, auth_groupFindManyArgs>
    ): Prisma.PrismaPromise<Array<auth_groupGetPayload<T>>>

    /**
     * Create a Auth_group.
     * @param {auth_groupCreateArgs} args - Arguments to create a Auth_group.
     * @example
     * // Create one Auth_group
     * const Auth_group = await prisma.auth_group.create({
     *   data: {
     *     // ... data to create a Auth_group
     *   }
     * })
     * 
    **/
    create<T extends auth_groupCreateArgs>(
      args: SelectSubset<T, auth_groupCreateArgs>
    ): Prisma__auth_groupClient<auth_groupGetPayload<T>>

    /**
     * Create many Auth_groups.
     *     @param {auth_groupCreateManyArgs} args - Arguments to create many Auth_groups.
     *     @example
     *     // Create many Auth_groups
     *     const auth_group = await prisma.auth_group.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends auth_groupCreateManyArgs>(
      args?: SelectSubset<T, auth_groupCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auth_group.
     * @param {auth_groupDeleteArgs} args - Arguments to delete one Auth_group.
     * @example
     * // Delete one Auth_group
     * const Auth_group = await prisma.auth_group.delete({
     *   where: {
     *     // ... filter to delete one Auth_group
     *   }
     * })
     * 
    **/
    delete<T extends auth_groupDeleteArgs>(
      args: SelectSubset<T, auth_groupDeleteArgs>
    ): Prisma__auth_groupClient<auth_groupGetPayload<T>>

    /**
     * Update one Auth_group.
     * @param {auth_groupUpdateArgs} args - Arguments to update one Auth_group.
     * @example
     * // Update one Auth_group
     * const auth_group = await prisma.auth_group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends auth_groupUpdateArgs>(
      args: SelectSubset<T, auth_groupUpdateArgs>
    ): Prisma__auth_groupClient<auth_groupGetPayload<T>>

    /**
     * Delete zero or more Auth_groups.
     * @param {auth_groupDeleteManyArgs} args - Arguments to filter Auth_groups to delete.
     * @example
     * // Delete a few Auth_groups
     * const { count } = await prisma.auth_group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends auth_groupDeleteManyArgs>(
      args?: SelectSubset<T, auth_groupDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_groupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auth_groups
     * const auth_group = await prisma.auth_group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends auth_groupUpdateManyArgs>(
      args: SelectSubset<T, auth_groupUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auth_group.
     * @param {auth_groupUpsertArgs} args - Arguments to update or create a Auth_group.
     * @example
     * // Update or create a Auth_group
     * const auth_group = await prisma.auth_group.upsert({
     *   create: {
     *     // ... data to create a Auth_group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth_group we want to update
     *   }
     * })
    **/
    upsert<T extends auth_groupUpsertArgs>(
      args: SelectSubset<T, auth_groupUpsertArgs>
    ): Prisma__auth_groupClient<auth_groupGetPayload<T>>

    /**
     * Count the number of Auth_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_groupCountArgs} args - Arguments to filter Auth_groups to count.
     * @example
     * // Count the number of Auth_groups
     * const count = await prisma.auth_group.count({
     *   where: {
     *     // ... the filter for the Auth_groups we want to count
     *   }
     * })
    **/
    count<T extends auth_groupCountArgs>(
      args?: Subset<T, auth_groupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auth_groupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth_group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_groupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auth_groupAggregateArgs>(args: Subset<T, Auth_groupAggregateArgs>): Prisma.PrismaPromise<GetAuth_groupAggregateType<T>>

    /**
     * Group by Auth_group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_groupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Auth_groupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Auth_groupGroupByArgs['orderBy'] }
        : { orderBy?: Auth_groupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Auth_groupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuth_groupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for auth_group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__auth_groupClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    auth_group_permissions<T extends auth_group$auth_group_permissionsArgs= {}>(args?: Subset<T, auth_group$auth_group_permissionsArgs>): Prisma.PrismaPromise<Array<auth_group_permissionsGetPayload<T>>| Null>;

    auth_user_groups<T extends auth_group$auth_user_groupsArgs= {}>(args?: Subset<T, auth_group$auth_user_groupsArgs>): Prisma.PrismaPromise<Array<auth_user_groupsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * auth_group base type for findUnique actions
   */
  export type auth_groupFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the auth_group
     */
    select?: auth_groupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_groupInclude | null
    /**
     * Filter, which auth_group to fetch.
     */
    where: auth_groupWhereUniqueInput
  }

  /**
   * auth_group findUnique
   */
  export interface auth_groupFindUniqueArgs extends auth_groupFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auth_group findUniqueOrThrow
   */
  export type auth_groupFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the auth_group
     */
    select?: auth_groupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_groupInclude | null
    /**
     * Filter, which auth_group to fetch.
     */
    where: auth_groupWhereUniqueInput
  }


  /**
   * auth_group base type for findFirst actions
   */
  export type auth_groupFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the auth_group
     */
    select?: auth_groupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_groupInclude | null
    /**
     * Filter, which auth_group to fetch.
     */
    where?: auth_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_groups to fetch.
     */
    orderBy?: Enumerable<auth_groupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_groups.
     */
    cursor?: auth_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_groups.
     */
    distinct?: Enumerable<Auth_groupScalarFieldEnum>
  }

  /**
   * auth_group findFirst
   */
  export interface auth_groupFindFirstArgs extends auth_groupFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auth_group findFirstOrThrow
   */
  export type auth_groupFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the auth_group
     */
    select?: auth_groupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_groupInclude | null
    /**
     * Filter, which auth_group to fetch.
     */
    where?: auth_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_groups to fetch.
     */
    orderBy?: Enumerable<auth_groupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_groups.
     */
    cursor?: auth_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_groups.
     */
    distinct?: Enumerable<Auth_groupScalarFieldEnum>
  }


  /**
   * auth_group findMany
   */
  export type auth_groupFindManyArgs = {
    /**
     * Select specific fields to fetch from the auth_group
     */
    select?: auth_groupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_groupInclude | null
    /**
     * Filter, which auth_groups to fetch.
     */
    where?: auth_groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_groups to fetch.
     */
    orderBy?: Enumerable<auth_groupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auth_groups.
     */
    cursor?: auth_groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_groups.
     */
    skip?: number
    distinct?: Enumerable<Auth_groupScalarFieldEnum>
  }


  /**
   * auth_group create
   */
  export type auth_groupCreateArgs = {
    /**
     * Select specific fields to fetch from the auth_group
     */
    select?: auth_groupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_groupInclude | null
    /**
     * The data needed to create a auth_group.
     */
    data: XOR<auth_groupCreateInput, auth_groupUncheckedCreateInput>
  }


  /**
   * auth_group createMany
   */
  export type auth_groupCreateManyArgs = {
    /**
     * The data used to create many auth_groups.
     */
    data: Enumerable<auth_groupCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * auth_group update
   */
  export type auth_groupUpdateArgs = {
    /**
     * Select specific fields to fetch from the auth_group
     */
    select?: auth_groupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_groupInclude | null
    /**
     * The data needed to update a auth_group.
     */
    data: XOR<auth_groupUpdateInput, auth_groupUncheckedUpdateInput>
    /**
     * Choose, which auth_group to update.
     */
    where: auth_groupWhereUniqueInput
  }


  /**
   * auth_group updateMany
   */
  export type auth_groupUpdateManyArgs = {
    /**
     * The data used to update auth_groups.
     */
    data: XOR<auth_groupUpdateManyMutationInput, auth_groupUncheckedUpdateManyInput>
    /**
     * Filter which auth_groups to update
     */
    where?: auth_groupWhereInput
  }


  /**
   * auth_group upsert
   */
  export type auth_groupUpsertArgs = {
    /**
     * Select specific fields to fetch from the auth_group
     */
    select?: auth_groupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_groupInclude | null
    /**
     * The filter to search for the auth_group to update in case it exists.
     */
    where: auth_groupWhereUniqueInput
    /**
     * In case the auth_group found by the `where` argument doesn't exist, create a new auth_group with this data.
     */
    create: XOR<auth_groupCreateInput, auth_groupUncheckedCreateInput>
    /**
     * In case the auth_group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auth_groupUpdateInput, auth_groupUncheckedUpdateInput>
  }


  /**
   * auth_group delete
   */
  export type auth_groupDeleteArgs = {
    /**
     * Select specific fields to fetch from the auth_group
     */
    select?: auth_groupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_groupInclude | null
    /**
     * Filter which auth_group to delete.
     */
    where: auth_groupWhereUniqueInput
  }


  /**
   * auth_group deleteMany
   */
  export type auth_groupDeleteManyArgs = {
    /**
     * Filter which auth_groups to delete
     */
    where?: auth_groupWhereInput
  }


  /**
   * auth_group.auth_group_permissions
   */
  export type auth_group$auth_group_permissionsArgs = {
    /**
     * Select specific fields to fetch from the auth_group_permissions
     */
    select?: auth_group_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_group_permissionsInclude | null
    where?: auth_group_permissionsWhereInput
    orderBy?: Enumerable<auth_group_permissionsOrderByWithRelationInput>
    cursor?: auth_group_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Auth_group_permissionsScalarFieldEnum>
  }


  /**
   * auth_group.auth_user_groups
   */
  export type auth_group$auth_user_groupsArgs = {
    /**
     * Select specific fields to fetch from the auth_user_groups
     */
    select?: auth_user_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_groupsInclude | null
    where?: auth_user_groupsWhereInput
    orderBy?: Enumerable<auth_user_groupsOrderByWithRelationInput>
    cursor?: auth_user_groupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Auth_user_groupsScalarFieldEnum>
  }


  /**
   * auth_group without action
   */
  export type auth_groupArgs = {
    /**
     * Select specific fields to fetch from the auth_group
     */
    select?: auth_groupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_groupInclude | null
  }



  /**
   * Model auth_group_permissions
   */


  export type AggregateAuth_group_permissions = {
    _count: Auth_group_permissionsCountAggregateOutputType | null
    _avg: Auth_group_permissionsAvgAggregateOutputType | null
    _sum: Auth_group_permissionsSumAggregateOutputType | null
    _min: Auth_group_permissionsMinAggregateOutputType | null
    _max: Auth_group_permissionsMaxAggregateOutputType | null
  }

  export type Auth_group_permissionsAvgAggregateOutputType = {
    id: number | null
    group_id: number | null
    permission_id: number | null
  }

  export type Auth_group_permissionsSumAggregateOutputType = {
    id: bigint | null
    group_id: number | null
    permission_id: number | null
  }

  export type Auth_group_permissionsMinAggregateOutputType = {
    id: bigint | null
    group_id: number | null
    permission_id: number | null
  }

  export type Auth_group_permissionsMaxAggregateOutputType = {
    id: bigint | null
    group_id: number | null
    permission_id: number | null
  }

  export type Auth_group_permissionsCountAggregateOutputType = {
    id: number
    group_id: number
    permission_id: number
    _all: number
  }


  export type Auth_group_permissionsAvgAggregateInputType = {
    id?: true
    group_id?: true
    permission_id?: true
  }

  export type Auth_group_permissionsSumAggregateInputType = {
    id?: true
    group_id?: true
    permission_id?: true
  }

  export type Auth_group_permissionsMinAggregateInputType = {
    id?: true
    group_id?: true
    permission_id?: true
  }

  export type Auth_group_permissionsMaxAggregateInputType = {
    id?: true
    group_id?: true
    permission_id?: true
  }

  export type Auth_group_permissionsCountAggregateInputType = {
    id?: true
    group_id?: true
    permission_id?: true
    _all?: true
  }

  export type Auth_group_permissionsAggregateArgs = {
    /**
     * Filter which auth_group_permissions to aggregate.
     */
    where?: auth_group_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_group_permissions to fetch.
     */
    orderBy?: Enumerable<auth_group_permissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auth_group_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_group_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_group_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auth_group_permissions
    **/
    _count?: true | Auth_group_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Auth_group_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Auth_group_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auth_group_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auth_group_permissionsMaxAggregateInputType
  }

  export type GetAuth_group_permissionsAggregateType<T extends Auth_group_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth_group_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth_group_permissions[P]>
      : GetScalarType<T[P], AggregateAuth_group_permissions[P]>
  }




  export type Auth_group_permissionsGroupByArgs = {
    where?: auth_group_permissionsWhereInput
    orderBy?: Enumerable<auth_group_permissionsOrderByWithAggregationInput>
    by: Auth_group_permissionsScalarFieldEnum[]
    having?: auth_group_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auth_group_permissionsCountAggregateInputType | true
    _avg?: Auth_group_permissionsAvgAggregateInputType
    _sum?: Auth_group_permissionsSumAggregateInputType
    _min?: Auth_group_permissionsMinAggregateInputType
    _max?: Auth_group_permissionsMaxAggregateInputType
  }


  export type Auth_group_permissionsGroupByOutputType = {
    id: bigint
    group_id: number
    permission_id: number
    _count: Auth_group_permissionsCountAggregateOutputType | null
    _avg: Auth_group_permissionsAvgAggregateOutputType | null
    _sum: Auth_group_permissionsSumAggregateOutputType | null
    _min: Auth_group_permissionsMinAggregateOutputType | null
    _max: Auth_group_permissionsMaxAggregateOutputType | null
  }

  type GetAuth_group_permissionsGroupByPayload<T extends Auth_group_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Auth_group_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auth_group_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auth_group_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Auth_group_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type auth_group_permissionsSelect = {
    id?: boolean
    group_id?: boolean
    permission_id?: boolean
    auth_permission?: boolean | auth_permissionArgs
    auth_group?: boolean | auth_groupArgs
  }


  export type auth_group_permissionsInclude = {
    auth_permission?: boolean | auth_permissionArgs
    auth_group?: boolean | auth_groupArgs
  }

  export type auth_group_permissionsGetPayload<S extends boolean | null | undefined | auth_group_permissionsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? auth_group_permissions :
    S extends undefined ? never :
    S extends { include: any } & (auth_group_permissionsArgs | auth_group_permissionsFindManyArgs)
    ? auth_group_permissions  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'auth_permission' ? auth_permissionGetPayload<S['include'][P]> :
        P extends 'auth_group' ? auth_groupGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (auth_group_permissionsArgs | auth_group_permissionsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'auth_permission' ? auth_permissionGetPayload<S['select'][P]> :
        P extends 'auth_group' ? auth_groupGetPayload<S['select'][P]> :  P extends keyof auth_group_permissions ? auth_group_permissions[P] : never
  } 
      : auth_group_permissions


  type auth_group_permissionsCountArgs = 
    Omit<auth_group_permissionsFindManyArgs, 'select' | 'include'> & {
      select?: Auth_group_permissionsCountAggregateInputType | true
    }

  export interface auth_group_permissionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Auth_group_permissions that matches the filter.
     * @param {auth_group_permissionsFindUniqueArgs} args - Arguments to find a Auth_group_permissions
     * @example
     * // Get one Auth_group_permissions
     * const auth_group_permissions = await prisma.auth_group_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends auth_group_permissionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, auth_group_permissionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'auth_group_permissions'> extends True ? Prisma__auth_group_permissionsClient<auth_group_permissionsGetPayload<T>> : Prisma__auth_group_permissionsClient<auth_group_permissionsGetPayload<T> | null, null>

    /**
     * Find one Auth_group_permissions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {auth_group_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Auth_group_permissions
     * @example
     * // Get one Auth_group_permissions
     * const auth_group_permissions = await prisma.auth_group_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends auth_group_permissionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, auth_group_permissionsFindUniqueOrThrowArgs>
    ): Prisma__auth_group_permissionsClient<auth_group_permissionsGetPayload<T>>

    /**
     * Find the first Auth_group_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_group_permissionsFindFirstArgs} args - Arguments to find a Auth_group_permissions
     * @example
     * // Get one Auth_group_permissions
     * const auth_group_permissions = await prisma.auth_group_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends auth_group_permissionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, auth_group_permissionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'auth_group_permissions'> extends True ? Prisma__auth_group_permissionsClient<auth_group_permissionsGetPayload<T>> : Prisma__auth_group_permissionsClient<auth_group_permissionsGetPayload<T> | null, null>

    /**
     * Find the first Auth_group_permissions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_group_permissionsFindFirstOrThrowArgs} args - Arguments to find a Auth_group_permissions
     * @example
     * // Get one Auth_group_permissions
     * const auth_group_permissions = await prisma.auth_group_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends auth_group_permissionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, auth_group_permissionsFindFirstOrThrowArgs>
    ): Prisma__auth_group_permissionsClient<auth_group_permissionsGetPayload<T>>

    /**
     * Find zero or more Auth_group_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_group_permissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auth_group_permissions
     * const auth_group_permissions = await prisma.auth_group_permissions.findMany()
     * 
     * // Get first 10 Auth_group_permissions
     * const auth_group_permissions = await prisma.auth_group_permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auth_group_permissionsWithIdOnly = await prisma.auth_group_permissions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends auth_group_permissionsFindManyArgs>(
      args?: SelectSubset<T, auth_group_permissionsFindManyArgs>
    ): Prisma.PrismaPromise<Array<auth_group_permissionsGetPayload<T>>>

    /**
     * Create a Auth_group_permissions.
     * @param {auth_group_permissionsCreateArgs} args - Arguments to create a Auth_group_permissions.
     * @example
     * // Create one Auth_group_permissions
     * const Auth_group_permissions = await prisma.auth_group_permissions.create({
     *   data: {
     *     // ... data to create a Auth_group_permissions
     *   }
     * })
     * 
    **/
    create<T extends auth_group_permissionsCreateArgs>(
      args: SelectSubset<T, auth_group_permissionsCreateArgs>
    ): Prisma__auth_group_permissionsClient<auth_group_permissionsGetPayload<T>>

    /**
     * Create many Auth_group_permissions.
     *     @param {auth_group_permissionsCreateManyArgs} args - Arguments to create many Auth_group_permissions.
     *     @example
     *     // Create many Auth_group_permissions
     *     const auth_group_permissions = await prisma.auth_group_permissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends auth_group_permissionsCreateManyArgs>(
      args?: SelectSubset<T, auth_group_permissionsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auth_group_permissions.
     * @param {auth_group_permissionsDeleteArgs} args - Arguments to delete one Auth_group_permissions.
     * @example
     * // Delete one Auth_group_permissions
     * const Auth_group_permissions = await prisma.auth_group_permissions.delete({
     *   where: {
     *     // ... filter to delete one Auth_group_permissions
     *   }
     * })
     * 
    **/
    delete<T extends auth_group_permissionsDeleteArgs>(
      args: SelectSubset<T, auth_group_permissionsDeleteArgs>
    ): Prisma__auth_group_permissionsClient<auth_group_permissionsGetPayload<T>>

    /**
     * Update one Auth_group_permissions.
     * @param {auth_group_permissionsUpdateArgs} args - Arguments to update one Auth_group_permissions.
     * @example
     * // Update one Auth_group_permissions
     * const auth_group_permissions = await prisma.auth_group_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends auth_group_permissionsUpdateArgs>(
      args: SelectSubset<T, auth_group_permissionsUpdateArgs>
    ): Prisma__auth_group_permissionsClient<auth_group_permissionsGetPayload<T>>

    /**
     * Delete zero or more Auth_group_permissions.
     * @param {auth_group_permissionsDeleteManyArgs} args - Arguments to filter Auth_group_permissions to delete.
     * @example
     * // Delete a few Auth_group_permissions
     * const { count } = await prisma.auth_group_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends auth_group_permissionsDeleteManyArgs>(
      args?: SelectSubset<T, auth_group_permissionsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_group_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_group_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auth_group_permissions
     * const auth_group_permissions = await prisma.auth_group_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends auth_group_permissionsUpdateManyArgs>(
      args: SelectSubset<T, auth_group_permissionsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auth_group_permissions.
     * @param {auth_group_permissionsUpsertArgs} args - Arguments to update or create a Auth_group_permissions.
     * @example
     * // Update or create a Auth_group_permissions
     * const auth_group_permissions = await prisma.auth_group_permissions.upsert({
     *   create: {
     *     // ... data to create a Auth_group_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth_group_permissions we want to update
     *   }
     * })
    **/
    upsert<T extends auth_group_permissionsUpsertArgs>(
      args: SelectSubset<T, auth_group_permissionsUpsertArgs>
    ): Prisma__auth_group_permissionsClient<auth_group_permissionsGetPayload<T>>

    /**
     * Count the number of Auth_group_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_group_permissionsCountArgs} args - Arguments to filter Auth_group_permissions to count.
     * @example
     * // Count the number of Auth_group_permissions
     * const count = await prisma.auth_group_permissions.count({
     *   where: {
     *     // ... the filter for the Auth_group_permissions we want to count
     *   }
     * })
    **/
    count<T extends auth_group_permissionsCountArgs>(
      args?: Subset<T, auth_group_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auth_group_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth_group_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_group_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auth_group_permissionsAggregateArgs>(args: Subset<T, Auth_group_permissionsAggregateArgs>): Prisma.PrismaPromise<GetAuth_group_permissionsAggregateType<T>>

    /**
     * Group by Auth_group_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_group_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Auth_group_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Auth_group_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: Auth_group_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Auth_group_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuth_group_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for auth_group_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__auth_group_permissionsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    auth_permission<T extends auth_permissionArgs= {}>(args?: Subset<T, auth_permissionArgs>): Prisma__auth_permissionClient<auth_permissionGetPayload<T> | Null>;

    auth_group<T extends auth_groupArgs= {}>(args?: Subset<T, auth_groupArgs>): Prisma__auth_groupClient<auth_groupGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * auth_group_permissions base type for findUnique actions
   */
  export type auth_group_permissionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the auth_group_permissions
     */
    select?: auth_group_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_group_permissionsInclude | null
    /**
     * Filter, which auth_group_permissions to fetch.
     */
    where: auth_group_permissionsWhereUniqueInput
  }

  /**
   * auth_group_permissions findUnique
   */
  export interface auth_group_permissionsFindUniqueArgs extends auth_group_permissionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auth_group_permissions findUniqueOrThrow
   */
  export type auth_group_permissionsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the auth_group_permissions
     */
    select?: auth_group_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_group_permissionsInclude | null
    /**
     * Filter, which auth_group_permissions to fetch.
     */
    where: auth_group_permissionsWhereUniqueInput
  }


  /**
   * auth_group_permissions base type for findFirst actions
   */
  export type auth_group_permissionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the auth_group_permissions
     */
    select?: auth_group_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_group_permissionsInclude | null
    /**
     * Filter, which auth_group_permissions to fetch.
     */
    where?: auth_group_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_group_permissions to fetch.
     */
    orderBy?: Enumerable<auth_group_permissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_group_permissions.
     */
    cursor?: auth_group_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_group_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_group_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_group_permissions.
     */
    distinct?: Enumerable<Auth_group_permissionsScalarFieldEnum>
  }

  /**
   * auth_group_permissions findFirst
   */
  export interface auth_group_permissionsFindFirstArgs extends auth_group_permissionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auth_group_permissions findFirstOrThrow
   */
  export type auth_group_permissionsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the auth_group_permissions
     */
    select?: auth_group_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_group_permissionsInclude | null
    /**
     * Filter, which auth_group_permissions to fetch.
     */
    where?: auth_group_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_group_permissions to fetch.
     */
    orderBy?: Enumerable<auth_group_permissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_group_permissions.
     */
    cursor?: auth_group_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_group_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_group_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_group_permissions.
     */
    distinct?: Enumerable<Auth_group_permissionsScalarFieldEnum>
  }


  /**
   * auth_group_permissions findMany
   */
  export type auth_group_permissionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the auth_group_permissions
     */
    select?: auth_group_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_group_permissionsInclude | null
    /**
     * Filter, which auth_group_permissions to fetch.
     */
    where?: auth_group_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_group_permissions to fetch.
     */
    orderBy?: Enumerable<auth_group_permissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auth_group_permissions.
     */
    cursor?: auth_group_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_group_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_group_permissions.
     */
    skip?: number
    distinct?: Enumerable<Auth_group_permissionsScalarFieldEnum>
  }


  /**
   * auth_group_permissions create
   */
  export type auth_group_permissionsCreateArgs = {
    /**
     * Select specific fields to fetch from the auth_group_permissions
     */
    select?: auth_group_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_group_permissionsInclude | null
    /**
     * The data needed to create a auth_group_permissions.
     */
    data: XOR<auth_group_permissionsCreateInput, auth_group_permissionsUncheckedCreateInput>
  }


  /**
   * auth_group_permissions createMany
   */
  export type auth_group_permissionsCreateManyArgs = {
    /**
     * The data used to create many auth_group_permissions.
     */
    data: Enumerable<auth_group_permissionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * auth_group_permissions update
   */
  export type auth_group_permissionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the auth_group_permissions
     */
    select?: auth_group_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_group_permissionsInclude | null
    /**
     * The data needed to update a auth_group_permissions.
     */
    data: XOR<auth_group_permissionsUpdateInput, auth_group_permissionsUncheckedUpdateInput>
    /**
     * Choose, which auth_group_permissions to update.
     */
    where: auth_group_permissionsWhereUniqueInput
  }


  /**
   * auth_group_permissions updateMany
   */
  export type auth_group_permissionsUpdateManyArgs = {
    /**
     * The data used to update auth_group_permissions.
     */
    data: XOR<auth_group_permissionsUpdateManyMutationInput, auth_group_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which auth_group_permissions to update
     */
    where?: auth_group_permissionsWhereInput
  }


  /**
   * auth_group_permissions upsert
   */
  export type auth_group_permissionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the auth_group_permissions
     */
    select?: auth_group_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_group_permissionsInclude | null
    /**
     * The filter to search for the auth_group_permissions to update in case it exists.
     */
    where: auth_group_permissionsWhereUniqueInput
    /**
     * In case the auth_group_permissions found by the `where` argument doesn't exist, create a new auth_group_permissions with this data.
     */
    create: XOR<auth_group_permissionsCreateInput, auth_group_permissionsUncheckedCreateInput>
    /**
     * In case the auth_group_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auth_group_permissionsUpdateInput, auth_group_permissionsUncheckedUpdateInput>
  }


  /**
   * auth_group_permissions delete
   */
  export type auth_group_permissionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the auth_group_permissions
     */
    select?: auth_group_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_group_permissionsInclude | null
    /**
     * Filter which auth_group_permissions to delete.
     */
    where: auth_group_permissionsWhereUniqueInput
  }


  /**
   * auth_group_permissions deleteMany
   */
  export type auth_group_permissionsDeleteManyArgs = {
    /**
     * Filter which auth_group_permissions to delete
     */
    where?: auth_group_permissionsWhereInput
  }


  /**
   * auth_group_permissions without action
   */
  export type auth_group_permissionsArgs = {
    /**
     * Select specific fields to fetch from the auth_group_permissions
     */
    select?: auth_group_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_group_permissionsInclude | null
  }



  /**
   * Model auth_permission
   */


  export type AggregateAuth_permission = {
    _count: Auth_permissionCountAggregateOutputType | null
    _avg: Auth_permissionAvgAggregateOutputType | null
    _sum: Auth_permissionSumAggregateOutputType | null
    _min: Auth_permissionMinAggregateOutputType | null
    _max: Auth_permissionMaxAggregateOutputType | null
  }

  export type Auth_permissionAvgAggregateOutputType = {
    id: number | null
    content_type_id: number | null
  }

  export type Auth_permissionSumAggregateOutputType = {
    id: number | null
    content_type_id: number | null
  }

  export type Auth_permissionMinAggregateOutputType = {
    id: number | null
    name: string | null
    content_type_id: number | null
    codename: string | null
  }

  export type Auth_permissionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    content_type_id: number | null
    codename: string | null
  }

  export type Auth_permissionCountAggregateOutputType = {
    id: number
    name: number
    content_type_id: number
    codename: number
    _all: number
  }


  export type Auth_permissionAvgAggregateInputType = {
    id?: true
    content_type_id?: true
  }

  export type Auth_permissionSumAggregateInputType = {
    id?: true
    content_type_id?: true
  }

  export type Auth_permissionMinAggregateInputType = {
    id?: true
    name?: true
    content_type_id?: true
    codename?: true
  }

  export type Auth_permissionMaxAggregateInputType = {
    id?: true
    name?: true
    content_type_id?: true
    codename?: true
  }

  export type Auth_permissionCountAggregateInputType = {
    id?: true
    name?: true
    content_type_id?: true
    codename?: true
    _all?: true
  }

  export type Auth_permissionAggregateArgs = {
    /**
     * Filter which auth_permission to aggregate.
     */
    where?: auth_permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_permissions to fetch.
     */
    orderBy?: Enumerable<auth_permissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auth_permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auth_permissions
    **/
    _count?: true | Auth_permissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Auth_permissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Auth_permissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auth_permissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auth_permissionMaxAggregateInputType
  }

  export type GetAuth_permissionAggregateType<T extends Auth_permissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth_permission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth_permission[P]>
      : GetScalarType<T[P], AggregateAuth_permission[P]>
  }




  export type Auth_permissionGroupByArgs = {
    where?: auth_permissionWhereInput
    orderBy?: Enumerable<auth_permissionOrderByWithAggregationInput>
    by: Auth_permissionScalarFieldEnum[]
    having?: auth_permissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auth_permissionCountAggregateInputType | true
    _avg?: Auth_permissionAvgAggregateInputType
    _sum?: Auth_permissionSumAggregateInputType
    _min?: Auth_permissionMinAggregateInputType
    _max?: Auth_permissionMaxAggregateInputType
  }


  export type Auth_permissionGroupByOutputType = {
    id: number
    name: string
    content_type_id: number
    codename: string
    _count: Auth_permissionCountAggregateOutputType | null
    _avg: Auth_permissionAvgAggregateOutputType | null
    _sum: Auth_permissionSumAggregateOutputType | null
    _min: Auth_permissionMinAggregateOutputType | null
    _max: Auth_permissionMaxAggregateOutputType | null
  }

  type GetAuth_permissionGroupByPayload<T extends Auth_permissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Auth_permissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auth_permissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auth_permissionGroupByOutputType[P]>
            : GetScalarType<T[P], Auth_permissionGroupByOutputType[P]>
        }
      >
    >


  export type auth_permissionSelect = {
    id?: boolean
    name?: boolean
    content_type_id?: boolean
    codename?: boolean
    auth_group_permissions?: boolean | auth_permission$auth_group_permissionsArgs
    django_content_type?: boolean | django_content_typeArgs
    auth_user_user_permissions?: boolean | auth_permission$auth_user_user_permissionsArgs
    _count?: boolean | Auth_permissionCountOutputTypeArgs
  }


  export type auth_permissionInclude = {
    auth_group_permissions?: boolean | auth_permission$auth_group_permissionsArgs
    django_content_type?: boolean | django_content_typeArgs
    auth_user_user_permissions?: boolean | auth_permission$auth_user_user_permissionsArgs
    _count?: boolean | Auth_permissionCountOutputTypeArgs
  }

  export type auth_permissionGetPayload<S extends boolean | null | undefined | auth_permissionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? auth_permission :
    S extends undefined ? never :
    S extends { include: any } & (auth_permissionArgs | auth_permissionFindManyArgs)
    ? auth_permission  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'auth_group_permissions' ? Array < auth_group_permissionsGetPayload<S['include'][P]>>  :
        P extends 'django_content_type' ? django_content_typeGetPayload<S['include'][P]> :
        P extends 'auth_user_user_permissions' ? Array < auth_user_user_permissionsGetPayload<S['include'][P]>>  :
        P extends '_count' ? Auth_permissionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (auth_permissionArgs | auth_permissionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'auth_group_permissions' ? Array < auth_group_permissionsGetPayload<S['select'][P]>>  :
        P extends 'django_content_type' ? django_content_typeGetPayload<S['select'][P]> :
        P extends 'auth_user_user_permissions' ? Array < auth_user_user_permissionsGetPayload<S['select'][P]>>  :
        P extends '_count' ? Auth_permissionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof auth_permission ? auth_permission[P] : never
  } 
      : auth_permission


  type auth_permissionCountArgs = 
    Omit<auth_permissionFindManyArgs, 'select' | 'include'> & {
      select?: Auth_permissionCountAggregateInputType | true
    }

  export interface auth_permissionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Auth_permission that matches the filter.
     * @param {auth_permissionFindUniqueArgs} args - Arguments to find a Auth_permission
     * @example
     * // Get one Auth_permission
     * const auth_permission = await prisma.auth_permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends auth_permissionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, auth_permissionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'auth_permission'> extends True ? Prisma__auth_permissionClient<auth_permissionGetPayload<T>> : Prisma__auth_permissionClient<auth_permissionGetPayload<T> | null, null>

    /**
     * Find one Auth_permission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {auth_permissionFindUniqueOrThrowArgs} args - Arguments to find a Auth_permission
     * @example
     * // Get one Auth_permission
     * const auth_permission = await prisma.auth_permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends auth_permissionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, auth_permissionFindUniqueOrThrowArgs>
    ): Prisma__auth_permissionClient<auth_permissionGetPayload<T>>

    /**
     * Find the first Auth_permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_permissionFindFirstArgs} args - Arguments to find a Auth_permission
     * @example
     * // Get one Auth_permission
     * const auth_permission = await prisma.auth_permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends auth_permissionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, auth_permissionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'auth_permission'> extends True ? Prisma__auth_permissionClient<auth_permissionGetPayload<T>> : Prisma__auth_permissionClient<auth_permissionGetPayload<T> | null, null>

    /**
     * Find the first Auth_permission that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_permissionFindFirstOrThrowArgs} args - Arguments to find a Auth_permission
     * @example
     * // Get one Auth_permission
     * const auth_permission = await prisma.auth_permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends auth_permissionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, auth_permissionFindFirstOrThrowArgs>
    ): Prisma__auth_permissionClient<auth_permissionGetPayload<T>>

    /**
     * Find zero or more Auth_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_permissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auth_permissions
     * const auth_permissions = await prisma.auth_permission.findMany()
     * 
     * // Get first 10 Auth_permissions
     * const auth_permissions = await prisma.auth_permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auth_permissionWithIdOnly = await prisma.auth_permission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends auth_permissionFindManyArgs>(
      args?: SelectSubset<T, auth_permissionFindManyArgs>
    ): Prisma.PrismaPromise<Array<auth_permissionGetPayload<T>>>

    /**
     * Create a Auth_permission.
     * @param {auth_permissionCreateArgs} args - Arguments to create a Auth_permission.
     * @example
     * // Create one Auth_permission
     * const Auth_permission = await prisma.auth_permission.create({
     *   data: {
     *     // ... data to create a Auth_permission
     *   }
     * })
     * 
    **/
    create<T extends auth_permissionCreateArgs>(
      args: SelectSubset<T, auth_permissionCreateArgs>
    ): Prisma__auth_permissionClient<auth_permissionGetPayload<T>>

    /**
     * Create many Auth_permissions.
     *     @param {auth_permissionCreateManyArgs} args - Arguments to create many Auth_permissions.
     *     @example
     *     // Create many Auth_permissions
     *     const auth_permission = await prisma.auth_permission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends auth_permissionCreateManyArgs>(
      args?: SelectSubset<T, auth_permissionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auth_permission.
     * @param {auth_permissionDeleteArgs} args - Arguments to delete one Auth_permission.
     * @example
     * // Delete one Auth_permission
     * const Auth_permission = await prisma.auth_permission.delete({
     *   where: {
     *     // ... filter to delete one Auth_permission
     *   }
     * })
     * 
    **/
    delete<T extends auth_permissionDeleteArgs>(
      args: SelectSubset<T, auth_permissionDeleteArgs>
    ): Prisma__auth_permissionClient<auth_permissionGetPayload<T>>

    /**
     * Update one Auth_permission.
     * @param {auth_permissionUpdateArgs} args - Arguments to update one Auth_permission.
     * @example
     * // Update one Auth_permission
     * const auth_permission = await prisma.auth_permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends auth_permissionUpdateArgs>(
      args: SelectSubset<T, auth_permissionUpdateArgs>
    ): Prisma__auth_permissionClient<auth_permissionGetPayload<T>>

    /**
     * Delete zero or more Auth_permissions.
     * @param {auth_permissionDeleteManyArgs} args - Arguments to filter Auth_permissions to delete.
     * @example
     * // Delete a few Auth_permissions
     * const { count } = await prisma.auth_permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends auth_permissionDeleteManyArgs>(
      args?: SelectSubset<T, auth_permissionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_permissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auth_permissions
     * const auth_permission = await prisma.auth_permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends auth_permissionUpdateManyArgs>(
      args: SelectSubset<T, auth_permissionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auth_permission.
     * @param {auth_permissionUpsertArgs} args - Arguments to update or create a Auth_permission.
     * @example
     * // Update or create a Auth_permission
     * const auth_permission = await prisma.auth_permission.upsert({
     *   create: {
     *     // ... data to create a Auth_permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth_permission we want to update
     *   }
     * })
    **/
    upsert<T extends auth_permissionUpsertArgs>(
      args: SelectSubset<T, auth_permissionUpsertArgs>
    ): Prisma__auth_permissionClient<auth_permissionGetPayload<T>>

    /**
     * Count the number of Auth_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_permissionCountArgs} args - Arguments to filter Auth_permissions to count.
     * @example
     * // Count the number of Auth_permissions
     * const count = await prisma.auth_permission.count({
     *   where: {
     *     // ... the filter for the Auth_permissions we want to count
     *   }
     * })
    **/
    count<T extends auth_permissionCountArgs>(
      args?: Subset<T, auth_permissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auth_permissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth_permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_permissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auth_permissionAggregateArgs>(args: Subset<T, Auth_permissionAggregateArgs>): Prisma.PrismaPromise<GetAuth_permissionAggregateType<T>>

    /**
     * Group by Auth_permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_permissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Auth_permissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Auth_permissionGroupByArgs['orderBy'] }
        : { orderBy?: Auth_permissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Auth_permissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuth_permissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for auth_permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__auth_permissionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    auth_group_permissions<T extends auth_permission$auth_group_permissionsArgs= {}>(args?: Subset<T, auth_permission$auth_group_permissionsArgs>): Prisma.PrismaPromise<Array<auth_group_permissionsGetPayload<T>>| Null>;

    django_content_type<T extends django_content_typeArgs= {}>(args?: Subset<T, django_content_typeArgs>): Prisma__django_content_typeClient<django_content_typeGetPayload<T> | Null>;

    auth_user_user_permissions<T extends auth_permission$auth_user_user_permissionsArgs= {}>(args?: Subset<T, auth_permission$auth_user_user_permissionsArgs>): Prisma.PrismaPromise<Array<auth_user_user_permissionsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * auth_permission base type for findUnique actions
   */
  export type auth_permissionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the auth_permission
     */
    select?: auth_permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_permissionInclude | null
    /**
     * Filter, which auth_permission to fetch.
     */
    where: auth_permissionWhereUniqueInput
  }

  /**
   * auth_permission findUnique
   */
  export interface auth_permissionFindUniqueArgs extends auth_permissionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auth_permission findUniqueOrThrow
   */
  export type auth_permissionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the auth_permission
     */
    select?: auth_permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_permissionInclude | null
    /**
     * Filter, which auth_permission to fetch.
     */
    where: auth_permissionWhereUniqueInput
  }


  /**
   * auth_permission base type for findFirst actions
   */
  export type auth_permissionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the auth_permission
     */
    select?: auth_permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_permissionInclude | null
    /**
     * Filter, which auth_permission to fetch.
     */
    where?: auth_permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_permissions to fetch.
     */
    orderBy?: Enumerable<auth_permissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_permissions.
     */
    cursor?: auth_permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_permissions.
     */
    distinct?: Enumerable<Auth_permissionScalarFieldEnum>
  }

  /**
   * auth_permission findFirst
   */
  export interface auth_permissionFindFirstArgs extends auth_permissionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auth_permission findFirstOrThrow
   */
  export type auth_permissionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the auth_permission
     */
    select?: auth_permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_permissionInclude | null
    /**
     * Filter, which auth_permission to fetch.
     */
    where?: auth_permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_permissions to fetch.
     */
    orderBy?: Enumerable<auth_permissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_permissions.
     */
    cursor?: auth_permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_permissions.
     */
    distinct?: Enumerable<Auth_permissionScalarFieldEnum>
  }


  /**
   * auth_permission findMany
   */
  export type auth_permissionFindManyArgs = {
    /**
     * Select specific fields to fetch from the auth_permission
     */
    select?: auth_permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_permissionInclude | null
    /**
     * Filter, which auth_permissions to fetch.
     */
    where?: auth_permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_permissions to fetch.
     */
    orderBy?: Enumerable<auth_permissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auth_permissions.
     */
    cursor?: auth_permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_permissions.
     */
    skip?: number
    distinct?: Enumerable<Auth_permissionScalarFieldEnum>
  }


  /**
   * auth_permission create
   */
  export type auth_permissionCreateArgs = {
    /**
     * Select specific fields to fetch from the auth_permission
     */
    select?: auth_permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_permissionInclude | null
    /**
     * The data needed to create a auth_permission.
     */
    data: XOR<auth_permissionCreateInput, auth_permissionUncheckedCreateInput>
  }


  /**
   * auth_permission createMany
   */
  export type auth_permissionCreateManyArgs = {
    /**
     * The data used to create many auth_permissions.
     */
    data: Enumerable<auth_permissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * auth_permission update
   */
  export type auth_permissionUpdateArgs = {
    /**
     * Select specific fields to fetch from the auth_permission
     */
    select?: auth_permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_permissionInclude | null
    /**
     * The data needed to update a auth_permission.
     */
    data: XOR<auth_permissionUpdateInput, auth_permissionUncheckedUpdateInput>
    /**
     * Choose, which auth_permission to update.
     */
    where: auth_permissionWhereUniqueInput
  }


  /**
   * auth_permission updateMany
   */
  export type auth_permissionUpdateManyArgs = {
    /**
     * The data used to update auth_permissions.
     */
    data: XOR<auth_permissionUpdateManyMutationInput, auth_permissionUncheckedUpdateManyInput>
    /**
     * Filter which auth_permissions to update
     */
    where?: auth_permissionWhereInput
  }


  /**
   * auth_permission upsert
   */
  export type auth_permissionUpsertArgs = {
    /**
     * Select specific fields to fetch from the auth_permission
     */
    select?: auth_permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_permissionInclude | null
    /**
     * The filter to search for the auth_permission to update in case it exists.
     */
    where: auth_permissionWhereUniqueInput
    /**
     * In case the auth_permission found by the `where` argument doesn't exist, create a new auth_permission with this data.
     */
    create: XOR<auth_permissionCreateInput, auth_permissionUncheckedCreateInput>
    /**
     * In case the auth_permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auth_permissionUpdateInput, auth_permissionUncheckedUpdateInput>
  }


  /**
   * auth_permission delete
   */
  export type auth_permissionDeleteArgs = {
    /**
     * Select specific fields to fetch from the auth_permission
     */
    select?: auth_permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_permissionInclude | null
    /**
     * Filter which auth_permission to delete.
     */
    where: auth_permissionWhereUniqueInput
  }


  /**
   * auth_permission deleteMany
   */
  export type auth_permissionDeleteManyArgs = {
    /**
     * Filter which auth_permissions to delete
     */
    where?: auth_permissionWhereInput
  }


  /**
   * auth_permission.auth_group_permissions
   */
  export type auth_permission$auth_group_permissionsArgs = {
    /**
     * Select specific fields to fetch from the auth_group_permissions
     */
    select?: auth_group_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_group_permissionsInclude | null
    where?: auth_group_permissionsWhereInput
    orderBy?: Enumerable<auth_group_permissionsOrderByWithRelationInput>
    cursor?: auth_group_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Auth_group_permissionsScalarFieldEnum>
  }


  /**
   * auth_permission.auth_user_user_permissions
   */
  export type auth_permission$auth_user_user_permissionsArgs = {
    /**
     * Select specific fields to fetch from the auth_user_user_permissions
     */
    select?: auth_user_user_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_user_permissionsInclude | null
    where?: auth_user_user_permissionsWhereInput
    orderBy?: Enumerable<auth_user_user_permissionsOrderByWithRelationInput>
    cursor?: auth_user_user_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Auth_user_user_permissionsScalarFieldEnum>
  }


  /**
   * auth_permission without action
   */
  export type auth_permissionArgs = {
    /**
     * Select specific fields to fetch from the auth_permission
     */
    select?: auth_permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_permissionInclude | null
  }



  /**
   * Model auth_user
   */


  export type AggregateAuth_user = {
    _count: Auth_userCountAggregateOutputType | null
    _avg: Auth_userAvgAggregateOutputType | null
    _sum: Auth_userSumAggregateOutputType | null
    _min: Auth_userMinAggregateOutputType | null
    _max: Auth_userMaxAggregateOutputType | null
  }

  export type Auth_userAvgAggregateOutputType = {
    id: number | null
  }

  export type Auth_userSumAggregateOutputType = {
    id: number | null
  }

  export type Auth_userMinAggregateOutputType = {
    id: number | null
    password: string | null
    last_login: Date | null
    is_superuser: boolean | null
    username: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    is_staff: boolean | null
    is_active: boolean | null
    date_joined: Date | null
  }

  export type Auth_userMaxAggregateOutputType = {
    id: number | null
    password: string | null
    last_login: Date | null
    is_superuser: boolean | null
    username: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    is_staff: boolean | null
    is_active: boolean | null
    date_joined: Date | null
  }

  export type Auth_userCountAggregateOutputType = {
    id: number
    password: number
    last_login: number
    is_superuser: number
    username: number
    first_name: number
    last_name: number
    email: number
    is_staff: number
    is_active: number
    date_joined: number
    _all: number
  }


  export type Auth_userAvgAggregateInputType = {
    id?: true
  }

  export type Auth_userSumAggregateInputType = {
    id?: true
  }

  export type Auth_userMinAggregateInputType = {
    id?: true
    password?: true
    last_login?: true
    is_superuser?: true
    username?: true
    first_name?: true
    last_name?: true
    email?: true
    is_staff?: true
    is_active?: true
    date_joined?: true
  }

  export type Auth_userMaxAggregateInputType = {
    id?: true
    password?: true
    last_login?: true
    is_superuser?: true
    username?: true
    first_name?: true
    last_name?: true
    email?: true
    is_staff?: true
    is_active?: true
    date_joined?: true
  }

  export type Auth_userCountAggregateInputType = {
    id?: true
    password?: true
    last_login?: true
    is_superuser?: true
    username?: true
    first_name?: true
    last_name?: true
    email?: true
    is_staff?: true
    is_active?: true
    date_joined?: true
    _all?: true
  }

  export type Auth_userAggregateArgs = {
    /**
     * Filter which auth_user to aggregate.
     */
    where?: auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_users to fetch.
     */
    orderBy?: Enumerable<auth_userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auth_users
    **/
    _count?: true | Auth_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Auth_userAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Auth_userSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auth_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auth_userMaxAggregateInputType
  }

  export type GetAuth_userAggregateType<T extends Auth_userAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth_user[P]>
      : GetScalarType<T[P], AggregateAuth_user[P]>
  }




  export type Auth_userGroupByArgs = {
    where?: auth_userWhereInput
    orderBy?: Enumerable<auth_userOrderByWithAggregationInput>
    by: Auth_userScalarFieldEnum[]
    having?: auth_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auth_userCountAggregateInputType | true
    _avg?: Auth_userAvgAggregateInputType
    _sum?: Auth_userSumAggregateInputType
    _min?: Auth_userMinAggregateInputType
    _max?: Auth_userMaxAggregateInputType
  }


  export type Auth_userGroupByOutputType = {
    id: number
    password: string
    last_login: Date | null
    is_superuser: boolean
    username: string
    first_name: string
    last_name: string
    email: string
    is_staff: boolean
    is_active: boolean
    date_joined: Date
    _count: Auth_userCountAggregateOutputType | null
    _avg: Auth_userAvgAggregateOutputType | null
    _sum: Auth_userSumAggregateOutputType | null
    _min: Auth_userMinAggregateOutputType | null
    _max: Auth_userMaxAggregateOutputType | null
  }

  type GetAuth_userGroupByPayload<T extends Auth_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Auth_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auth_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auth_userGroupByOutputType[P]>
            : GetScalarType<T[P], Auth_userGroupByOutputType[P]>
        }
      >
    >


  export type auth_userSelect = {
    id?: boolean
    password?: boolean
    last_login?: boolean
    is_superuser?: boolean
    username?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    is_staff?: boolean
    is_active?: boolean
    date_joined?: boolean
    auth_user_groups?: boolean | auth_user$auth_user_groupsArgs
    auth_user_user_permissions?: boolean | auth_user$auth_user_user_permissionsArgs
    django_admin_log?: boolean | auth_user$django_admin_logArgs
    _count?: boolean | Auth_userCountOutputTypeArgs
  }


  export type auth_userInclude = {
    auth_user_groups?: boolean | auth_user$auth_user_groupsArgs
    auth_user_user_permissions?: boolean | auth_user$auth_user_user_permissionsArgs
    django_admin_log?: boolean | auth_user$django_admin_logArgs
    _count?: boolean | Auth_userCountOutputTypeArgs
  }

  export type auth_userGetPayload<S extends boolean | null | undefined | auth_userArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? auth_user :
    S extends undefined ? never :
    S extends { include: any } & (auth_userArgs | auth_userFindManyArgs)
    ? auth_user  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'auth_user_groups' ? Array < auth_user_groupsGetPayload<S['include'][P]>>  :
        P extends 'auth_user_user_permissions' ? Array < auth_user_user_permissionsGetPayload<S['include'][P]>>  :
        P extends 'django_admin_log' ? Array < django_admin_logGetPayload<S['include'][P]>>  :
        P extends '_count' ? Auth_userCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (auth_userArgs | auth_userFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'auth_user_groups' ? Array < auth_user_groupsGetPayload<S['select'][P]>>  :
        P extends 'auth_user_user_permissions' ? Array < auth_user_user_permissionsGetPayload<S['select'][P]>>  :
        P extends 'django_admin_log' ? Array < django_admin_logGetPayload<S['select'][P]>>  :
        P extends '_count' ? Auth_userCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof auth_user ? auth_user[P] : never
  } 
      : auth_user


  type auth_userCountArgs = 
    Omit<auth_userFindManyArgs, 'select' | 'include'> & {
      select?: Auth_userCountAggregateInputType | true
    }

  export interface auth_userDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Auth_user that matches the filter.
     * @param {auth_userFindUniqueArgs} args - Arguments to find a Auth_user
     * @example
     * // Get one Auth_user
     * const auth_user = await prisma.auth_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends auth_userFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, auth_userFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'auth_user'> extends True ? Prisma__auth_userClient<auth_userGetPayload<T>> : Prisma__auth_userClient<auth_userGetPayload<T> | null, null>

    /**
     * Find one Auth_user that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {auth_userFindUniqueOrThrowArgs} args - Arguments to find a Auth_user
     * @example
     * // Get one Auth_user
     * const auth_user = await prisma.auth_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends auth_userFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, auth_userFindUniqueOrThrowArgs>
    ): Prisma__auth_userClient<auth_userGetPayload<T>>

    /**
     * Find the first Auth_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userFindFirstArgs} args - Arguments to find a Auth_user
     * @example
     * // Get one Auth_user
     * const auth_user = await prisma.auth_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends auth_userFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, auth_userFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'auth_user'> extends True ? Prisma__auth_userClient<auth_userGetPayload<T>> : Prisma__auth_userClient<auth_userGetPayload<T> | null, null>

    /**
     * Find the first Auth_user that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userFindFirstOrThrowArgs} args - Arguments to find a Auth_user
     * @example
     * // Get one Auth_user
     * const auth_user = await prisma.auth_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends auth_userFindFirstOrThrowArgs>(
      args?: SelectSubset<T, auth_userFindFirstOrThrowArgs>
    ): Prisma__auth_userClient<auth_userGetPayload<T>>

    /**
     * Find zero or more Auth_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auth_users
     * const auth_users = await prisma.auth_user.findMany()
     * 
     * // Get first 10 Auth_users
     * const auth_users = await prisma.auth_user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auth_userWithIdOnly = await prisma.auth_user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends auth_userFindManyArgs>(
      args?: SelectSubset<T, auth_userFindManyArgs>
    ): Prisma.PrismaPromise<Array<auth_userGetPayload<T>>>

    /**
     * Create a Auth_user.
     * @param {auth_userCreateArgs} args - Arguments to create a Auth_user.
     * @example
     * // Create one Auth_user
     * const Auth_user = await prisma.auth_user.create({
     *   data: {
     *     // ... data to create a Auth_user
     *   }
     * })
     * 
    **/
    create<T extends auth_userCreateArgs>(
      args: SelectSubset<T, auth_userCreateArgs>
    ): Prisma__auth_userClient<auth_userGetPayload<T>>

    /**
     * Create many Auth_users.
     *     @param {auth_userCreateManyArgs} args - Arguments to create many Auth_users.
     *     @example
     *     // Create many Auth_users
     *     const auth_user = await prisma.auth_user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends auth_userCreateManyArgs>(
      args?: SelectSubset<T, auth_userCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auth_user.
     * @param {auth_userDeleteArgs} args - Arguments to delete one Auth_user.
     * @example
     * // Delete one Auth_user
     * const Auth_user = await prisma.auth_user.delete({
     *   where: {
     *     // ... filter to delete one Auth_user
     *   }
     * })
     * 
    **/
    delete<T extends auth_userDeleteArgs>(
      args: SelectSubset<T, auth_userDeleteArgs>
    ): Prisma__auth_userClient<auth_userGetPayload<T>>

    /**
     * Update one Auth_user.
     * @param {auth_userUpdateArgs} args - Arguments to update one Auth_user.
     * @example
     * // Update one Auth_user
     * const auth_user = await prisma.auth_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends auth_userUpdateArgs>(
      args: SelectSubset<T, auth_userUpdateArgs>
    ): Prisma__auth_userClient<auth_userGetPayload<T>>

    /**
     * Delete zero or more Auth_users.
     * @param {auth_userDeleteManyArgs} args - Arguments to filter Auth_users to delete.
     * @example
     * // Delete a few Auth_users
     * const { count } = await prisma.auth_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends auth_userDeleteManyArgs>(
      args?: SelectSubset<T, auth_userDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auth_users
     * const auth_user = await prisma.auth_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends auth_userUpdateManyArgs>(
      args: SelectSubset<T, auth_userUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auth_user.
     * @param {auth_userUpsertArgs} args - Arguments to update or create a Auth_user.
     * @example
     * // Update or create a Auth_user
     * const auth_user = await prisma.auth_user.upsert({
     *   create: {
     *     // ... data to create a Auth_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth_user we want to update
     *   }
     * })
    **/
    upsert<T extends auth_userUpsertArgs>(
      args: SelectSubset<T, auth_userUpsertArgs>
    ): Prisma__auth_userClient<auth_userGetPayload<T>>

    /**
     * Count the number of Auth_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userCountArgs} args - Arguments to filter Auth_users to count.
     * @example
     * // Count the number of Auth_users
     * const count = await prisma.auth_user.count({
     *   where: {
     *     // ... the filter for the Auth_users we want to count
     *   }
     * })
    **/
    count<T extends auth_userCountArgs>(
      args?: Subset<T, auth_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auth_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auth_userAggregateArgs>(args: Subset<T, Auth_userAggregateArgs>): Prisma.PrismaPromise<GetAuth_userAggregateType<T>>

    /**
     * Group by Auth_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Auth_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Auth_userGroupByArgs['orderBy'] }
        : { orderBy?: Auth_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Auth_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuth_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for auth_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__auth_userClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    auth_user_groups<T extends auth_user$auth_user_groupsArgs= {}>(args?: Subset<T, auth_user$auth_user_groupsArgs>): Prisma.PrismaPromise<Array<auth_user_groupsGetPayload<T>>| Null>;

    auth_user_user_permissions<T extends auth_user$auth_user_user_permissionsArgs= {}>(args?: Subset<T, auth_user$auth_user_user_permissionsArgs>): Prisma.PrismaPromise<Array<auth_user_user_permissionsGetPayload<T>>| Null>;

    django_admin_log<T extends auth_user$django_admin_logArgs= {}>(args?: Subset<T, auth_user$django_admin_logArgs>): Prisma.PrismaPromise<Array<django_admin_logGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * auth_user base type for findUnique actions
   */
  export type auth_userFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude | null
    /**
     * Filter, which auth_user to fetch.
     */
    where: auth_userWhereUniqueInput
  }

  /**
   * auth_user findUnique
   */
  export interface auth_userFindUniqueArgs extends auth_userFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auth_user findUniqueOrThrow
   */
  export type auth_userFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude | null
    /**
     * Filter, which auth_user to fetch.
     */
    where: auth_userWhereUniqueInput
  }


  /**
   * auth_user base type for findFirst actions
   */
  export type auth_userFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude | null
    /**
     * Filter, which auth_user to fetch.
     */
    where?: auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_users to fetch.
     */
    orderBy?: Enumerable<auth_userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_users.
     */
    cursor?: auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_users.
     */
    distinct?: Enumerable<Auth_userScalarFieldEnum>
  }

  /**
   * auth_user findFirst
   */
  export interface auth_userFindFirstArgs extends auth_userFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auth_user findFirstOrThrow
   */
  export type auth_userFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude | null
    /**
     * Filter, which auth_user to fetch.
     */
    where?: auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_users to fetch.
     */
    orderBy?: Enumerable<auth_userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_users.
     */
    cursor?: auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_users.
     */
    distinct?: Enumerable<Auth_userScalarFieldEnum>
  }


  /**
   * auth_user findMany
   */
  export type auth_userFindManyArgs = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude | null
    /**
     * Filter, which auth_users to fetch.
     */
    where?: auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_users to fetch.
     */
    orderBy?: Enumerable<auth_userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auth_users.
     */
    cursor?: auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_users.
     */
    skip?: number
    distinct?: Enumerable<Auth_userScalarFieldEnum>
  }


  /**
   * auth_user create
   */
  export type auth_userCreateArgs = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude | null
    /**
     * The data needed to create a auth_user.
     */
    data: XOR<auth_userCreateInput, auth_userUncheckedCreateInput>
  }


  /**
   * auth_user createMany
   */
  export type auth_userCreateManyArgs = {
    /**
     * The data used to create many auth_users.
     */
    data: Enumerable<auth_userCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * auth_user update
   */
  export type auth_userUpdateArgs = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude | null
    /**
     * The data needed to update a auth_user.
     */
    data: XOR<auth_userUpdateInput, auth_userUncheckedUpdateInput>
    /**
     * Choose, which auth_user to update.
     */
    where: auth_userWhereUniqueInput
  }


  /**
   * auth_user updateMany
   */
  export type auth_userUpdateManyArgs = {
    /**
     * The data used to update auth_users.
     */
    data: XOR<auth_userUpdateManyMutationInput, auth_userUncheckedUpdateManyInput>
    /**
     * Filter which auth_users to update
     */
    where?: auth_userWhereInput
  }


  /**
   * auth_user upsert
   */
  export type auth_userUpsertArgs = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude | null
    /**
     * The filter to search for the auth_user to update in case it exists.
     */
    where: auth_userWhereUniqueInput
    /**
     * In case the auth_user found by the `where` argument doesn't exist, create a new auth_user with this data.
     */
    create: XOR<auth_userCreateInput, auth_userUncheckedCreateInput>
    /**
     * In case the auth_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auth_userUpdateInput, auth_userUncheckedUpdateInput>
  }


  /**
   * auth_user delete
   */
  export type auth_userDeleteArgs = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude | null
    /**
     * Filter which auth_user to delete.
     */
    where: auth_userWhereUniqueInput
  }


  /**
   * auth_user deleteMany
   */
  export type auth_userDeleteManyArgs = {
    /**
     * Filter which auth_users to delete
     */
    where?: auth_userWhereInput
  }


  /**
   * auth_user.auth_user_groups
   */
  export type auth_user$auth_user_groupsArgs = {
    /**
     * Select specific fields to fetch from the auth_user_groups
     */
    select?: auth_user_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_groupsInclude | null
    where?: auth_user_groupsWhereInput
    orderBy?: Enumerable<auth_user_groupsOrderByWithRelationInput>
    cursor?: auth_user_groupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Auth_user_groupsScalarFieldEnum>
  }


  /**
   * auth_user.auth_user_user_permissions
   */
  export type auth_user$auth_user_user_permissionsArgs = {
    /**
     * Select specific fields to fetch from the auth_user_user_permissions
     */
    select?: auth_user_user_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_user_permissionsInclude | null
    where?: auth_user_user_permissionsWhereInput
    orderBy?: Enumerable<auth_user_user_permissionsOrderByWithRelationInput>
    cursor?: auth_user_user_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Auth_user_user_permissionsScalarFieldEnum>
  }


  /**
   * auth_user.django_admin_log
   */
  export type auth_user$django_admin_logArgs = {
    /**
     * Select specific fields to fetch from the django_admin_log
     */
    select?: django_admin_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_admin_logInclude | null
    where?: django_admin_logWhereInput
    orderBy?: Enumerable<django_admin_logOrderByWithRelationInput>
    cursor?: django_admin_logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Django_admin_logScalarFieldEnum>
  }


  /**
   * auth_user without action
   */
  export type auth_userArgs = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_userInclude | null
  }



  /**
   * Model auth_user_groups
   */


  export type AggregateAuth_user_groups = {
    _count: Auth_user_groupsCountAggregateOutputType | null
    _avg: Auth_user_groupsAvgAggregateOutputType | null
    _sum: Auth_user_groupsSumAggregateOutputType | null
    _min: Auth_user_groupsMinAggregateOutputType | null
    _max: Auth_user_groupsMaxAggregateOutputType | null
  }

  export type Auth_user_groupsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    group_id: number | null
  }

  export type Auth_user_groupsSumAggregateOutputType = {
    id: bigint | null
    user_id: number | null
    group_id: number | null
  }

  export type Auth_user_groupsMinAggregateOutputType = {
    id: bigint | null
    user_id: number | null
    group_id: number | null
  }

  export type Auth_user_groupsMaxAggregateOutputType = {
    id: bigint | null
    user_id: number | null
    group_id: number | null
  }

  export type Auth_user_groupsCountAggregateOutputType = {
    id: number
    user_id: number
    group_id: number
    _all: number
  }


  export type Auth_user_groupsAvgAggregateInputType = {
    id?: true
    user_id?: true
    group_id?: true
  }

  export type Auth_user_groupsSumAggregateInputType = {
    id?: true
    user_id?: true
    group_id?: true
  }

  export type Auth_user_groupsMinAggregateInputType = {
    id?: true
    user_id?: true
    group_id?: true
  }

  export type Auth_user_groupsMaxAggregateInputType = {
    id?: true
    user_id?: true
    group_id?: true
  }

  export type Auth_user_groupsCountAggregateInputType = {
    id?: true
    user_id?: true
    group_id?: true
    _all?: true
  }

  export type Auth_user_groupsAggregateArgs = {
    /**
     * Filter which auth_user_groups to aggregate.
     */
    where?: auth_user_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_user_groups to fetch.
     */
    orderBy?: Enumerable<auth_user_groupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auth_user_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_user_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_user_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auth_user_groups
    **/
    _count?: true | Auth_user_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Auth_user_groupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Auth_user_groupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auth_user_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auth_user_groupsMaxAggregateInputType
  }

  export type GetAuth_user_groupsAggregateType<T extends Auth_user_groupsAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth_user_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth_user_groups[P]>
      : GetScalarType<T[P], AggregateAuth_user_groups[P]>
  }




  export type Auth_user_groupsGroupByArgs = {
    where?: auth_user_groupsWhereInput
    orderBy?: Enumerable<auth_user_groupsOrderByWithAggregationInput>
    by: Auth_user_groupsScalarFieldEnum[]
    having?: auth_user_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auth_user_groupsCountAggregateInputType | true
    _avg?: Auth_user_groupsAvgAggregateInputType
    _sum?: Auth_user_groupsSumAggregateInputType
    _min?: Auth_user_groupsMinAggregateInputType
    _max?: Auth_user_groupsMaxAggregateInputType
  }


  export type Auth_user_groupsGroupByOutputType = {
    id: bigint
    user_id: number
    group_id: number
    _count: Auth_user_groupsCountAggregateOutputType | null
    _avg: Auth_user_groupsAvgAggregateOutputType | null
    _sum: Auth_user_groupsSumAggregateOutputType | null
    _min: Auth_user_groupsMinAggregateOutputType | null
    _max: Auth_user_groupsMaxAggregateOutputType | null
  }

  type GetAuth_user_groupsGroupByPayload<T extends Auth_user_groupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Auth_user_groupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auth_user_groupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auth_user_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], Auth_user_groupsGroupByOutputType[P]>
        }
      >
    >


  export type auth_user_groupsSelect = {
    id?: boolean
    user_id?: boolean
    group_id?: boolean
    auth_group?: boolean | auth_groupArgs
    auth_user?: boolean | auth_userArgs
  }


  export type auth_user_groupsInclude = {
    auth_group?: boolean | auth_groupArgs
    auth_user?: boolean | auth_userArgs
  }

  export type auth_user_groupsGetPayload<S extends boolean | null | undefined | auth_user_groupsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? auth_user_groups :
    S extends undefined ? never :
    S extends { include: any } & (auth_user_groupsArgs | auth_user_groupsFindManyArgs)
    ? auth_user_groups  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'auth_group' ? auth_groupGetPayload<S['include'][P]> :
        P extends 'auth_user' ? auth_userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (auth_user_groupsArgs | auth_user_groupsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'auth_group' ? auth_groupGetPayload<S['select'][P]> :
        P extends 'auth_user' ? auth_userGetPayload<S['select'][P]> :  P extends keyof auth_user_groups ? auth_user_groups[P] : never
  } 
      : auth_user_groups


  type auth_user_groupsCountArgs = 
    Omit<auth_user_groupsFindManyArgs, 'select' | 'include'> & {
      select?: Auth_user_groupsCountAggregateInputType | true
    }

  export interface auth_user_groupsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Auth_user_groups that matches the filter.
     * @param {auth_user_groupsFindUniqueArgs} args - Arguments to find a Auth_user_groups
     * @example
     * // Get one Auth_user_groups
     * const auth_user_groups = await prisma.auth_user_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends auth_user_groupsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, auth_user_groupsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'auth_user_groups'> extends True ? Prisma__auth_user_groupsClient<auth_user_groupsGetPayload<T>> : Prisma__auth_user_groupsClient<auth_user_groupsGetPayload<T> | null, null>

    /**
     * Find one Auth_user_groups that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {auth_user_groupsFindUniqueOrThrowArgs} args - Arguments to find a Auth_user_groups
     * @example
     * // Get one Auth_user_groups
     * const auth_user_groups = await prisma.auth_user_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends auth_user_groupsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, auth_user_groupsFindUniqueOrThrowArgs>
    ): Prisma__auth_user_groupsClient<auth_user_groupsGetPayload<T>>

    /**
     * Find the first Auth_user_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_user_groupsFindFirstArgs} args - Arguments to find a Auth_user_groups
     * @example
     * // Get one Auth_user_groups
     * const auth_user_groups = await prisma.auth_user_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends auth_user_groupsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, auth_user_groupsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'auth_user_groups'> extends True ? Prisma__auth_user_groupsClient<auth_user_groupsGetPayload<T>> : Prisma__auth_user_groupsClient<auth_user_groupsGetPayload<T> | null, null>

    /**
     * Find the first Auth_user_groups that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_user_groupsFindFirstOrThrowArgs} args - Arguments to find a Auth_user_groups
     * @example
     * // Get one Auth_user_groups
     * const auth_user_groups = await prisma.auth_user_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends auth_user_groupsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, auth_user_groupsFindFirstOrThrowArgs>
    ): Prisma__auth_user_groupsClient<auth_user_groupsGetPayload<T>>

    /**
     * Find zero or more Auth_user_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_user_groupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auth_user_groups
     * const auth_user_groups = await prisma.auth_user_groups.findMany()
     * 
     * // Get first 10 Auth_user_groups
     * const auth_user_groups = await prisma.auth_user_groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auth_user_groupsWithIdOnly = await prisma.auth_user_groups.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends auth_user_groupsFindManyArgs>(
      args?: SelectSubset<T, auth_user_groupsFindManyArgs>
    ): Prisma.PrismaPromise<Array<auth_user_groupsGetPayload<T>>>

    /**
     * Create a Auth_user_groups.
     * @param {auth_user_groupsCreateArgs} args - Arguments to create a Auth_user_groups.
     * @example
     * // Create one Auth_user_groups
     * const Auth_user_groups = await prisma.auth_user_groups.create({
     *   data: {
     *     // ... data to create a Auth_user_groups
     *   }
     * })
     * 
    **/
    create<T extends auth_user_groupsCreateArgs>(
      args: SelectSubset<T, auth_user_groupsCreateArgs>
    ): Prisma__auth_user_groupsClient<auth_user_groupsGetPayload<T>>

    /**
     * Create many Auth_user_groups.
     *     @param {auth_user_groupsCreateManyArgs} args - Arguments to create many Auth_user_groups.
     *     @example
     *     // Create many Auth_user_groups
     *     const auth_user_groups = await prisma.auth_user_groups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends auth_user_groupsCreateManyArgs>(
      args?: SelectSubset<T, auth_user_groupsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auth_user_groups.
     * @param {auth_user_groupsDeleteArgs} args - Arguments to delete one Auth_user_groups.
     * @example
     * // Delete one Auth_user_groups
     * const Auth_user_groups = await prisma.auth_user_groups.delete({
     *   where: {
     *     // ... filter to delete one Auth_user_groups
     *   }
     * })
     * 
    **/
    delete<T extends auth_user_groupsDeleteArgs>(
      args: SelectSubset<T, auth_user_groupsDeleteArgs>
    ): Prisma__auth_user_groupsClient<auth_user_groupsGetPayload<T>>

    /**
     * Update one Auth_user_groups.
     * @param {auth_user_groupsUpdateArgs} args - Arguments to update one Auth_user_groups.
     * @example
     * // Update one Auth_user_groups
     * const auth_user_groups = await prisma.auth_user_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends auth_user_groupsUpdateArgs>(
      args: SelectSubset<T, auth_user_groupsUpdateArgs>
    ): Prisma__auth_user_groupsClient<auth_user_groupsGetPayload<T>>

    /**
     * Delete zero or more Auth_user_groups.
     * @param {auth_user_groupsDeleteManyArgs} args - Arguments to filter Auth_user_groups to delete.
     * @example
     * // Delete a few Auth_user_groups
     * const { count } = await prisma.auth_user_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends auth_user_groupsDeleteManyArgs>(
      args?: SelectSubset<T, auth_user_groupsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_user_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_user_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auth_user_groups
     * const auth_user_groups = await prisma.auth_user_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends auth_user_groupsUpdateManyArgs>(
      args: SelectSubset<T, auth_user_groupsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auth_user_groups.
     * @param {auth_user_groupsUpsertArgs} args - Arguments to update or create a Auth_user_groups.
     * @example
     * // Update or create a Auth_user_groups
     * const auth_user_groups = await prisma.auth_user_groups.upsert({
     *   create: {
     *     // ... data to create a Auth_user_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth_user_groups we want to update
     *   }
     * })
    **/
    upsert<T extends auth_user_groupsUpsertArgs>(
      args: SelectSubset<T, auth_user_groupsUpsertArgs>
    ): Prisma__auth_user_groupsClient<auth_user_groupsGetPayload<T>>

    /**
     * Count the number of Auth_user_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_user_groupsCountArgs} args - Arguments to filter Auth_user_groups to count.
     * @example
     * // Count the number of Auth_user_groups
     * const count = await prisma.auth_user_groups.count({
     *   where: {
     *     // ... the filter for the Auth_user_groups we want to count
     *   }
     * })
    **/
    count<T extends auth_user_groupsCountArgs>(
      args?: Subset<T, auth_user_groupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auth_user_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth_user_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_user_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auth_user_groupsAggregateArgs>(args: Subset<T, Auth_user_groupsAggregateArgs>): Prisma.PrismaPromise<GetAuth_user_groupsAggregateType<T>>

    /**
     * Group by Auth_user_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_user_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Auth_user_groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Auth_user_groupsGroupByArgs['orderBy'] }
        : { orderBy?: Auth_user_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Auth_user_groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuth_user_groupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for auth_user_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__auth_user_groupsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    auth_group<T extends auth_groupArgs= {}>(args?: Subset<T, auth_groupArgs>): Prisma__auth_groupClient<auth_groupGetPayload<T> | Null>;

    auth_user<T extends auth_userArgs= {}>(args?: Subset<T, auth_userArgs>): Prisma__auth_userClient<auth_userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * auth_user_groups base type for findUnique actions
   */
  export type auth_user_groupsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the auth_user_groups
     */
    select?: auth_user_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_groupsInclude | null
    /**
     * Filter, which auth_user_groups to fetch.
     */
    where: auth_user_groupsWhereUniqueInput
  }

  /**
   * auth_user_groups findUnique
   */
  export interface auth_user_groupsFindUniqueArgs extends auth_user_groupsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auth_user_groups findUniqueOrThrow
   */
  export type auth_user_groupsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the auth_user_groups
     */
    select?: auth_user_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_groupsInclude | null
    /**
     * Filter, which auth_user_groups to fetch.
     */
    where: auth_user_groupsWhereUniqueInput
  }


  /**
   * auth_user_groups base type for findFirst actions
   */
  export type auth_user_groupsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the auth_user_groups
     */
    select?: auth_user_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_groupsInclude | null
    /**
     * Filter, which auth_user_groups to fetch.
     */
    where?: auth_user_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_user_groups to fetch.
     */
    orderBy?: Enumerable<auth_user_groupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_user_groups.
     */
    cursor?: auth_user_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_user_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_user_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_user_groups.
     */
    distinct?: Enumerable<Auth_user_groupsScalarFieldEnum>
  }

  /**
   * auth_user_groups findFirst
   */
  export interface auth_user_groupsFindFirstArgs extends auth_user_groupsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auth_user_groups findFirstOrThrow
   */
  export type auth_user_groupsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the auth_user_groups
     */
    select?: auth_user_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_groupsInclude | null
    /**
     * Filter, which auth_user_groups to fetch.
     */
    where?: auth_user_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_user_groups to fetch.
     */
    orderBy?: Enumerable<auth_user_groupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_user_groups.
     */
    cursor?: auth_user_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_user_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_user_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_user_groups.
     */
    distinct?: Enumerable<Auth_user_groupsScalarFieldEnum>
  }


  /**
   * auth_user_groups findMany
   */
  export type auth_user_groupsFindManyArgs = {
    /**
     * Select specific fields to fetch from the auth_user_groups
     */
    select?: auth_user_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_groupsInclude | null
    /**
     * Filter, which auth_user_groups to fetch.
     */
    where?: auth_user_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_user_groups to fetch.
     */
    orderBy?: Enumerable<auth_user_groupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auth_user_groups.
     */
    cursor?: auth_user_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_user_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_user_groups.
     */
    skip?: number
    distinct?: Enumerable<Auth_user_groupsScalarFieldEnum>
  }


  /**
   * auth_user_groups create
   */
  export type auth_user_groupsCreateArgs = {
    /**
     * Select specific fields to fetch from the auth_user_groups
     */
    select?: auth_user_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_groupsInclude | null
    /**
     * The data needed to create a auth_user_groups.
     */
    data: XOR<auth_user_groupsCreateInput, auth_user_groupsUncheckedCreateInput>
  }


  /**
   * auth_user_groups createMany
   */
  export type auth_user_groupsCreateManyArgs = {
    /**
     * The data used to create many auth_user_groups.
     */
    data: Enumerable<auth_user_groupsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * auth_user_groups update
   */
  export type auth_user_groupsUpdateArgs = {
    /**
     * Select specific fields to fetch from the auth_user_groups
     */
    select?: auth_user_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_groupsInclude | null
    /**
     * The data needed to update a auth_user_groups.
     */
    data: XOR<auth_user_groupsUpdateInput, auth_user_groupsUncheckedUpdateInput>
    /**
     * Choose, which auth_user_groups to update.
     */
    where: auth_user_groupsWhereUniqueInput
  }


  /**
   * auth_user_groups updateMany
   */
  export type auth_user_groupsUpdateManyArgs = {
    /**
     * The data used to update auth_user_groups.
     */
    data: XOR<auth_user_groupsUpdateManyMutationInput, auth_user_groupsUncheckedUpdateManyInput>
    /**
     * Filter which auth_user_groups to update
     */
    where?: auth_user_groupsWhereInput
  }


  /**
   * auth_user_groups upsert
   */
  export type auth_user_groupsUpsertArgs = {
    /**
     * Select specific fields to fetch from the auth_user_groups
     */
    select?: auth_user_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_groupsInclude | null
    /**
     * The filter to search for the auth_user_groups to update in case it exists.
     */
    where: auth_user_groupsWhereUniqueInput
    /**
     * In case the auth_user_groups found by the `where` argument doesn't exist, create a new auth_user_groups with this data.
     */
    create: XOR<auth_user_groupsCreateInput, auth_user_groupsUncheckedCreateInput>
    /**
     * In case the auth_user_groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auth_user_groupsUpdateInput, auth_user_groupsUncheckedUpdateInput>
  }


  /**
   * auth_user_groups delete
   */
  export type auth_user_groupsDeleteArgs = {
    /**
     * Select specific fields to fetch from the auth_user_groups
     */
    select?: auth_user_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_groupsInclude | null
    /**
     * Filter which auth_user_groups to delete.
     */
    where: auth_user_groupsWhereUniqueInput
  }


  /**
   * auth_user_groups deleteMany
   */
  export type auth_user_groupsDeleteManyArgs = {
    /**
     * Filter which auth_user_groups to delete
     */
    where?: auth_user_groupsWhereInput
  }


  /**
   * auth_user_groups without action
   */
  export type auth_user_groupsArgs = {
    /**
     * Select specific fields to fetch from the auth_user_groups
     */
    select?: auth_user_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_groupsInclude | null
  }



  /**
   * Model auth_user_user_permissions
   */


  export type AggregateAuth_user_user_permissions = {
    _count: Auth_user_user_permissionsCountAggregateOutputType | null
    _avg: Auth_user_user_permissionsAvgAggregateOutputType | null
    _sum: Auth_user_user_permissionsSumAggregateOutputType | null
    _min: Auth_user_user_permissionsMinAggregateOutputType | null
    _max: Auth_user_user_permissionsMaxAggregateOutputType | null
  }

  export type Auth_user_user_permissionsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    permission_id: number | null
  }

  export type Auth_user_user_permissionsSumAggregateOutputType = {
    id: bigint | null
    user_id: number | null
    permission_id: number | null
  }

  export type Auth_user_user_permissionsMinAggregateOutputType = {
    id: bigint | null
    user_id: number | null
    permission_id: number | null
  }

  export type Auth_user_user_permissionsMaxAggregateOutputType = {
    id: bigint | null
    user_id: number | null
    permission_id: number | null
  }

  export type Auth_user_user_permissionsCountAggregateOutputType = {
    id: number
    user_id: number
    permission_id: number
    _all: number
  }


  export type Auth_user_user_permissionsAvgAggregateInputType = {
    id?: true
    user_id?: true
    permission_id?: true
  }

  export type Auth_user_user_permissionsSumAggregateInputType = {
    id?: true
    user_id?: true
    permission_id?: true
  }

  export type Auth_user_user_permissionsMinAggregateInputType = {
    id?: true
    user_id?: true
    permission_id?: true
  }

  export type Auth_user_user_permissionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    permission_id?: true
  }

  export type Auth_user_user_permissionsCountAggregateInputType = {
    id?: true
    user_id?: true
    permission_id?: true
    _all?: true
  }

  export type Auth_user_user_permissionsAggregateArgs = {
    /**
     * Filter which auth_user_user_permissions to aggregate.
     */
    where?: auth_user_user_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_user_user_permissions to fetch.
     */
    orderBy?: Enumerable<auth_user_user_permissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auth_user_user_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_user_user_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_user_user_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auth_user_user_permissions
    **/
    _count?: true | Auth_user_user_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Auth_user_user_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Auth_user_user_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auth_user_user_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auth_user_user_permissionsMaxAggregateInputType
  }

  export type GetAuth_user_user_permissionsAggregateType<T extends Auth_user_user_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth_user_user_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth_user_user_permissions[P]>
      : GetScalarType<T[P], AggregateAuth_user_user_permissions[P]>
  }




  export type Auth_user_user_permissionsGroupByArgs = {
    where?: auth_user_user_permissionsWhereInput
    orderBy?: Enumerable<auth_user_user_permissionsOrderByWithAggregationInput>
    by: Auth_user_user_permissionsScalarFieldEnum[]
    having?: auth_user_user_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auth_user_user_permissionsCountAggregateInputType | true
    _avg?: Auth_user_user_permissionsAvgAggregateInputType
    _sum?: Auth_user_user_permissionsSumAggregateInputType
    _min?: Auth_user_user_permissionsMinAggregateInputType
    _max?: Auth_user_user_permissionsMaxAggregateInputType
  }


  export type Auth_user_user_permissionsGroupByOutputType = {
    id: bigint
    user_id: number
    permission_id: number
    _count: Auth_user_user_permissionsCountAggregateOutputType | null
    _avg: Auth_user_user_permissionsAvgAggregateOutputType | null
    _sum: Auth_user_user_permissionsSumAggregateOutputType | null
    _min: Auth_user_user_permissionsMinAggregateOutputType | null
    _max: Auth_user_user_permissionsMaxAggregateOutputType | null
  }

  type GetAuth_user_user_permissionsGroupByPayload<T extends Auth_user_user_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Auth_user_user_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auth_user_user_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auth_user_user_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Auth_user_user_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type auth_user_user_permissionsSelect = {
    id?: boolean
    user_id?: boolean
    permission_id?: boolean
    auth_permission?: boolean | auth_permissionArgs
    auth_user?: boolean | auth_userArgs
  }


  export type auth_user_user_permissionsInclude = {
    auth_permission?: boolean | auth_permissionArgs
    auth_user?: boolean | auth_userArgs
  }

  export type auth_user_user_permissionsGetPayload<S extends boolean | null | undefined | auth_user_user_permissionsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? auth_user_user_permissions :
    S extends undefined ? never :
    S extends { include: any } & (auth_user_user_permissionsArgs | auth_user_user_permissionsFindManyArgs)
    ? auth_user_user_permissions  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'auth_permission' ? auth_permissionGetPayload<S['include'][P]> :
        P extends 'auth_user' ? auth_userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (auth_user_user_permissionsArgs | auth_user_user_permissionsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'auth_permission' ? auth_permissionGetPayload<S['select'][P]> :
        P extends 'auth_user' ? auth_userGetPayload<S['select'][P]> :  P extends keyof auth_user_user_permissions ? auth_user_user_permissions[P] : never
  } 
      : auth_user_user_permissions


  type auth_user_user_permissionsCountArgs = 
    Omit<auth_user_user_permissionsFindManyArgs, 'select' | 'include'> & {
      select?: Auth_user_user_permissionsCountAggregateInputType | true
    }

  export interface auth_user_user_permissionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Auth_user_user_permissions that matches the filter.
     * @param {auth_user_user_permissionsFindUniqueArgs} args - Arguments to find a Auth_user_user_permissions
     * @example
     * // Get one Auth_user_user_permissions
     * const auth_user_user_permissions = await prisma.auth_user_user_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends auth_user_user_permissionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, auth_user_user_permissionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'auth_user_user_permissions'> extends True ? Prisma__auth_user_user_permissionsClient<auth_user_user_permissionsGetPayload<T>> : Prisma__auth_user_user_permissionsClient<auth_user_user_permissionsGetPayload<T> | null, null>

    /**
     * Find one Auth_user_user_permissions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {auth_user_user_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Auth_user_user_permissions
     * @example
     * // Get one Auth_user_user_permissions
     * const auth_user_user_permissions = await prisma.auth_user_user_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends auth_user_user_permissionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, auth_user_user_permissionsFindUniqueOrThrowArgs>
    ): Prisma__auth_user_user_permissionsClient<auth_user_user_permissionsGetPayload<T>>

    /**
     * Find the first Auth_user_user_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_user_user_permissionsFindFirstArgs} args - Arguments to find a Auth_user_user_permissions
     * @example
     * // Get one Auth_user_user_permissions
     * const auth_user_user_permissions = await prisma.auth_user_user_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends auth_user_user_permissionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, auth_user_user_permissionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'auth_user_user_permissions'> extends True ? Prisma__auth_user_user_permissionsClient<auth_user_user_permissionsGetPayload<T>> : Prisma__auth_user_user_permissionsClient<auth_user_user_permissionsGetPayload<T> | null, null>

    /**
     * Find the first Auth_user_user_permissions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_user_user_permissionsFindFirstOrThrowArgs} args - Arguments to find a Auth_user_user_permissions
     * @example
     * // Get one Auth_user_user_permissions
     * const auth_user_user_permissions = await prisma.auth_user_user_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends auth_user_user_permissionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, auth_user_user_permissionsFindFirstOrThrowArgs>
    ): Prisma__auth_user_user_permissionsClient<auth_user_user_permissionsGetPayload<T>>

    /**
     * Find zero or more Auth_user_user_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_user_user_permissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auth_user_user_permissions
     * const auth_user_user_permissions = await prisma.auth_user_user_permissions.findMany()
     * 
     * // Get first 10 Auth_user_user_permissions
     * const auth_user_user_permissions = await prisma.auth_user_user_permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auth_user_user_permissionsWithIdOnly = await prisma.auth_user_user_permissions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends auth_user_user_permissionsFindManyArgs>(
      args?: SelectSubset<T, auth_user_user_permissionsFindManyArgs>
    ): Prisma.PrismaPromise<Array<auth_user_user_permissionsGetPayload<T>>>

    /**
     * Create a Auth_user_user_permissions.
     * @param {auth_user_user_permissionsCreateArgs} args - Arguments to create a Auth_user_user_permissions.
     * @example
     * // Create one Auth_user_user_permissions
     * const Auth_user_user_permissions = await prisma.auth_user_user_permissions.create({
     *   data: {
     *     // ... data to create a Auth_user_user_permissions
     *   }
     * })
     * 
    **/
    create<T extends auth_user_user_permissionsCreateArgs>(
      args: SelectSubset<T, auth_user_user_permissionsCreateArgs>
    ): Prisma__auth_user_user_permissionsClient<auth_user_user_permissionsGetPayload<T>>

    /**
     * Create many Auth_user_user_permissions.
     *     @param {auth_user_user_permissionsCreateManyArgs} args - Arguments to create many Auth_user_user_permissions.
     *     @example
     *     // Create many Auth_user_user_permissions
     *     const auth_user_user_permissions = await prisma.auth_user_user_permissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends auth_user_user_permissionsCreateManyArgs>(
      args?: SelectSubset<T, auth_user_user_permissionsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auth_user_user_permissions.
     * @param {auth_user_user_permissionsDeleteArgs} args - Arguments to delete one Auth_user_user_permissions.
     * @example
     * // Delete one Auth_user_user_permissions
     * const Auth_user_user_permissions = await prisma.auth_user_user_permissions.delete({
     *   where: {
     *     // ... filter to delete one Auth_user_user_permissions
     *   }
     * })
     * 
    **/
    delete<T extends auth_user_user_permissionsDeleteArgs>(
      args: SelectSubset<T, auth_user_user_permissionsDeleteArgs>
    ): Prisma__auth_user_user_permissionsClient<auth_user_user_permissionsGetPayload<T>>

    /**
     * Update one Auth_user_user_permissions.
     * @param {auth_user_user_permissionsUpdateArgs} args - Arguments to update one Auth_user_user_permissions.
     * @example
     * // Update one Auth_user_user_permissions
     * const auth_user_user_permissions = await prisma.auth_user_user_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends auth_user_user_permissionsUpdateArgs>(
      args: SelectSubset<T, auth_user_user_permissionsUpdateArgs>
    ): Prisma__auth_user_user_permissionsClient<auth_user_user_permissionsGetPayload<T>>

    /**
     * Delete zero or more Auth_user_user_permissions.
     * @param {auth_user_user_permissionsDeleteManyArgs} args - Arguments to filter Auth_user_user_permissions to delete.
     * @example
     * // Delete a few Auth_user_user_permissions
     * const { count } = await prisma.auth_user_user_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends auth_user_user_permissionsDeleteManyArgs>(
      args?: SelectSubset<T, auth_user_user_permissionsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_user_user_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_user_user_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auth_user_user_permissions
     * const auth_user_user_permissions = await prisma.auth_user_user_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends auth_user_user_permissionsUpdateManyArgs>(
      args: SelectSubset<T, auth_user_user_permissionsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auth_user_user_permissions.
     * @param {auth_user_user_permissionsUpsertArgs} args - Arguments to update or create a Auth_user_user_permissions.
     * @example
     * // Update or create a Auth_user_user_permissions
     * const auth_user_user_permissions = await prisma.auth_user_user_permissions.upsert({
     *   create: {
     *     // ... data to create a Auth_user_user_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth_user_user_permissions we want to update
     *   }
     * })
    **/
    upsert<T extends auth_user_user_permissionsUpsertArgs>(
      args: SelectSubset<T, auth_user_user_permissionsUpsertArgs>
    ): Prisma__auth_user_user_permissionsClient<auth_user_user_permissionsGetPayload<T>>

    /**
     * Count the number of Auth_user_user_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_user_user_permissionsCountArgs} args - Arguments to filter Auth_user_user_permissions to count.
     * @example
     * // Count the number of Auth_user_user_permissions
     * const count = await prisma.auth_user_user_permissions.count({
     *   where: {
     *     // ... the filter for the Auth_user_user_permissions we want to count
     *   }
     * })
    **/
    count<T extends auth_user_user_permissionsCountArgs>(
      args?: Subset<T, auth_user_user_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auth_user_user_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth_user_user_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_user_user_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auth_user_user_permissionsAggregateArgs>(args: Subset<T, Auth_user_user_permissionsAggregateArgs>): Prisma.PrismaPromise<GetAuth_user_user_permissionsAggregateType<T>>

    /**
     * Group by Auth_user_user_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_user_user_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Auth_user_user_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Auth_user_user_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: Auth_user_user_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Auth_user_user_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuth_user_user_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for auth_user_user_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__auth_user_user_permissionsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    auth_permission<T extends auth_permissionArgs= {}>(args?: Subset<T, auth_permissionArgs>): Prisma__auth_permissionClient<auth_permissionGetPayload<T> | Null>;

    auth_user<T extends auth_userArgs= {}>(args?: Subset<T, auth_userArgs>): Prisma__auth_userClient<auth_userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * auth_user_user_permissions base type for findUnique actions
   */
  export type auth_user_user_permissionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the auth_user_user_permissions
     */
    select?: auth_user_user_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_user_permissionsInclude | null
    /**
     * Filter, which auth_user_user_permissions to fetch.
     */
    where: auth_user_user_permissionsWhereUniqueInput
  }

  /**
   * auth_user_user_permissions findUnique
   */
  export interface auth_user_user_permissionsFindUniqueArgs extends auth_user_user_permissionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auth_user_user_permissions findUniqueOrThrow
   */
  export type auth_user_user_permissionsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the auth_user_user_permissions
     */
    select?: auth_user_user_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_user_permissionsInclude | null
    /**
     * Filter, which auth_user_user_permissions to fetch.
     */
    where: auth_user_user_permissionsWhereUniqueInput
  }


  /**
   * auth_user_user_permissions base type for findFirst actions
   */
  export type auth_user_user_permissionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the auth_user_user_permissions
     */
    select?: auth_user_user_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_user_permissionsInclude | null
    /**
     * Filter, which auth_user_user_permissions to fetch.
     */
    where?: auth_user_user_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_user_user_permissions to fetch.
     */
    orderBy?: Enumerable<auth_user_user_permissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_user_user_permissions.
     */
    cursor?: auth_user_user_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_user_user_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_user_user_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_user_user_permissions.
     */
    distinct?: Enumerable<Auth_user_user_permissionsScalarFieldEnum>
  }

  /**
   * auth_user_user_permissions findFirst
   */
  export interface auth_user_user_permissionsFindFirstArgs extends auth_user_user_permissionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auth_user_user_permissions findFirstOrThrow
   */
  export type auth_user_user_permissionsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the auth_user_user_permissions
     */
    select?: auth_user_user_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_user_permissionsInclude | null
    /**
     * Filter, which auth_user_user_permissions to fetch.
     */
    where?: auth_user_user_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_user_user_permissions to fetch.
     */
    orderBy?: Enumerable<auth_user_user_permissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_user_user_permissions.
     */
    cursor?: auth_user_user_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_user_user_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_user_user_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_user_user_permissions.
     */
    distinct?: Enumerable<Auth_user_user_permissionsScalarFieldEnum>
  }


  /**
   * auth_user_user_permissions findMany
   */
  export type auth_user_user_permissionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the auth_user_user_permissions
     */
    select?: auth_user_user_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_user_permissionsInclude | null
    /**
     * Filter, which auth_user_user_permissions to fetch.
     */
    where?: auth_user_user_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_user_user_permissions to fetch.
     */
    orderBy?: Enumerable<auth_user_user_permissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auth_user_user_permissions.
     */
    cursor?: auth_user_user_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_user_user_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_user_user_permissions.
     */
    skip?: number
    distinct?: Enumerable<Auth_user_user_permissionsScalarFieldEnum>
  }


  /**
   * auth_user_user_permissions create
   */
  export type auth_user_user_permissionsCreateArgs = {
    /**
     * Select specific fields to fetch from the auth_user_user_permissions
     */
    select?: auth_user_user_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_user_permissionsInclude | null
    /**
     * The data needed to create a auth_user_user_permissions.
     */
    data: XOR<auth_user_user_permissionsCreateInput, auth_user_user_permissionsUncheckedCreateInput>
  }


  /**
   * auth_user_user_permissions createMany
   */
  export type auth_user_user_permissionsCreateManyArgs = {
    /**
     * The data used to create many auth_user_user_permissions.
     */
    data: Enumerable<auth_user_user_permissionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * auth_user_user_permissions update
   */
  export type auth_user_user_permissionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the auth_user_user_permissions
     */
    select?: auth_user_user_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_user_permissionsInclude | null
    /**
     * The data needed to update a auth_user_user_permissions.
     */
    data: XOR<auth_user_user_permissionsUpdateInput, auth_user_user_permissionsUncheckedUpdateInput>
    /**
     * Choose, which auth_user_user_permissions to update.
     */
    where: auth_user_user_permissionsWhereUniqueInput
  }


  /**
   * auth_user_user_permissions updateMany
   */
  export type auth_user_user_permissionsUpdateManyArgs = {
    /**
     * The data used to update auth_user_user_permissions.
     */
    data: XOR<auth_user_user_permissionsUpdateManyMutationInput, auth_user_user_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which auth_user_user_permissions to update
     */
    where?: auth_user_user_permissionsWhereInput
  }


  /**
   * auth_user_user_permissions upsert
   */
  export type auth_user_user_permissionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the auth_user_user_permissions
     */
    select?: auth_user_user_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_user_permissionsInclude | null
    /**
     * The filter to search for the auth_user_user_permissions to update in case it exists.
     */
    where: auth_user_user_permissionsWhereUniqueInput
    /**
     * In case the auth_user_user_permissions found by the `where` argument doesn't exist, create a new auth_user_user_permissions with this data.
     */
    create: XOR<auth_user_user_permissionsCreateInput, auth_user_user_permissionsUncheckedCreateInput>
    /**
     * In case the auth_user_user_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auth_user_user_permissionsUpdateInput, auth_user_user_permissionsUncheckedUpdateInput>
  }


  /**
   * auth_user_user_permissions delete
   */
  export type auth_user_user_permissionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the auth_user_user_permissions
     */
    select?: auth_user_user_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_user_permissionsInclude | null
    /**
     * Filter which auth_user_user_permissions to delete.
     */
    where: auth_user_user_permissionsWhereUniqueInput
  }


  /**
   * auth_user_user_permissions deleteMany
   */
  export type auth_user_user_permissionsDeleteManyArgs = {
    /**
     * Filter which auth_user_user_permissions to delete
     */
    where?: auth_user_user_permissionsWhereInput
  }


  /**
   * auth_user_user_permissions without action
   */
  export type auth_user_user_permissionsArgs = {
    /**
     * Select specific fields to fetch from the auth_user_user_permissions
     */
    select?: auth_user_user_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_user_user_permissionsInclude | null
  }



  /**
   * Model categoryList
   */


  export type AggregateCategoryList = {
    _count: CategoryListCountAggregateOutputType | null
    _avg: CategoryListAvgAggregateOutputType | null
    _sum: CategoryListSumAggregateOutputType | null
    _min: CategoryListMinAggregateOutputType | null
    _max: CategoryListMaxAggregateOutputType | null
  }

  export type CategoryListAvgAggregateOutputType = {
    hide: number | null
    categoryID: number | null
  }

  export type CategoryListSumAggregateOutputType = {
    hide: number | null
    categoryID: number | null
  }

  export type CategoryListMinAggregateOutputType = {
    categorytype: string | null
    hide: number | null
    categoryID: number | null
  }

  export type CategoryListMaxAggregateOutputType = {
    categorytype: string | null
    hide: number | null
    categoryID: number | null
  }

  export type CategoryListCountAggregateOutputType = {
    categorytype: number
    hide: number
    categoryID: number
    _all: number
  }


  export type CategoryListAvgAggregateInputType = {
    hide?: true
    categoryID?: true
  }

  export type CategoryListSumAggregateInputType = {
    hide?: true
    categoryID?: true
  }

  export type CategoryListMinAggregateInputType = {
    categorytype?: true
    hide?: true
    categoryID?: true
  }

  export type CategoryListMaxAggregateInputType = {
    categorytype?: true
    hide?: true
    categoryID?: true
  }

  export type CategoryListCountAggregateInputType = {
    categorytype?: true
    hide?: true
    categoryID?: true
    _all?: true
  }

  export type CategoryListAggregateArgs = {
    /**
     * Filter which categoryList to aggregate.
     */
    where?: categoryListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoryLists to fetch.
     */
    orderBy?: Enumerable<categoryListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoryListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoryLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoryLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categoryLists
    **/
    _count?: true | CategoryListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoryListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryListMaxAggregateInputType
  }

  export type GetCategoryListAggregateType<T extends CategoryListAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoryList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoryList[P]>
      : GetScalarType<T[P], AggregateCategoryList[P]>
  }




  export type CategoryListGroupByArgs = {
    where?: categoryListWhereInput
    orderBy?: Enumerable<categoryListOrderByWithAggregationInput>
    by: CategoryListScalarFieldEnum[]
    having?: categoryListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryListCountAggregateInputType | true
    _avg?: CategoryListAvgAggregateInputType
    _sum?: CategoryListSumAggregateInputType
    _min?: CategoryListMinAggregateInputType
    _max?: CategoryListMaxAggregateInputType
  }


  export type CategoryListGroupByOutputType = {
    categorytype: string | null
    hide: number | null
    categoryID: number
    _count: CategoryListCountAggregateOutputType | null
    _avg: CategoryListAvgAggregateOutputType | null
    _sum: CategoryListSumAggregateOutputType | null
    _min: CategoryListMinAggregateOutputType | null
    _max: CategoryListMaxAggregateOutputType | null
  }

  type GetCategoryListGroupByPayload<T extends CategoryListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CategoryListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryListGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryListGroupByOutputType[P]>
        }
      >
    >


  export type categoryListSelect = {
    categorytype?: boolean
    hide?: boolean
    categoryID?: boolean
  }


  export type categoryListGetPayload<S extends boolean | null | undefined | categoryListArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? categoryList :
    S extends undefined ? never :
    S extends { include: any } & (categoryListArgs | categoryListFindManyArgs)
    ? categoryList 
    : S extends { select: any } & (categoryListArgs | categoryListFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof categoryList ? categoryList[P] : never
  } 
      : categoryList


  type categoryListCountArgs = 
    Omit<categoryListFindManyArgs, 'select' | 'include'> & {
      select?: CategoryListCountAggregateInputType | true
    }

  export interface categoryListDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CategoryList that matches the filter.
     * @param {categoryListFindUniqueArgs} args - Arguments to find a CategoryList
     * @example
     * // Get one CategoryList
     * const categoryList = await prisma.categoryList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends categoryListFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, categoryListFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'categoryList'> extends True ? Prisma__categoryListClient<categoryListGetPayload<T>> : Prisma__categoryListClient<categoryListGetPayload<T> | null, null>

    /**
     * Find one CategoryList that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {categoryListFindUniqueOrThrowArgs} args - Arguments to find a CategoryList
     * @example
     * // Get one CategoryList
     * const categoryList = await prisma.categoryList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends categoryListFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, categoryListFindUniqueOrThrowArgs>
    ): Prisma__categoryListClient<categoryListGetPayload<T>>

    /**
     * Find the first CategoryList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryListFindFirstArgs} args - Arguments to find a CategoryList
     * @example
     * // Get one CategoryList
     * const categoryList = await prisma.categoryList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends categoryListFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, categoryListFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'categoryList'> extends True ? Prisma__categoryListClient<categoryListGetPayload<T>> : Prisma__categoryListClient<categoryListGetPayload<T> | null, null>

    /**
     * Find the first CategoryList that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryListFindFirstOrThrowArgs} args - Arguments to find a CategoryList
     * @example
     * // Get one CategoryList
     * const categoryList = await prisma.categoryList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends categoryListFindFirstOrThrowArgs>(
      args?: SelectSubset<T, categoryListFindFirstOrThrowArgs>
    ): Prisma__categoryListClient<categoryListGetPayload<T>>

    /**
     * Find zero or more CategoryLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryListFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoryLists
     * const categoryLists = await prisma.categoryList.findMany()
     * 
     * // Get first 10 CategoryLists
     * const categoryLists = await prisma.categoryList.findMany({ take: 10 })
     * 
     * // Only select the `categorytype`
     * const categoryListWithCategorytypeOnly = await prisma.categoryList.findMany({ select: { categorytype: true } })
     * 
    **/
    findMany<T extends categoryListFindManyArgs>(
      args?: SelectSubset<T, categoryListFindManyArgs>
    ): Prisma.PrismaPromise<Array<categoryListGetPayload<T>>>

    /**
     * Create a CategoryList.
     * @param {categoryListCreateArgs} args - Arguments to create a CategoryList.
     * @example
     * // Create one CategoryList
     * const CategoryList = await prisma.categoryList.create({
     *   data: {
     *     // ... data to create a CategoryList
     *   }
     * })
     * 
    **/
    create<T extends categoryListCreateArgs>(
      args: SelectSubset<T, categoryListCreateArgs>
    ): Prisma__categoryListClient<categoryListGetPayload<T>>

    /**
     * Create many CategoryLists.
     *     @param {categoryListCreateManyArgs} args - Arguments to create many CategoryLists.
     *     @example
     *     // Create many CategoryLists
     *     const categoryList = await prisma.categoryList.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends categoryListCreateManyArgs>(
      args?: SelectSubset<T, categoryListCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CategoryList.
     * @param {categoryListDeleteArgs} args - Arguments to delete one CategoryList.
     * @example
     * // Delete one CategoryList
     * const CategoryList = await prisma.categoryList.delete({
     *   where: {
     *     // ... filter to delete one CategoryList
     *   }
     * })
     * 
    **/
    delete<T extends categoryListDeleteArgs>(
      args: SelectSubset<T, categoryListDeleteArgs>
    ): Prisma__categoryListClient<categoryListGetPayload<T>>

    /**
     * Update one CategoryList.
     * @param {categoryListUpdateArgs} args - Arguments to update one CategoryList.
     * @example
     * // Update one CategoryList
     * const categoryList = await prisma.categoryList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends categoryListUpdateArgs>(
      args: SelectSubset<T, categoryListUpdateArgs>
    ): Prisma__categoryListClient<categoryListGetPayload<T>>

    /**
     * Delete zero or more CategoryLists.
     * @param {categoryListDeleteManyArgs} args - Arguments to filter CategoryLists to delete.
     * @example
     * // Delete a few CategoryLists
     * const { count } = await prisma.categoryList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends categoryListDeleteManyArgs>(
      args?: SelectSubset<T, categoryListDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoryLists
     * const categoryList = await prisma.categoryList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends categoryListUpdateManyArgs>(
      args: SelectSubset<T, categoryListUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CategoryList.
     * @param {categoryListUpsertArgs} args - Arguments to update or create a CategoryList.
     * @example
     * // Update or create a CategoryList
     * const categoryList = await prisma.categoryList.upsert({
     *   create: {
     *     // ... data to create a CategoryList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoryList we want to update
     *   }
     * })
    **/
    upsert<T extends categoryListUpsertArgs>(
      args: SelectSubset<T, categoryListUpsertArgs>
    ): Prisma__categoryListClient<categoryListGetPayload<T>>

    /**
     * Count the number of CategoryLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryListCountArgs} args - Arguments to filter CategoryLists to count.
     * @example
     * // Count the number of CategoryLists
     * const count = await prisma.categoryList.count({
     *   where: {
     *     // ... the filter for the CategoryLists we want to count
     *   }
     * })
    **/
    count<T extends categoryListCountArgs>(
      args?: Subset<T, categoryListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoryList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryListAggregateArgs>(args: Subset<T, CategoryListAggregateArgs>): Prisma.PrismaPromise<GetCategoryListAggregateType<T>>

    /**
     * Group by CategoryList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryListGroupByArgs['orderBy'] }
        : { orderBy?: CategoryListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for categoryList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__categoryListClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * categoryList base type for findUnique actions
   */
  export type categoryListFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the categoryList
     */
    select?: categoryListSelect | null
    /**
     * Filter, which categoryList to fetch.
     */
    where: categoryListWhereUniqueInput
  }

  /**
   * categoryList findUnique
   */
  export interface categoryListFindUniqueArgs extends categoryListFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * categoryList findUniqueOrThrow
   */
  export type categoryListFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the categoryList
     */
    select?: categoryListSelect | null
    /**
     * Filter, which categoryList to fetch.
     */
    where: categoryListWhereUniqueInput
  }


  /**
   * categoryList base type for findFirst actions
   */
  export type categoryListFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the categoryList
     */
    select?: categoryListSelect | null
    /**
     * Filter, which categoryList to fetch.
     */
    where?: categoryListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoryLists to fetch.
     */
    orderBy?: Enumerable<categoryListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categoryLists.
     */
    cursor?: categoryListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoryLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoryLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categoryLists.
     */
    distinct?: Enumerable<CategoryListScalarFieldEnum>
  }

  /**
   * categoryList findFirst
   */
  export interface categoryListFindFirstArgs extends categoryListFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * categoryList findFirstOrThrow
   */
  export type categoryListFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the categoryList
     */
    select?: categoryListSelect | null
    /**
     * Filter, which categoryList to fetch.
     */
    where?: categoryListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoryLists to fetch.
     */
    orderBy?: Enumerable<categoryListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categoryLists.
     */
    cursor?: categoryListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoryLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoryLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categoryLists.
     */
    distinct?: Enumerable<CategoryListScalarFieldEnum>
  }


  /**
   * categoryList findMany
   */
  export type categoryListFindManyArgs = {
    /**
     * Select specific fields to fetch from the categoryList
     */
    select?: categoryListSelect | null
    /**
     * Filter, which categoryLists to fetch.
     */
    where?: categoryListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoryLists to fetch.
     */
    orderBy?: Enumerable<categoryListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categoryLists.
     */
    cursor?: categoryListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoryLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoryLists.
     */
    skip?: number
    distinct?: Enumerable<CategoryListScalarFieldEnum>
  }


  /**
   * categoryList create
   */
  export type categoryListCreateArgs = {
    /**
     * Select specific fields to fetch from the categoryList
     */
    select?: categoryListSelect | null
    /**
     * The data needed to create a categoryList.
     */
    data?: XOR<categoryListCreateInput, categoryListUncheckedCreateInput>
  }


  /**
   * categoryList createMany
   */
  export type categoryListCreateManyArgs = {
    /**
     * The data used to create many categoryLists.
     */
    data: Enumerable<categoryListCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * categoryList update
   */
  export type categoryListUpdateArgs = {
    /**
     * Select specific fields to fetch from the categoryList
     */
    select?: categoryListSelect | null
    /**
     * The data needed to update a categoryList.
     */
    data: XOR<categoryListUpdateInput, categoryListUncheckedUpdateInput>
    /**
     * Choose, which categoryList to update.
     */
    where: categoryListWhereUniqueInput
  }


  /**
   * categoryList updateMany
   */
  export type categoryListUpdateManyArgs = {
    /**
     * The data used to update categoryLists.
     */
    data: XOR<categoryListUpdateManyMutationInput, categoryListUncheckedUpdateManyInput>
    /**
     * Filter which categoryLists to update
     */
    where?: categoryListWhereInput
  }


  /**
   * categoryList upsert
   */
  export type categoryListUpsertArgs = {
    /**
     * Select specific fields to fetch from the categoryList
     */
    select?: categoryListSelect | null
    /**
     * The filter to search for the categoryList to update in case it exists.
     */
    where: categoryListWhereUniqueInput
    /**
     * In case the categoryList found by the `where` argument doesn't exist, create a new categoryList with this data.
     */
    create: XOR<categoryListCreateInput, categoryListUncheckedCreateInput>
    /**
     * In case the categoryList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoryListUpdateInput, categoryListUncheckedUpdateInput>
  }


  /**
   * categoryList delete
   */
  export type categoryListDeleteArgs = {
    /**
     * Select specific fields to fetch from the categoryList
     */
    select?: categoryListSelect | null
    /**
     * Filter which categoryList to delete.
     */
    where: categoryListWhereUniqueInput
  }


  /**
   * categoryList deleteMany
   */
  export type categoryListDeleteManyArgs = {
    /**
     * Filter which categoryLists to delete
     */
    where?: categoryListWhereInput
  }


  /**
   * categoryList without action
   */
  export type categoryListArgs = {
    /**
     * Select specific fields to fetch from the categoryList
     */
    select?: categoryListSelect | null
  }



  /**
   * Model django_admin_log
   */


  export type AggregateDjango_admin_log = {
    _count: Django_admin_logCountAggregateOutputType | null
    _avg: Django_admin_logAvgAggregateOutputType | null
    _sum: Django_admin_logSumAggregateOutputType | null
    _min: Django_admin_logMinAggregateOutputType | null
    _max: Django_admin_logMaxAggregateOutputType | null
  }

  export type Django_admin_logAvgAggregateOutputType = {
    id: number | null
    action_flag: number | null
    content_type_id: number | null
    user_id: number | null
  }

  export type Django_admin_logSumAggregateOutputType = {
    id: number | null
    action_flag: number | null
    content_type_id: number | null
    user_id: number | null
  }

  export type Django_admin_logMinAggregateOutputType = {
    id: number | null
    action_time: Date | null
    object_id: string | null
    object_repr: string | null
    action_flag: number | null
    change_message: string | null
    content_type_id: number | null
    user_id: number | null
  }

  export type Django_admin_logMaxAggregateOutputType = {
    id: number | null
    action_time: Date | null
    object_id: string | null
    object_repr: string | null
    action_flag: number | null
    change_message: string | null
    content_type_id: number | null
    user_id: number | null
  }

  export type Django_admin_logCountAggregateOutputType = {
    id: number
    action_time: number
    object_id: number
    object_repr: number
    action_flag: number
    change_message: number
    content_type_id: number
    user_id: number
    _all: number
  }


  export type Django_admin_logAvgAggregateInputType = {
    id?: true
    action_flag?: true
    content_type_id?: true
    user_id?: true
  }

  export type Django_admin_logSumAggregateInputType = {
    id?: true
    action_flag?: true
    content_type_id?: true
    user_id?: true
  }

  export type Django_admin_logMinAggregateInputType = {
    id?: true
    action_time?: true
    object_id?: true
    object_repr?: true
    action_flag?: true
    change_message?: true
    content_type_id?: true
    user_id?: true
  }

  export type Django_admin_logMaxAggregateInputType = {
    id?: true
    action_time?: true
    object_id?: true
    object_repr?: true
    action_flag?: true
    change_message?: true
    content_type_id?: true
    user_id?: true
  }

  export type Django_admin_logCountAggregateInputType = {
    id?: true
    action_time?: true
    object_id?: true
    object_repr?: true
    action_flag?: true
    change_message?: true
    content_type_id?: true
    user_id?: true
    _all?: true
  }

  export type Django_admin_logAggregateArgs = {
    /**
     * Filter which django_admin_log to aggregate.
     */
    where?: django_admin_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_admin_logs to fetch.
     */
    orderBy?: Enumerable<django_admin_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: django_admin_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_admin_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_admin_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned django_admin_logs
    **/
    _count?: true | Django_admin_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Django_admin_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Django_admin_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Django_admin_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Django_admin_logMaxAggregateInputType
  }

  export type GetDjango_admin_logAggregateType<T extends Django_admin_logAggregateArgs> = {
        [P in keyof T & keyof AggregateDjango_admin_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDjango_admin_log[P]>
      : GetScalarType<T[P], AggregateDjango_admin_log[P]>
  }




  export type Django_admin_logGroupByArgs = {
    where?: django_admin_logWhereInput
    orderBy?: Enumerable<django_admin_logOrderByWithAggregationInput>
    by: Django_admin_logScalarFieldEnum[]
    having?: django_admin_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Django_admin_logCountAggregateInputType | true
    _avg?: Django_admin_logAvgAggregateInputType
    _sum?: Django_admin_logSumAggregateInputType
    _min?: Django_admin_logMinAggregateInputType
    _max?: Django_admin_logMaxAggregateInputType
  }


  export type Django_admin_logGroupByOutputType = {
    id: number
    action_time: Date
    object_id: string | null
    object_repr: string
    action_flag: number
    change_message: string
    content_type_id: number | null
    user_id: number
    _count: Django_admin_logCountAggregateOutputType | null
    _avg: Django_admin_logAvgAggregateOutputType | null
    _sum: Django_admin_logSumAggregateOutputType | null
    _min: Django_admin_logMinAggregateOutputType | null
    _max: Django_admin_logMaxAggregateOutputType | null
  }

  type GetDjango_admin_logGroupByPayload<T extends Django_admin_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Django_admin_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Django_admin_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Django_admin_logGroupByOutputType[P]>
            : GetScalarType<T[P], Django_admin_logGroupByOutputType[P]>
        }
      >
    >


  export type django_admin_logSelect = {
    id?: boolean
    action_time?: boolean
    object_id?: boolean
    object_repr?: boolean
    action_flag?: boolean
    change_message?: boolean
    content_type_id?: boolean
    user_id?: boolean
    django_content_type?: boolean | django_admin_log$django_content_typeArgs
    auth_user?: boolean | auth_userArgs
  }


  export type django_admin_logInclude = {
    django_content_type?: boolean | django_admin_log$django_content_typeArgs
    auth_user?: boolean | auth_userArgs
  }

  export type django_admin_logGetPayload<S extends boolean | null | undefined | django_admin_logArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? django_admin_log :
    S extends undefined ? never :
    S extends { include: any } & (django_admin_logArgs | django_admin_logFindManyArgs)
    ? django_admin_log  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'django_content_type' ? django_content_typeGetPayload<S['include'][P]> | null :
        P extends 'auth_user' ? auth_userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (django_admin_logArgs | django_admin_logFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'django_content_type' ? django_content_typeGetPayload<S['select'][P]> | null :
        P extends 'auth_user' ? auth_userGetPayload<S['select'][P]> :  P extends keyof django_admin_log ? django_admin_log[P] : never
  } 
      : django_admin_log


  type django_admin_logCountArgs = 
    Omit<django_admin_logFindManyArgs, 'select' | 'include'> & {
      select?: Django_admin_logCountAggregateInputType | true
    }

  export interface django_admin_logDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Django_admin_log that matches the filter.
     * @param {django_admin_logFindUniqueArgs} args - Arguments to find a Django_admin_log
     * @example
     * // Get one Django_admin_log
     * const django_admin_log = await prisma.django_admin_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends django_admin_logFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, django_admin_logFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'django_admin_log'> extends True ? Prisma__django_admin_logClient<django_admin_logGetPayload<T>> : Prisma__django_admin_logClient<django_admin_logGetPayload<T> | null, null>

    /**
     * Find one Django_admin_log that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {django_admin_logFindUniqueOrThrowArgs} args - Arguments to find a Django_admin_log
     * @example
     * // Get one Django_admin_log
     * const django_admin_log = await prisma.django_admin_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends django_admin_logFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, django_admin_logFindUniqueOrThrowArgs>
    ): Prisma__django_admin_logClient<django_admin_logGetPayload<T>>

    /**
     * Find the first Django_admin_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_admin_logFindFirstArgs} args - Arguments to find a Django_admin_log
     * @example
     * // Get one Django_admin_log
     * const django_admin_log = await prisma.django_admin_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends django_admin_logFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, django_admin_logFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'django_admin_log'> extends True ? Prisma__django_admin_logClient<django_admin_logGetPayload<T>> : Prisma__django_admin_logClient<django_admin_logGetPayload<T> | null, null>

    /**
     * Find the first Django_admin_log that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_admin_logFindFirstOrThrowArgs} args - Arguments to find a Django_admin_log
     * @example
     * // Get one Django_admin_log
     * const django_admin_log = await prisma.django_admin_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends django_admin_logFindFirstOrThrowArgs>(
      args?: SelectSubset<T, django_admin_logFindFirstOrThrowArgs>
    ): Prisma__django_admin_logClient<django_admin_logGetPayload<T>>

    /**
     * Find zero or more Django_admin_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_admin_logFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Django_admin_logs
     * const django_admin_logs = await prisma.django_admin_log.findMany()
     * 
     * // Get first 10 Django_admin_logs
     * const django_admin_logs = await prisma.django_admin_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const django_admin_logWithIdOnly = await prisma.django_admin_log.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends django_admin_logFindManyArgs>(
      args?: SelectSubset<T, django_admin_logFindManyArgs>
    ): Prisma.PrismaPromise<Array<django_admin_logGetPayload<T>>>

    /**
     * Create a Django_admin_log.
     * @param {django_admin_logCreateArgs} args - Arguments to create a Django_admin_log.
     * @example
     * // Create one Django_admin_log
     * const Django_admin_log = await prisma.django_admin_log.create({
     *   data: {
     *     // ... data to create a Django_admin_log
     *   }
     * })
     * 
    **/
    create<T extends django_admin_logCreateArgs>(
      args: SelectSubset<T, django_admin_logCreateArgs>
    ): Prisma__django_admin_logClient<django_admin_logGetPayload<T>>

    /**
     * Create many Django_admin_logs.
     *     @param {django_admin_logCreateManyArgs} args - Arguments to create many Django_admin_logs.
     *     @example
     *     // Create many Django_admin_logs
     *     const django_admin_log = await prisma.django_admin_log.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends django_admin_logCreateManyArgs>(
      args?: SelectSubset<T, django_admin_logCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Django_admin_log.
     * @param {django_admin_logDeleteArgs} args - Arguments to delete one Django_admin_log.
     * @example
     * // Delete one Django_admin_log
     * const Django_admin_log = await prisma.django_admin_log.delete({
     *   where: {
     *     // ... filter to delete one Django_admin_log
     *   }
     * })
     * 
    **/
    delete<T extends django_admin_logDeleteArgs>(
      args: SelectSubset<T, django_admin_logDeleteArgs>
    ): Prisma__django_admin_logClient<django_admin_logGetPayload<T>>

    /**
     * Update one Django_admin_log.
     * @param {django_admin_logUpdateArgs} args - Arguments to update one Django_admin_log.
     * @example
     * // Update one Django_admin_log
     * const django_admin_log = await prisma.django_admin_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends django_admin_logUpdateArgs>(
      args: SelectSubset<T, django_admin_logUpdateArgs>
    ): Prisma__django_admin_logClient<django_admin_logGetPayload<T>>

    /**
     * Delete zero or more Django_admin_logs.
     * @param {django_admin_logDeleteManyArgs} args - Arguments to filter Django_admin_logs to delete.
     * @example
     * // Delete a few Django_admin_logs
     * const { count } = await prisma.django_admin_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends django_admin_logDeleteManyArgs>(
      args?: SelectSubset<T, django_admin_logDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Django_admin_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_admin_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Django_admin_logs
     * const django_admin_log = await prisma.django_admin_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends django_admin_logUpdateManyArgs>(
      args: SelectSubset<T, django_admin_logUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Django_admin_log.
     * @param {django_admin_logUpsertArgs} args - Arguments to update or create a Django_admin_log.
     * @example
     * // Update or create a Django_admin_log
     * const django_admin_log = await prisma.django_admin_log.upsert({
     *   create: {
     *     // ... data to create a Django_admin_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Django_admin_log we want to update
     *   }
     * })
    **/
    upsert<T extends django_admin_logUpsertArgs>(
      args: SelectSubset<T, django_admin_logUpsertArgs>
    ): Prisma__django_admin_logClient<django_admin_logGetPayload<T>>

    /**
     * Count the number of Django_admin_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_admin_logCountArgs} args - Arguments to filter Django_admin_logs to count.
     * @example
     * // Count the number of Django_admin_logs
     * const count = await prisma.django_admin_log.count({
     *   where: {
     *     // ... the filter for the Django_admin_logs we want to count
     *   }
     * })
    **/
    count<T extends django_admin_logCountArgs>(
      args?: Subset<T, django_admin_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Django_admin_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Django_admin_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Django_admin_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Django_admin_logAggregateArgs>(args: Subset<T, Django_admin_logAggregateArgs>): Prisma.PrismaPromise<GetDjango_admin_logAggregateType<T>>

    /**
     * Group by Django_admin_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Django_admin_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Django_admin_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Django_admin_logGroupByArgs['orderBy'] }
        : { orderBy?: Django_admin_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Django_admin_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDjango_admin_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for django_admin_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__django_admin_logClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    django_content_type<T extends django_admin_log$django_content_typeArgs= {}>(args?: Subset<T, django_admin_log$django_content_typeArgs>): Prisma__django_content_typeClient<django_content_typeGetPayload<T> | Null>;

    auth_user<T extends auth_userArgs= {}>(args?: Subset<T, auth_userArgs>): Prisma__auth_userClient<auth_userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * django_admin_log base type for findUnique actions
   */
  export type django_admin_logFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the django_admin_log
     */
    select?: django_admin_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_admin_logInclude | null
    /**
     * Filter, which django_admin_log to fetch.
     */
    where: django_admin_logWhereUniqueInput
  }

  /**
   * django_admin_log findUnique
   */
  export interface django_admin_logFindUniqueArgs extends django_admin_logFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * django_admin_log findUniqueOrThrow
   */
  export type django_admin_logFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the django_admin_log
     */
    select?: django_admin_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_admin_logInclude | null
    /**
     * Filter, which django_admin_log to fetch.
     */
    where: django_admin_logWhereUniqueInput
  }


  /**
   * django_admin_log base type for findFirst actions
   */
  export type django_admin_logFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the django_admin_log
     */
    select?: django_admin_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_admin_logInclude | null
    /**
     * Filter, which django_admin_log to fetch.
     */
    where?: django_admin_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_admin_logs to fetch.
     */
    orderBy?: Enumerable<django_admin_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for django_admin_logs.
     */
    cursor?: django_admin_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_admin_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_admin_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of django_admin_logs.
     */
    distinct?: Enumerable<Django_admin_logScalarFieldEnum>
  }

  /**
   * django_admin_log findFirst
   */
  export interface django_admin_logFindFirstArgs extends django_admin_logFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * django_admin_log findFirstOrThrow
   */
  export type django_admin_logFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the django_admin_log
     */
    select?: django_admin_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_admin_logInclude | null
    /**
     * Filter, which django_admin_log to fetch.
     */
    where?: django_admin_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_admin_logs to fetch.
     */
    orderBy?: Enumerable<django_admin_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for django_admin_logs.
     */
    cursor?: django_admin_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_admin_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_admin_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of django_admin_logs.
     */
    distinct?: Enumerable<Django_admin_logScalarFieldEnum>
  }


  /**
   * django_admin_log findMany
   */
  export type django_admin_logFindManyArgs = {
    /**
     * Select specific fields to fetch from the django_admin_log
     */
    select?: django_admin_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_admin_logInclude | null
    /**
     * Filter, which django_admin_logs to fetch.
     */
    where?: django_admin_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_admin_logs to fetch.
     */
    orderBy?: Enumerable<django_admin_logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing django_admin_logs.
     */
    cursor?: django_admin_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_admin_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_admin_logs.
     */
    skip?: number
    distinct?: Enumerable<Django_admin_logScalarFieldEnum>
  }


  /**
   * django_admin_log create
   */
  export type django_admin_logCreateArgs = {
    /**
     * Select specific fields to fetch from the django_admin_log
     */
    select?: django_admin_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_admin_logInclude | null
    /**
     * The data needed to create a django_admin_log.
     */
    data: XOR<django_admin_logCreateInput, django_admin_logUncheckedCreateInput>
  }


  /**
   * django_admin_log createMany
   */
  export type django_admin_logCreateManyArgs = {
    /**
     * The data used to create many django_admin_logs.
     */
    data: Enumerable<django_admin_logCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * django_admin_log update
   */
  export type django_admin_logUpdateArgs = {
    /**
     * Select specific fields to fetch from the django_admin_log
     */
    select?: django_admin_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_admin_logInclude | null
    /**
     * The data needed to update a django_admin_log.
     */
    data: XOR<django_admin_logUpdateInput, django_admin_logUncheckedUpdateInput>
    /**
     * Choose, which django_admin_log to update.
     */
    where: django_admin_logWhereUniqueInput
  }


  /**
   * django_admin_log updateMany
   */
  export type django_admin_logUpdateManyArgs = {
    /**
     * The data used to update django_admin_logs.
     */
    data: XOR<django_admin_logUpdateManyMutationInput, django_admin_logUncheckedUpdateManyInput>
    /**
     * Filter which django_admin_logs to update
     */
    where?: django_admin_logWhereInput
  }


  /**
   * django_admin_log upsert
   */
  export type django_admin_logUpsertArgs = {
    /**
     * Select specific fields to fetch from the django_admin_log
     */
    select?: django_admin_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_admin_logInclude | null
    /**
     * The filter to search for the django_admin_log to update in case it exists.
     */
    where: django_admin_logWhereUniqueInput
    /**
     * In case the django_admin_log found by the `where` argument doesn't exist, create a new django_admin_log with this data.
     */
    create: XOR<django_admin_logCreateInput, django_admin_logUncheckedCreateInput>
    /**
     * In case the django_admin_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<django_admin_logUpdateInput, django_admin_logUncheckedUpdateInput>
  }


  /**
   * django_admin_log delete
   */
  export type django_admin_logDeleteArgs = {
    /**
     * Select specific fields to fetch from the django_admin_log
     */
    select?: django_admin_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_admin_logInclude | null
    /**
     * Filter which django_admin_log to delete.
     */
    where: django_admin_logWhereUniqueInput
  }


  /**
   * django_admin_log deleteMany
   */
  export type django_admin_logDeleteManyArgs = {
    /**
     * Filter which django_admin_logs to delete
     */
    where?: django_admin_logWhereInput
  }


  /**
   * django_admin_log.django_content_type
   */
  export type django_admin_log$django_content_typeArgs = {
    /**
     * Select specific fields to fetch from the django_content_type
     */
    select?: django_content_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_content_typeInclude | null
    where?: django_content_typeWhereInput
  }


  /**
   * django_admin_log without action
   */
  export type django_admin_logArgs = {
    /**
     * Select specific fields to fetch from the django_admin_log
     */
    select?: django_admin_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_admin_logInclude | null
  }



  /**
   * Model django_content_type
   */


  export type AggregateDjango_content_type = {
    _count: Django_content_typeCountAggregateOutputType | null
    _avg: Django_content_typeAvgAggregateOutputType | null
    _sum: Django_content_typeSumAggregateOutputType | null
    _min: Django_content_typeMinAggregateOutputType | null
    _max: Django_content_typeMaxAggregateOutputType | null
  }

  export type Django_content_typeAvgAggregateOutputType = {
    id: number | null
  }

  export type Django_content_typeSumAggregateOutputType = {
    id: number | null
  }

  export type Django_content_typeMinAggregateOutputType = {
    id: number | null
    app_label: string | null
    model: string | null
  }

  export type Django_content_typeMaxAggregateOutputType = {
    id: number | null
    app_label: string | null
    model: string | null
  }

  export type Django_content_typeCountAggregateOutputType = {
    id: number
    app_label: number
    model: number
    _all: number
  }


  export type Django_content_typeAvgAggregateInputType = {
    id?: true
  }

  export type Django_content_typeSumAggregateInputType = {
    id?: true
  }

  export type Django_content_typeMinAggregateInputType = {
    id?: true
    app_label?: true
    model?: true
  }

  export type Django_content_typeMaxAggregateInputType = {
    id?: true
    app_label?: true
    model?: true
  }

  export type Django_content_typeCountAggregateInputType = {
    id?: true
    app_label?: true
    model?: true
    _all?: true
  }

  export type Django_content_typeAggregateArgs = {
    /**
     * Filter which django_content_type to aggregate.
     */
    where?: django_content_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_content_types to fetch.
     */
    orderBy?: Enumerable<django_content_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: django_content_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_content_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_content_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned django_content_types
    **/
    _count?: true | Django_content_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Django_content_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Django_content_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Django_content_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Django_content_typeMaxAggregateInputType
  }

  export type GetDjango_content_typeAggregateType<T extends Django_content_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateDjango_content_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDjango_content_type[P]>
      : GetScalarType<T[P], AggregateDjango_content_type[P]>
  }




  export type Django_content_typeGroupByArgs = {
    where?: django_content_typeWhereInput
    orderBy?: Enumerable<django_content_typeOrderByWithAggregationInput>
    by: Django_content_typeScalarFieldEnum[]
    having?: django_content_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Django_content_typeCountAggregateInputType | true
    _avg?: Django_content_typeAvgAggregateInputType
    _sum?: Django_content_typeSumAggregateInputType
    _min?: Django_content_typeMinAggregateInputType
    _max?: Django_content_typeMaxAggregateInputType
  }


  export type Django_content_typeGroupByOutputType = {
    id: number
    app_label: string
    model: string
    _count: Django_content_typeCountAggregateOutputType | null
    _avg: Django_content_typeAvgAggregateOutputType | null
    _sum: Django_content_typeSumAggregateOutputType | null
    _min: Django_content_typeMinAggregateOutputType | null
    _max: Django_content_typeMaxAggregateOutputType | null
  }

  type GetDjango_content_typeGroupByPayload<T extends Django_content_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Django_content_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Django_content_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Django_content_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Django_content_typeGroupByOutputType[P]>
        }
      >
    >


  export type django_content_typeSelect = {
    id?: boolean
    app_label?: boolean
    model?: boolean
    auth_permission?: boolean | django_content_type$auth_permissionArgs
    django_admin_log?: boolean | django_content_type$django_admin_logArgs
    _count?: boolean | Django_content_typeCountOutputTypeArgs
  }


  export type django_content_typeInclude = {
    auth_permission?: boolean | django_content_type$auth_permissionArgs
    django_admin_log?: boolean | django_content_type$django_admin_logArgs
    _count?: boolean | Django_content_typeCountOutputTypeArgs
  }

  export type django_content_typeGetPayload<S extends boolean | null | undefined | django_content_typeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? django_content_type :
    S extends undefined ? never :
    S extends { include: any } & (django_content_typeArgs | django_content_typeFindManyArgs)
    ? django_content_type  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'auth_permission' ? Array < auth_permissionGetPayload<S['include'][P]>>  :
        P extends 'django_admin_log' ? Array < django_admin_logGetPayload<S['include'][P]>>  :
        P extends '_count' ? Django_content_typeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (django_content_typeArgs | django_content_typeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'auth_permission' ? Array < auth_permissionGetPayload<S['select'][P]>>  :
        P extends 'django_admin_log' ? Array < django_admin_logGetPayload<S['select'][P]>>  :
        P extends '_count' ? Django_content_typeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof django_content_type ? django_content_type[P] : never
  } 
      : django_content_type


  type django_content_typeCountArgs = 
    Omit<django_content_typeFindManyArgs, 'select' | 'include'> & {
      select?: Django_content_typeCountAggregateInputType | true
    }

  export interface django_content_typeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Django_content_type that matches the filter.
     * @param {django_content_typeFindUniqueArgs} args - Arguments to find a Django_content_type
     * @example
     * // Get one Django_content_type
     * const django_content_type = await prisma.django_content_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends django_content_typeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, django_content_typeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'django_content_type'> extends True ? Prisma__django_content_typeClient<django_content_typeGetPayload<T>> : Prisma__django_content_typeClient<django_content_typeGetPayload<T> | null, null>

    /**
     * Find one Django_content_type that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {django_content_typeFindUniqueOrThrowArgs} args - Arguments to find a Django_content_type
     * @example
     * // Get one Django_content_type
     * const django_content_type = await prisma.django_content_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends django_content_typeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, django_content_typeFindUniqueOrThrowArgs>
    ): Prisma__django_content_typeClient<django_content_typeGetPayload<T>>

    /**
     * Find the first Django_content_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_content_typeFindFirstArgs} args - Arguments to find a Django_content_type
     * @example
     * // Get one Django_content_type
     * const django_content_type = await prisma.django_content_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends django_content_typeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, django_content_typeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'django_content_type'> extends True ? Prisma__django_content_typeClient<django_content_typeGetPayload<T>> : Prisma__django_content_typeClient<django_content_typeGetPayload<T> | null, null>

    /**
     * Find the first Django_content_type that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_content_typeFindFirstOrThrowArgs} args - Arguments to find a Django_content_type
     * @example
     * // Get one Django_content_type
     * const django_content_type = await prisma.django_content_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends django_content_typeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, django_content_typeFindFirstOrThrowArgs>
    ): Prisma__django_content_typeClient<django_content_typeGetPayload<T>>

    /**
     * Find zero or more Django_content_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_content_typeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Django_content_types
     * const django_content_types = await prisma.django_content_type.findMany()
     * 
     * // Get first 10 Django_content_types
     * const django_content_types = await prisma.django_content_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const django_content_typeWithIdOnly = await prisma.django_content_type.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends django_content_typeFindManyArgs>(
      args?: SelectSubset<T, django_content_typeFindManyArgs>
    ): Prisma.PrismaPromise<Array<django_content_typeGetPayload<T>>>

    /**
     * Create a Django_content_type.
     * @param {django_content_typeCreateArgs} args - Arguments to create a Django_content_type.
     * @example
     * // Create one Django_content_type
     * const Django_content_type = await prisma.django_content_type.create({
     *   data: {
     *     // ... data to create a Django_content_type
     *   }
     * })
     * 
    **/
    create<T extends django_content_typeCreateArgs>(
      args: SelectSubset<T, django_content_typeCreateArgs>
    ): Prisma__django_content_typeClient<django_content_typeGetPayload<T>>

    /**
     * Create many Django_content_types.
     *     @param {django_content_typeCreateManyArgs} args - Arguments to create many Django_content_types.
     *     @example
     *     // Create many Django_content_types
     *     const django_content_type = await prisma.django_content_type.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends django_content_typeCreateManyArgs>(
      args?: SelectSubset<T, django_content_typeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Django_content_type.
     * @param {django_content_typeDeleteArgs} args - Arguments to delete one Django_content_type.
     * @example
     * // Delete one Django_content_type
     * const Django_content_type = await prisma.django_content_type.delete({
     *   where: {
     *     // ... filter to delete one Django_content_type
     *   }
     * })
     * 
    **/
    delete<T extends django_content_typeDeleteArgs>(
      args: SelectSubset<T, django_content_typeDeleteArgs>
    ): Prisma__django_content_typeClient<django_content_typeGetPayload<T>>

    /**
     * Update one Django_content_type.
     * @param {django_content_typeUpdateArgs} args - Arguments to update one Django_content_type.
     * @example
     * // Update one Django_content_type
     * const django_content_type = await prisma.django_content_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends django_content_typeUpdateArgs>(
      args: SelectSubset<T, django_content_typeUpdateArgs>
    ): Prisma__django_content_typeClient<django_content_typeGetPayload<T>>

    /**
     * Delete zero or more Django_content_types.
     * @param {django_content_typeDeleteManyArgs} args - Arguments to filter Django_content_types to delete.
     * @example
     * // Delete a few Django_content_types
     * const { count } = await prisma.django_content_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends django_content_typeDeleteManyArgs>(
      args?: SelectSubset<T, django_content_typeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Django_content_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_content_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Django_content_types
     * const django_content_type = await prisma.django_content_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends django_content_typeUpdateManyArgs>(
      args: SelectSubset<T, django_content_typeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Django_content_type.
     * @param {django_content_typeUpsertArgs} args - Arguments to update or create a Django_content_type.
     * @example
     * // Update or create a Django_content_type
     * const django_content_type = await prisma.django_content_type.upsert({
     *   create: {
     *     // ... data to create a Django_content_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Django_content_type we want to update
     *   }
     * })
    **/
    upsert<T extends django_content_typeUpsertArgs>(
      args: SelectSubset<T, django_content_typeUpsertArgs>
    ): Prisma__django_content_typeClient<django_content_typeGetPayload<T>>

    /**
     * Count the number of Django_content_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_content_typeCountArgs} args - Arguments to filter Django_content_types to count.
     * @example
     * // Count the number of Django_content_types
     * const count = await prisma.django_content_type.count({
     *   where: {
     *     // ... the filter for the Django_content_types we want to count
     *   }
     * })
    **/
    count<T extends django_content_typeCountArgs>(
      args?: Subset<T, django_content_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Django_content_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Django_content_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Django_content_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Django_content_typeAggregateArgs>(args: Subset<T, Django_content_typeAggregateArgs>): Prisma.PrismaPromise<GetDjango_content_typeAggregateType<T>>

    /**
     * Group by Django_content_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Django_content_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Django_content_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Django_content_typeGroupByArgs['orderBy'] }
        : { orderBy?: Django_content_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Django_content_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDjango_content_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for django_content_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__django_content_typeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    auth_permission<T extends django_content_type$auth_permissionArgs= {}>(args?: Subset<T, django_content_type$auth_permissionArgs>): Prisma.PrismaPromise<Array<auth_permissionGetPayload<T>>| Null>;

    django_admin_log<T extends django_content_type$django_admin_logArgs= {}>(args?: Subset<T, django_content_type$django_admin_logArgs>): Prisma.PrismaPromise<Array<django_admin_logGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * django_content_type base type for findUnique actions
   */
  export type django_content_typeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the django_content_type
     */
    select?: django_content_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_content_typeInclude | null
    /**
     * Filter, which django_content_type to fetch.
     */
    where: django_content_typeWhereUniqueInput
  }

  /**
   * django_content_type findUnique
   */
  export interface django_content_typeFindUniqueArgs extends django_content_typeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * django_content_type findUniqueOrThrow
   */
  export type django_content_typeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the django_content_type
     */
    select?: django_content_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_content_typeInclude | null
    /**
     * Filter, which django_content_type to fetch.
     */
    where: django_content_typeWhereUniqueInput
  }


  /**
   * django_content_type base type for findFirst actions
   */
  export type django_content_typeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the django_content_type
     */
    select?: django_content_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_content_typeInclude | null
    /**
     * Filter, which django_content_type to fetch.
     */
    where?: django_content_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_content_types to fetch.
     */
    orderBy?: Enumerable<django_content_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for django_content_types.
     */
    cursor?: django_content_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_content_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_content_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of django_content_types.
     */
    distinct?: Enumerable<Django_content_typeScalarFieldEnum>
  }

  /**
   * django_content_type findFirst
   */
  export interface django_content_typeFindFirstArgs extends django_content_typeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * django_content_type findFirstOrThrow
   */
  export type django_content_typeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the django_content_type
     */
    select?: django_content_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_content_typeInclude | null
    /**
     * Filter, which django_content_type to fetch.
     */
    where?: django_content_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_content_types to fetch.
     */
    orderBy?: Enumerable<django_content_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for django_content_types.
     */
    cursor?: django_content_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_content_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_content_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of django_content_types.
     */
    distinct?: Enumerable<Django_content_typeScalarFieldEnum>
  }


  /**
   * django_content_type findMany
   */
  export type django_content_typeFindManyArgs = {
    /**
     * Select specific fields to fetch from the django_content_type
     */
    select?: django_content_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_content_typeInclude | null
    /**
     * Filter, which django_content_types to fetch.
     */
    where?: django_content_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_content_types to fetch.
     */
    orderBy?: Enumerable<django_content_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing django_content_types.
     */
    cursor?: django_content_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_content_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_content_types.
     */
    skip?: number
    distinct?: Enumerable<Django_content_typeScalarFieldEnum>
  }


  /**
   * django_content_type create
   */
  export type django_content_typeCreateArgs = {
    /**
     * Select specific fields to fetch from the django_content_type
     */
    select?: django_content_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_content_typeInclude | null
    /**
     * The data needed to create a django_content_type.
     */
    data: XOR<django_content_typeCreateInput, django_content_typeUncheckedCreateInput>
  }


  /**
   * django_content_type createMany
   */
  export type django_content_typeCreateManyArgs = {
    /**
     * The data used to create many django_content_types.
     */
    data: Enumerable<django_content_typeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * django_content_type update
   */
  export type django_content_typeUpdateArgs = {
    /**
     * Select specific fields to fetch from the django_content_type
     */
    select?: django_content_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_content_typeInclude | null
    /**
     * The data needed to update a django_content_type.
     */
    data: XOR<django_content_typeUpdateInput, django_content_typeUncheckedUpdateInput>
    /**
     * Choose, which django_content_type to update.
     */
    where: django_content_typeWhereUniqueInput
  }


  /**
   * django_content_type updateMany
   */
  export type django_content_typeUpdateManyArgs = {
    /**
     * The data used to update django_content_types.
     */
    data: XOR<django_content_typeUpdateManyMutationInput, django_content_typeUncheckedUpdateManyInput>
    /**
     * Filter which django_content_types to update
     */
    where?: django_content_typeWhereInput
  }


  /**
   * django_content_type upsert
   */
  export type django_content_typeUpsertArgs = {
    /**
     * Select specific fields to fetch from the django_content_type
     */
    select?: django_content_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_content_typeInclude | null
    /**
     * The filter to search for the django_content_type to update in case it exists.
     */
    where: django_content_typeWhereUniqueInput
    /**
     * In case the django_content_type found by the `where` argument doesn't exist, create a new django_content_type with this data.
     */
    create: XOR<django_content_typeCreateInput, django_content_typeUncheckedCreateInput>
    /**
     * In case the django_content_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<django_content_typeUpdateInput, django_content_typeUncheckedUpdateInput>
  }


  /**
   * django_content_type delete
   */
  export type django_content_typeDeleteArgs = {
    /**
     * Select specific fields to fetch from the django_content_type
     */
    select?: django_content_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_content_typeInclude | null
    /**
     * Filter which django_content_type to delete.
     */
    where: django_content_typeWhereUniqueInput
  }


  /**
   * django_content_type deleteMany
   */
  export type django_content_typeDeleteManyArgs = {
    /**
     * Filter which django_content_types to delete
     */
    where?: django_content_typeWhereInput
  }


  /**
   * django_content_type.auth_permission
   */
  export type django_content_type$auth_permissionArgs = {
    /**
     * Select specific fields to fetch from the auth_permission
     */
    select?: auth_permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: auth_permissionInclude | null
    where?: auth_permissionWhereInput
    orderBy?: Enumerable<auth_permissionOrderByWithRelationInput>
    cursor?: auth_permissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Auth_permissionScalarFieldEnum>
  }


  /**
   * django_content_type.django_admin_log
   */
  export type django_content_type$django_admin_logArgs = {
    /**
     * Select specific fields to fetch from the django_admin_log
     */
    select?: django_admin_logSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_admin_logInclude | null
    where?: django_admin_logWhereInput
    orderBy?: Enumerable<django_admin_logOrderByWithRelationInput>
    cursor?: django_admin_logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Django_admin_logScalarFieldEnum>
  }


  /**
   * django_content_type without action
   */
  export type django_content_typeArgs = {
    /**
     * Select specific fields to fetch from the django_content_type
     */
    select?: django_content_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: django_content_typeInclude | null
  }



  /**
   * Model django_migrations
   */


  export type AggregateDjango_migrations = {
    _count: Django_migrationsCountAggregateOutputType | null
    _avg: Django_migrationsAvgAggregateOutputType | null
    _sum: Django_migrationsSumAggregateOutputType | null
    _min: Django_migrationsMinAggregateOutputType | null
    _max: Django_migrationsMaxAggregateOutputType | null
  }

  export type Django_migrationsAvgAggregateOutputType = {
    id: number | null
  }

  export type Django_migrationsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Django_migrationsMinAggregateOutputType = {
    id: bigint | null
    app: string | null
    name: string | null
    applied: Date | null
  }

  export type Django_migrationsMaxAggregateOutputType = {
    id: bigint | null
    app: string | null
    name: string | null
    applied: Date | null
  }

  export type Django_migrationsCountAggregateOutputType = {
    id: number
    app: number
    name: number
    applied: number
    _all: number
  }


  export type Django_migrationsAvgAggregateInputType = {
    id?: true
  }

  export type Django_migrationsSumAggregateInputType = {
    id?: true
  }

  export type Django_migrationsMinAggregateInputType = {
    id?: true
    app?: true
    name?: true
    applied?: true
  }

  export type Django_migrationsMaxAggregateInputType = {
    id?: true
    app?: true
    name?: true
    applied?: true
  }

  export type Django_migrationsCountAggregateInputType = {
    id?: true
    app?: true
    name?: true
    applied?: true
    _all?: true
  }

  export type Django_migrationsAggregateArgs = {
    /**
     * Filter which django_migrations to aggregate.
     */
    where?: django_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_migrations to fetch.
     */
    orderBy?: Enumerable<django_migrationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: django_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned django_migrations
    **/
    _count?: true | Django_migrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Django_migrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Django_migrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Django_migrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Django_migrationsMaxAggregateInputType
  }

  export type GetDjango_migrationsAggregateType<T extends Django_migrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateDjango_migrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDjango_migrations[P]>
      : GetScalarType<T[P], AggregateDjango_migrations[P]>
  }




  export type Django_migrationsGroupByArgs = {
    where?: django_migrationsWhereInput
    orderBy?: Enumerable<django_migrationsOrderByWithAggregationInput>
    by: Django_migrationsScalarFieldEnum[]
    having?: django_migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Django_migrationsCountAggregateInputType | true
    _avg?: Django_migrationsAvgAggregateInputType
    _sum?: Django_migrationsSumAggregateInputType
    _min?: Django_migrationsMinAggregateInputType
    _max?: Django_migrationsMaxAggregateInputType
  }


  export type Django_migrationsGroupByOutputType = {
    id: bigint
    app: string
    name: string
    applied: Date
    _count: Django_migrationsCountAggregateOutputType | null
    _avg: Django_migrationsAvgAggregateOutputType | null
    _sum: Django_migrationsSumAggregateOutputType | null
    _min: Django_migrationsMinAggregateOutputType | null
    _max: Django_migrationsMaxAggregateOutputType | null
  }

  type GetDjango_migrationsGroupByPayload<T extends Django_migrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Django_migrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Django_migrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Django_migrationsGroupByOutputType[P]>
            : GetScalarType<T[P], Django_migrationsGroupByOutputType[P]>
        }
      >
    >


  export type django_migrationsSelect = {
    id?: boolean
    app?: boolean
    name?: boolean
    applied?: boolean
  }


  export type django_migrationsGetPayload<S extends boolean | null | undefined | django_migrationsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? django_migrations :
    S extends undefined ? never :
    S extends { include: any } & (django_migrationsArgs | django_migrationsFindManyArgs)
    ? django_migrations 
    : S extends { select: any } & (django_migrationsArgs | django_migrationsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof django_migrations ? django_migrations[P] : never
  } 
      : django_migrations


  type django_migrationsCountArgs = 
    Omit<django_migrationsFindManyArgs, 'select' | 'include'> & {
      select?: Django_migrationsCountAggregateInputType | true
    }

  export interface django_migrationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Django_migrations that matches the filter.
     * @param {django_migrationsFindUniqueArgs} args - Arguments to find a Django_migrations
     * @example
     * // Get one Django_migrations
     * const django_migrations = await prisma.django_migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends django_migrationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, django_migrationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'django_migrations'> extends True ? Prisma__django_migrationsClient<django_migrationsGetPayload<T>> : Prisma__django_migrationsClient<django_migrationsGetPayload<T> | null, null>

    /**
     * Find one Django_migrations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {django_migrationsFindUniqueOrThrowArgs} args - Arguments to find a Django_migrations
     * @example
     * // Get one Django_migrations
     * const django_migrations = await prisma.django_migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends django_migrationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, django_migrationsFindUniqueOrThrowArgs>
    ): Prisma__django_migrationsClient<django_migrationsGetPayload<T>>

    /**
     * Find the first Django_migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_migrationsFindFirstArgs} args - Arguments to find a Django_migrations
     * @example
     * // Get one Django_migrations
     * const django_migrations = await prisma.django_migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends django_migrationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, django_migrationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'django_migrations'> extends True ? Prisma__django_migrationsClient<django_migrationsGetPayload<T>> : Prisma__django_migrationsClient<django_migrationsGetPayload<T> | null, null>

    /**
     * Find the first Django_migrations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_migrationsFindFirstOrThrowArgs} args - Arguments to find a Django_migrations
     * @example
     * // Get one Django_migrations
     * const django_migrations = await prisma.django_migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends django_migrationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, django_migrationsFindFirstOrThrowArgs>
    ): Prisma__django_migrationsClient<django_migrationsGetPayload<T>>

    /**
     * Find zero or more Django_migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_migrationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Django_migrations
     * const django_migrations = await prisma.django_migrations.findMany()
     * 
     * // Get first 10 Django_migrations
     * const django_migrations = await prisma.django_migrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const django_migrationsWithIdOnly = await prisma.django_migrations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends django_migrationsFindManyArgs>(
      args?: SelectSubset<T, django_migrationsFindManyArgs>
    ): Prisma.PrismaPromise<Array<django_migrationsGetPayload<T>>>

    /**
     * Create a Django_migrations.
     * @param {django_migrationsCreateArgs} args - Arguments to create a Django_migrations.
     * @example
     * // Create one Django_migrations
     * const Django_migrations = await prisma.django_migrations.create({
     *   data: {
     *     // ... data to create a Django_migrations
     *   }
     * })
     * 
    **/
    create<T extends django_migrationsCreateArgs>(
      args: SelectSubset<T, django_migrationsCreateArgs>
    ): Prisma__django_migrationsClient<django_migrationsGetPayload<T>>

    /**
     * Create many Django_migrations.
     *     @param {django_migrationsCreateManyArgs} args - Arguments to create many Django_migrations.
     *     @example
     *     // Create many Django_migrations
     *     const django_migrations = await prisma.django_migrations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends django_migrationsCreateManyArgs>(
      args?: SelectSubset<T, django_migrationsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Django_migrations.
     * @param {django_migrationsDeleteArgs} args - Arguments to delete one Django_migrations.
     * @example
     * // Delete one Django_migrations
     * const Django_migrations = await prisma.django_migrations.delete({
     *   where: {
     *     // ... filter to delete one Django_migrations
     *   }
     * })
     * 
    **/
    delete<T extends django_migrationsDeleteArgs>(
      args: SelectSubset<T, django_migrationsDeleteArgs>
    ): Prisma__django_migrationsClient<django_migrationsGetPayload<T>>

    /**
     * Update one Django_migrations.
     * @param {django_migrationsUpdateArgs} args - Arguments to update one Django_migrations.
     * @example
     * // Update one Django_migrations
     * const django_migrations = await prisma.django_migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends django_migrationsUpdateArgs>(
      args: SelectSubset<T, django_migrationsUpdateArgs>
    ): Prisma__django_migrationsClient<django_migrationsGetPayload<T>>

    /**
     * Delete zero or more Django_migrations.
     * @param {django_migrationsDeleteManyArgs} args - Arguments to filter Django_migrations to delete.
     * @example
     * // Delete a few Django_migrations
     * const { count } = await prisma.django_migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends django_migrationsDeleteManyArgs>(
      args?: SelectSubset<T, django_migrationsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Django_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Django_migrations
     * const django_migrations = await prisma.django_migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends django_migrationsUpdateManyArgs>(
      args: SelectSubset<T, django_migrationsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Django_migrations.
     * @param {django_migrationsUpsertArgs} args - Arguments to update or create a Django_migrations.
     * @example
     * // Update or create a Django_migrations
     * const django_migrations = await prisma.django_migrations.upsert({
     *   create: {
     *     // ... data to create a Django_migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Django_migrations we want to update
     *   }
     * })
    **/
    upsert<T extends django_migrationsUpsertArgs>(
      args: SelectSubset<T, django_migrationsUpsertArgs>
    ): Prisma__django_migrationsClient<django_migrationsGetPayload<T>>

    /**
     * Count the number of Django_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_migrationsCountArgs} args - Arguments to filter Django_migrations to count.
     * @example
     * // Count the number of Django_migrations
     * const count = await prisma.django_migrations.count({
     *   where: {
     *     // ... the filter for the Django_migrations we want to count
     *   }
     * })
    **/
    count<T extends django_migrationsCountArgs>(
      args?: Subset<T, django_migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Django_migrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Django_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Django_migrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Django_migrationsAggregateArgs>(args: Subset<T, Django_migrationsAggregateArgs>): Prisma.PrismaPromise<GetDjango_migrationsAggregateType<T>>

    /**
     * Group by Django_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Django_migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Django_migrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Django_migrationsGroupByArgs['orderBy'] }
        : { orderBy?: Django_migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Django_migrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDjango_migrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for django_migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__django_migrationsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * django_migrations base type for findUnique actions
   */
  export type django_migrationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the django_migrations
     */
    select?: django_migrationsSelect | null
    /**
     * Filter, which django_migrations to fetch.
     */
    where: django_migrationsWhereUniqueInput
  }

  /**
   * django_migrations findUnique
   */
  export interface django_migrationsFindUniqueArgs extends django_migrationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * django_migrations findUniqueOrThrow
   */
  export type django_migrationsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the django_migrations
     */
    select?: django_migrationsSelect | null
    /**
     * Filter, which django_migrations to fetch.
     */
    where: django_migrationsWhereUniqueInput
  }


  /**
   * django_migrations base type for findFirst actions
   */
  export type django_migrationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the django_migrations
     */
    select?: django_migrationsSelect | null
    /**
     * Filter, which django_migrations to fetch.
     */
    where?: django_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_migrations to fetch.
     */
    orderBy?: Enumerable<django_migrationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for django_migrations.
     */
    cursor?: django_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of django_migrations.
     */
    distinct?: Enumerable<Django_migrationsScalarFieldEnum>
  }

  /**
   * django_migrations findFirst
   */
  export interface django_migrationsFindFirstArgs extends django_migrationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * django_migrations findFirstOrThrow
   */
  export type django_migrationsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the django_migrations
     */
    select?: django_migrationsSelect | null
    /**
     * Filter, which django_migrations to fetch.
     */
    where?: django_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_migrations to fetch.
     */
    orderBy?: Enumerable<django_migrationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for django_migrations.
     */
    cursor?: django_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of django_migrations.
     */
    distinct?: Enumerable<Django_migrationsScalarFieldEnum>
  }


  /**
   * django_migrations findMany
   */
  export type django_migrationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the django_migrations
     */
    select?: django_migrationsSelect | null
    /**
     * Filter, which django_migrations to fetch.
     */
    where?: django_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_migrations to fetch.
     */
    orderBy?: Enumerable<django_migrationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing django_migrations.
     */
    cursor?: django_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_migrations.
     */
    skip?: number
    distinct?: Enumerable<Django_migrationsScalarFieldEnum>
  }


  /**
   * django_migrations create
   */
  export type django_migrationsCreateArgs = {
    /**
     * Select specific fields to fetch from the django_migrations
     */
    select?: django_migrationsSelect | null
    /**
     * The data needed to create a django_migrations.
     */
    data: XOR<django_migrationsCreateInput, django_migrationsUncheckedCreateInput>
  }


  /**
   * django_migrations createMany
   */
  export type django_migrationsCreateManyArgs = {
    /**
     * The data used to create many django_migrations.
     */
    data: Enumerable<django_migrationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * django_migrations update
   */
  export type django_migrationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the django_migrations
     */
    select?: django_migrationsSelect | null
    /**
     * The data needed to update a django_migrations.
     */
    data: XOR<django_migrationsUpdateInput, django_migrationsUncheckedUpdateInput>
    /**
     * Choose, which django_migrations to update.
     */
    where: django_migrationsWhereUniqueInput
  }


  /**
   * django_migrations updateMany
   */
  export type django_migrationsUpdateManyArgs = {
    /**
     * The data used to update django_migrations.
     */
    data: XOR<django_migrationsUpdateManyMutationInput, django_migrationsUncheckedUpdateManyInput>
    /**
     * Filter which django_migrations to update
     */
    where?: django_migrationsWhereInput
  }


  /**
   * django_migrations upsert
   */
  export type django_migrationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the django_migrations
     */
    select?: django_migrationsSelect | null
    /**
     * The filter to search for the django_migrations to update in case it exists.
     */
    where: django_migrationsWhereUniqueInput
    /**
     * In case the django_migrations found by the `where` argument doesn't exist, create a new django_migrations with this data.
     */
    create: XOR<django_migrationsCreateInput, django_migrationsUncheckedCreateInput>
    /**
     * In case the django_migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<django_migrationsUpdateInput, django_migrationsUncheckedUpdateInput>
  }


  /**
   * django_migrations delete
   */
  export type django_migrationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the django_migrations
     */
    select?: django_migrationsSelect | null
    /**
     * Filter which django_migrations to delete.
     */
    where: django_migrationsWhereUniqueInput
  }


  /**
   * django_migrations deleteMany
   */
  export type django_migrationsDeleteManyArgs = {
    /**
     * Filter which django_migrations to delete
     */
    where?: django_migrationsWhereInput
  }


  /**
   * django_migrations without action
   */
  export type django_migrationsArgs = {
    /**
     * Select specific fields to fetch from the django_migrations
     */
    select?: django_migrationsSelect | null
  }



  /**
   * Model django_session
   */


  export type AggregateDjango_session = {
    _count: Django_sessionCountAggregateOutputType | null
    _min: Django_sessionMinAggregateOutputType | null
    _max: Django_sessionMaxAggregateOutputType | null
  }

  export type Django_sessionMinAggregateOutputType = {
    session_key: string | null
    session_data: string | null
    expire_date: Date | null
  }

  export type Django_sessionMaxAggregateOutputType = {
    session_key: string | null
    session_data: string | null
    expire_date: Date | null
  }

  export type Django_sessionCountAggregateOutputType = {
    session_key: number
    session_data: number
    expire_date: number
    _all: number
  }


  export type Django_sessionMinAggregateInputType = {
    session_key?: true
    session_data?: true
    expire_date?: true
  }

  export type Django_sessionMaxAggregateInputType = {
    session_key?: true
    session_data?: true
    expire_date?: true
  }

  export type Django_sessionCountAggregateInputType = {
    session_key?: true
    session_data?: true
    expire_date?: true
    _all?: true
  }

  export type Django_sessionAggregateArgs = {
    /**
     * Filter which django_session to aggregate.
     */
    where?: django_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_sessions to fetch.
     */
    orderBy?: Enumerable<django_sessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: django_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned django_sessions
    **/
    _count?: true | Django_sessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Django_sessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Django_sessionMaxAggregateInputType
  }

  export type GetDjango_sessionAggregateType<T extends Django_sessionAggregateArgs> = {
        [P in keyof T & keyof AggregateDjango_session]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDjango_session[P]>
      : GetScalarType<T[P], AggregateDjango_session[P]>
  }




  export type Django_sessionGroupByArgs = {
    where?: django_sessionWhereInput
    orderBy?: Enumerable<django_sessionOrderByWithAggregationInput>
    by: Django_sessionScalarFieldEnum[]
    having?: django_sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Django_sessionCountAggregateInputType | true
    _min?: Django_sessionMinAggregateInputType
    _max?: Django_sessionMaxAggregateInputType
  }


  export type Django_sessionGroupByOutputType = {
    session_key: string
    session_data: string
    expire_date: Date
    _count: Django_sessionCountAggregateOutputType | null
    _min: Django_sessionMinAggregateOutputType | null
    _max: Django_sessionMaxAggregateOutputType | null
  }

  type GetDjango_sessionGroupByPayload<T extends Django_sessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Django_sessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Django_sessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Django_sessionGroupByOutputType[P]>
            : GetScalarType<T[P], Django_sessionGroupByOutputType[P]>
        }
      >
    >


  export type django_sessionSelect = {
    session_key?: boolean
    session_data?: boolean
    expire_date?: boolean
  }


  export type django_sessionGetPayload<S extends boolean | null | undefined | django_sessionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? django_session :
    S extends undefined ? never :
    S extends { include: any } & (django_sessionArgs | django_sessionFindManyArgs)
    ? django_session 
    : S extends { select: any } & (django_sessionArgs | django_sessionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof django_session ? django_session[P] : never
  } 
      : django_session


  type django_sessionCountArgs = 
    Omit<django_sessionFindManyArgs, 'select' | 'include'> & {
      select?: Django_sessionCountAggregateInputType | true
    }

  export interface django_sessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Django_session that matches the filter.
     * @param {django_sessionFindUniqueArgs} args - Arguments to find a Django_session
     * @example
     * // Get one Django_session
     * const django_session = await prisma.django_session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends django_sessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, django_sessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'django_session'> extends True ? Prisma__django_sessionClient<django_sessionGetPayload<T>> : Prisma__django_sessionClient<django_sessionGetPayload<T> | null, null>

    /**
     * Find one Django_session that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {django_sessionFindUniqueOrThrowArgs} args - Arguments to find a Django_session
     * @example
     * // Get one Django_session
     * const django_session = await prisma.django_session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends django_sessionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, django_sessionFindUniqueOrThrowArgs>
    ): Prisma__django_sessionClient<django_sessionGetPayload<T>>

    /**
     * Find the first Django_session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_sessionFindFirstArgs} args - Arguments to find a Django_session
     * @example
     * // Get one Django_session
     * const django_session = await prisma.django_session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends django_sessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, django_sessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'django_session'> extends True ? Prisma__django_sessionClient<django_sessionGetPayload<T>> : Prisma__django_sessionClient<django_sessionGetPayload<T> | null, null>

    /**
     * Find the first Django_session that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_sessionFindFirstOrThrowArgs} args - Arguments to find a Django_session
     * @example
     * // Get one Django_session
     * const django_session = await prisma.django_session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends django_sessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, django_sessionFindFirstOrThrowArgs>
    ): Prisma__django_sessionClient<django_sessionGetPayload<T>>

    /**
     * Find zero or more Django_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_sessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Django_sessions
     * const django_sessions = await prisma.django_session.findMany()
     * 
     * // Get first 10 Django_sessions
     * const django_sessions = await prisma.django_session.findMany({ take: 10 })
     * 
     * // Only select the `session_key`
     * const django_sessionWithSession_keyOnly = await prisma.django_session.findMany({ select: { session_key: true } })
     * 
    **/
    findMany<T extends django_sessionFindManyArgs>(
      args?: SelectSubset<T, django_sessionFindManyArgs>
    ): Prisma.PrismaPromise<Array<django_sessionGetPayload<T>>>

    /**
     * Create a Django_session.
     * @param {django_sessionCreateArgs} args - Arguments to create a Django_session.
     * @example
     * // Create one Django_session
     * const Django_session = await prisma.django_session.create({
     *   data: {
     *     // ... data to create a Django_session
     *   }
     * })
     * 
    **/
    create<T extends django_sessionCreateArgs>(
      args: SelectSubset<T, django_sessionCreateArgs>
    ): Prisma__django_sessionClient<django_sessionGetPayload<T>>

    /**
     * Create many Django_sessions.
     *     @param {django_sessionCreateManyArgs} args - Arguments to create many Django_sessions.
     *     @example
     *     // Create many Django_sessions
     *     const django_session = await prisma.django_session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends django_sessionCreateManyArgs>(
      args?: SelectSubset<T, django_sessionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Django_session.
     * @param {django_sessionDeleteArgs} args - Arguments to delete one Django_session.
     * @example
     * // Delete one Django_session
     * const Django_session = await prisma.django_session.delete({
     *   where: {
     *     // ... filter to delete one Django_session
     *   }
     * })
     * 
    **/
    delete<T extends django_sessionDeleteArgs>(
      args: SelectSubset<T, django_sessionDeleteArgs>
    ): Prisma__django_sessionClient<django_sessionGetPayload<T>>

    /**
     * Update one Django_session.
     * @param {django_sessionUpdateArgs} args - Arguments to update one Django_session.
     * @example
     * // Update one Django_session
     * const django_session = await prisma.django_session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends django_sessionUpdateArgs>(
      args: SelectSubset<T, django_sessionUpdateArgs>
    ): Prisma__django_sessionClient<django_sessionGetPayload<T>>

    /**
     * Delete zero or more Django_sessions.
     * @param {django_sessionDeleteManyArgs} args - Arguments to filter Django_sessions to delete.
     * @example
     * // Delete a few Django_sessions
     * const { count } = await prisma.django_session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends django_sessionDeleteManyArgs>(
      args?: SelectSubset<T, django_sessionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Django_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Django_sessions
     * const django_session = await prisma.django_session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends django_sessionUpdateManyArgs>(
      args: SelectSubset<T, django_sessionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Django_session.
     * @param {django_sessionUpsertArgs} args - Arguments to update or create a Django_session.
     * @example
     * // Update or create a Django_session
     * const django_session = await prisma.django_session.upsert({
     *   create: {
     *     // ... data to create a Django_session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Django_session we want to update
     *   }
     * })
    **/
    upsert<T extends django_sessionUpsertArgs>(
      args: SelectSubset<T, django_sessionUpsertArgs>
    ): Prisma__django_sessionClient<django_sessionGetPayload<T>>

    /**
     * Count the number of Django_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {django_sessionCountArgs} args - Arguments to filter Django_sessions to count.
     * @example
     * // Count the number of Django_sessions
     * const count = await prisma.django_session.count({
     *   where: {
     *     // ... the filter for the Django_sessions we want to count
     *   }
     * })
    **/
    count<T extends django_sessionCountArgs>(
      args?: Subset<T, django_sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Django_sessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Django_session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Django_sessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Django_sessionAggregateArgs>(args: Subset<T, Django_sessionAggregateArgs>): Prisma.PrismaPromise<GetDjango_sessionAggregateType<T>>

    /**
     * Group by Django_session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Django_sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Django_sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Django_sessionGroupByArgs['orderBy'] }
        : { orderBy?: Django_sessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Django_sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDjango_sessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for django_session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__django_sessionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * django_session base type for findUnique actions
   */
  export type django_sessionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the django_session
     */
    select?: django_sessionSelect | null
    /**
     * Filter, which django_session to fetch.
     */
    where: django_sessionWhereUniqueInput
  }

  /**
   * django_session findUnique
   */
  export interface django_sessionFindUniqueArgs extends django_sessionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * django_session findUniqueOrThrow
   */
  export type django_sessionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the django_session
     */
    select?: django_sessionSelect | null
    /**
     * Filter, which django_session to fetch.
     */
    where: django_sessionWhereUniqueInput
  }


  /**
   * django_session base type for findFirst actions
   */
  export type django_sessionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the django_session
     */
    select?: django_sessionSelect | null
    /**
     * Filter, which django_session to fetch.
     */
    where?: django_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_sessions to fetch.
     */
    orderBy?: Enumerable<django_sessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for django_sessions.
     */
    cursor?: django_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of django_sessions.
     */
    distinct?: Enumerable<Django_sessionScalarFieldEnum>
  }

  /**
   * django_session findFirst
   */
  export interface django_sessionFindFirstArgs extends django_sessionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * django_session findFirstOrThrow
   */
  export type django_sessionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the django_session
     */
    select?: django_sessionSelect | null
    /**
     * Filter, which django_session to fetch.
     */
    where?: django_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_sessions to fetch.
     */
    orderBy?: Enumerable<django_sessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for django_sessions.
     */
    cursor?: django_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of django_sessions.
     */
    distinct?: Enumerable<Django_sessionScalarFieldEnum>
  }


  /**
   * django_session findMany
   */
  export type django_sessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the django_session
     */
    select?: django_sessionSelect | null
    /**
     * Filter, which django_sessions to fetch.
     */
    where?: django_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of django_sessions to fetch.
     */
    orderBy?: Enumerable<django_sessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing django_sessions.
     */
    cursor?: django_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` django_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` django_sessions.
     */
    skip?: number
    distinct?: Enumerable<Django_sessionScalarFieldEnum>
  }


  /**
   * django_session create
   */
  export type django_sessionCreateArgs = {
    /**
     * Select specific fields to fetch from the django_session
     */
    select?: django_sessionSelect | null
    /**
     * The data needed to create a django_session.
     */
    data: XOR<django_sessionCreateInput, django_sessionUncheckedCreateInput>
  }


  /**
   * django_session createMany
   */
  export type django_sessionCreateManyArgs = {
    /**
     * The data used to create many django_sessions.
     */
    data: Enumerable<django_sessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * django_session update
   */
  export type django_sessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the django_session
     */
    select?: django_sessionSelect | null
    /**
     * The data needed to update a django_session.
     */
    data: XOR<django_sessionUpdateInput, django_sessionUncheckedUpdateInput>
    /**
     * Choose, which django_session to update.
     */
    where: django_sessionWhereUniqueInput
  }


  /**
   * django_session updateMany
   */
  export type django_sessionUpdateManyArgs = {
    /**
     * The data used to update django_sessions.
     */
    data: XOR<django_sessionUpdateManyMutationInput, django_sessionUncheckedUpdateManyInput>
    /**
     * Filter which django_sessions to update
     */
    where?: django_sessionWhereInput
  }


  /**
   * django_session upsert
   */
  export type django_sessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the django_session
     */
    select?: django_sessionSelect | null
    /**
     * The filter to search for the django_session to update in case it exists.
     */
    where: django_sessionWhereUniqueInput
    /**
     * In case the django_session found by the `where` argument doesn't exist, create a new django_session with this data.
     */
    create: XOR<django_sessionCreateInput, django_sessionUncheckedCreateInput>
    /**
     * In case the django_session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<django_sessionUpdateInput, django_sessionUncheckedUpdateInput>
  }


  /**
   * django_session delete
   */
  export type django_sessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the django_session
     */
    select?: django_sessionSelect | null
    /**
     * Filter which django_session to delete.
     */
    where: django_sessionWhereUniqueInput
  }


  /**
   * django_session deleteMany
   */
  export type django_sessionDeleteManyArgs = {
    /**
     * Filter which django_sessions to delete
     */
    where?: django_sessionWhereInput
  }


  /**
   * django_session without action
   */
  export type django_sessionArgs = {
    /**
     * Select specific fields to fetch from the django_session
     */
    select?: django_sessionSelect | null
  }



  /**
   * Model events
   */


  export type AggregateEvents = {
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  export type EventsAvgAggregateOutputType = {
    id: number | null
  }

  export type EventsSumAggregateOutputType = {
    id: number | null
  }

  export type EventsMinAggregateOutputType = {
    id: number | null
    title: string | null
    color: string | null
    start: Date | null
    end: Date | null
  }

  export type EventsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    color: string | null
    start: Date | null
    end: Date | null
  }

  export type EventsCountAggregateOutputType = {
    id: number
    title: number
    color: number
    start: number
    end: number
    _all: number
  }


  export type EventsAvgAggregateInputType = {
    id?: true
  }

  export type EventsSumAggregateInputType = {
    id?: true
  }

  export type EventsMinAggregateInputType = {
    id?: true
    title?: true
    color?: true
    start?: true
    end?: true
  }

  export type EventsMaxAggregateInputType = {
    id?: true
    title?: true
    color?: true
    start?: true
    end?: true
  }

  export type EventsCountAggregateInputType = {
    id?: true
    title?: true
    color?: true
    start?: true
    end?: true
    _all?: true
  }

  export type EventsAggregateArgs = {
    /**
     * Filter which events to aggregate.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: Enumerable<eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned events
    **/
    _count?: true | EventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventsMaxAggregateInputType
  }

  export type GetEventsAggregateType<T extends EventsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvents[P]>
      : GetScalarType<T[P], AggregateEvents[P]>
  }




  export type EventsGroupByArgs = {
    where?: eventsWhereInput
    orderBy?: Enumerable<eventsOrderByWithAggregationInput>
    by: EventsScalarFieldEnum[]
    having?: eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventsCountAggregateInputType | true
    _avg?: EventsAvgAggregateInputType
    _sum?: EventsSumAggregateInputType
    _min?: EventsMinAggregateInputType
    _max?: EventsMaxAggregateInputType
  }


  export type EventsGroupByOutputType = {
    id: number
    title: string
    color: string | null
    start: Date
    end: Date | null
    _count: EventsCountAggregateOutputType | null
    _avg: EventsAvgAggregateOutputType | null
    _sum: EventsSumAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  type GetEventsGroupByPayload<T extends EventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventsGroupByOutputType[P]>
            : GetScalarType<T[P], EventsGroupByOutputType[P]>
        }
      >
    >


  export type eventsSelect = {
    id?: boolean
    title?: boolean
    color?: boolean
    start?: boolean
    end?: boolean
  }


  export type eventsGetPayload<S extends boolean | null | undefined | eventsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? events :
    S extends undefined ? never :
    S extends { include: any } & (eventsArgs | eventsFindManyArgs)
    ? events 
    : S extends { select: any } & (eventsArgs | eventsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof events ? events[P] : never
  } 
      : events


  type eventsCountArgs = 
    Omit<eventsFindManyArgs, 'select' | 'include'> & {
      select?: EventsCountAggregateInputType | true
    }

  export interface eventsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Events that matches the filter.
     * @param {eventsFindUniqueArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends eventsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, eventsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'events'> extends True ? Prisma__eventsClient<eventsGetPayload<T>> : Prisma__eventsClient<eventsGetPayload<T> | null, null>

    /**
     * Find one Events that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {eventsFindUniqueOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends eventsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, eventsFindUniqueOrThrowArgs>
    ): Prisma__eventsClient<eventsGetPayload<T>>

    /**
     * Find the first Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsFindFirstArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends eventsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, eventsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'events'> extends True ? Prisma__eventsClient<eventsGetPayload<T>> : Prisma__eventsClient<eventsGetPayload<T> | null, null>

    /**
     * Find the first Events that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsFindFirstOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends eventsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, eventsFindFirstOrThrowArgs>
    ): Prisma__eventsClient<eventsGetPayload<T>>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.events.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventsWithIdOnly = await prisma.events.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends eventsFindManyArgs>(
      args?: SelectSubset<T, eventsFindManyArgs>
    ): Prisma.PrismaPromise<Array<eventsGetPayload<T>>>

    /**
     * Create a Events.
     * @param {eventsCreateArgs} args - Arguments to create a Events.
     * @example
     * // Create one Events
     * const Events = await prisma.events.create({
     *   data: {
     *     // ... data to create a Events
     *   }
     * })
     * 
    **/
    create<T extends eventsCreateArgs>(
      args: SelectSubset<T, eventsCreateArgs>
    ): Prisma__eventsClient<eventsGetPayload<T>>

    /**
     * Create many Events.
     *     @param {eventsCreateManyArgs} args - Arguments to create many Events.
     *     @example
     *     // Create many Events
     *     const events = await prisma.events.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends eventsCreateManyArgs>(
      args?: SelectSubset<T, eventsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Events.
     * @param {eventsDeleteArgs} args - Arguments to delete one Events.
     * @example
     * // Delete one Events
     * const Events = await prisma.events.delete({
     *   where: {
     *     // ... filter to delete one Events
     *   }
     * })
     * 
    **/
    delete<T extends eventsDeleteArgs>(
      args: SelectSubset<T, eventsDeleteArgs>
    ): Prisma__eventsClient<eventsGetPayload<T>>

    /**
     * Update one Events.
     * @param {eventsUpdateArgs} args - Arguments to update one Events.
     * @example
     * // Update one Events
     * const events = await prisma.events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends eventsUpdateArgs>(
      args: SelectSubset<T, eventsUpdateArgs>
    ): Prisma__eventsClient<eventsGetPayload<T>>

    /**
     * Delete zero or more Events.
     * @param {eventsDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends eventsDeleteManyArgs>(
      args?: SelectSubset<T, eventsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends eventsUpdateManyArgs>(
      args: SelectSubset<T, eventsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Events.
     * @param {eventsUpsertArgs} args - Arguments to update or create a Events.
     * @example
     * // Update or create a Events
     * const events = await prisma.events.upsert({
     *   create: {
     *     // ... data to create a Events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Events we want to update
     *   }
     * })
    **/
    upsert<T extends eventsUpsertArgs>(
      args: SelectSubset<T, eventsUpsertArgs>
    ): Prisma__eventsClient<eventsGetPayload<T>>

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.events.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends eventsCountArgs>(
      args?: Subset<T, eventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventsAggregateArgs>(args: Subset<T, EventsAggregateArgs>): Prisma.PrismaPromise<GetEventsAggregateType<T>>

    /**
     * Group by Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventsGroupByArgs['orderBy'] }
        : { orderBy?: EventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__eventsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * events base type for findUnique actions
   */
  export type eventsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect | null
    /**
     * Filter, which events to fetch.
     */
    where: eventsWhereUniqueInput
  }

  /**
   * events findUnique
   */
  export interface eventsFindUniqueArgs extends eventsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * events findUniqueOrThrow
   */
  export type eventsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect | null
    /**
     * Filter, which events to fetch.
     */
    where: eventsWhereUniqueInput
  }


  /**
   * events base type for findFirst actions
   */
  export type eventsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: Enumerable<eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: Enumerable<EventsScalarFieldEnum>
  }

  /**
   * events findFirst
   */
  export interface eventsFindFirstArgs extends eventsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * events findFirstOrThrow
   */
  export type eventsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: Enumerable<eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: Enumerable<EventsScalarFieldEnum>
  }


  /**
   * events findMany
   */
  export type eventsFindManyArgs = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: Enumerable<eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing events.
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    distinct?: Enumerable<EventsScalarFieldEnum>
  }


  /**
   * events create
   */
  export type eventsCreateArgs = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect | null
    /**
     * The data needed to create a events.
     */
    data: XOR<eventsCreateInput, eventsUncheckedCreateInput>
  }


  /**
   * events createMany
   */
  export type eventsCreateManyArgs = {
    /**
     * The data used to create many events.
     */
    data: Enumerable<eventsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * events update
   */
  export type eventsUpdateArgs = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect | null
    /**
     * The data needed to update a events.
     */
    data: XOR<eventsUpdateInput, eventsUncheckedUpdateInput>
    /**
     * Choose, which events to update.
     */
    where: eventsWhereUniqueInput
  }


  /**
   * events updateMany
   */
  export type eventsUpdateManyArgs = {
    /**
     * The data used to update events.
     */
    data: XOR<eventsUpdateManyMutationInput, eventsUncheckedUpdateManyInput>
    /**
     * Filter which events to update
     */
    where?: eventsWhereInput
  }


  /**
   * events upsert
   */
  export type eventsUpsertArgs = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect | null
    /**
     * The filter to search for the events to update in case it exists.
     */
    where: eventsWhereUniqueInput
    /**
     * In case the events found by the `where` argument doesn't exist, create a new events with this data.
     */
    create: XOR<eventsCreateInput, eventsUncheckedCreateInput>
    /**
     * In case the events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventsUpdateInput, eventsUncheckedUpdateInput>
  }


  /**
   * events delete
   */
  export type eventsDeleteArgs = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect | null
    /**
     * Filter which events to delete.
     */
    where: eventsWhereUniqueInput
  }


  /**
   * events deleteMany
   */
  export type eventsDeleteManyArgs = {
    /**
     * Filter which events to delete
     */
    where?: eventsWhereInput
  }


  /**
   * events without action
   */
  export type eventsArgs = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect | null
  }



  /**
   * Model recordInfo
   */


  export type AggregateRecordInfo = {
    _count: RecordInfoCountAggregateOutputType | null
    _avg: RecordInfoAvgAggregateOutputType | null
    _sum: RecordInfoSumAggregateOutputType | null
    _min: RecordInfoMinAggregateOutputType | null
    _max: RecordInfoMaxAggregateOutputType | null
  }

  export type RecordInfoAvgAggregateOutputType = {
    recordInfo_ID: number | null
    categoryID: number | null
  }

  export type RecordInfoSumAggregateOutputType = {
    recordInfo_ID: number | null
    categoryID: number | null
  }

  export type RecordInfoMinAggregateOutputType = {
    recordInfo_ID: number | null
    categoryID: number | null
    Name: string | null
    StreetAddress: string | null
    City: string | null
    PostalCode: string | null
    Province: string | null
    Telephone: string | null
    Fax: string | null
    Website: string | null
  }

  export type RecordInfoMaxAggregateOutputType = {
    recordInfo_ID: number | null
    categoryID: number | null
    Name: string | null
    StreetAddress: string | null
    City: string | null
    PostalCode: string | null
    Province: string | null
    Telephone: string | null
    Fax: string | null
    Website: string | null
  }

  export type RecordInfoCountAggregateOutputType = {
    recordInfo_ID: number
    categoryID: number
    Name: number
    StreetAddress: number
    City: number
    PostalCode: number
    Province: number
    Telephone: number
    Fax: number
    Website: number
    _all: number
  }


  export type RecordInfoAvgAggregateInputType = {
    recordInfo_ID?: true
    categoryID?: true
  }

  export type RecordInfoSumAggregateInputType = {
    recordInfo_ID?: true
    categoryID?: true
  }

  export type RecordInfoMinAggregateInputType = {
    recordInfo_ID?: true
    categoryID?: true
    Name?: true
    StreetAddress?: true
    City?: true
    PostalCode?: true
    Province?: true
    Telephone?: true
    Fax?: true
    Website?: true
  }

  export type RecordInfoMaxAggregateInputType = {
    recordInfo_ID?: true
    categoryID?: true
    Name?: true
    StreetAddress?: true
    City?: true
    PostalCode?: true
    Province?: true
    Telephone?: true
    Fax?: true
    Website?: true
  }

  export type RecordInfoCountAggregateInputType = {
    recordInfo_ID?: true
    categoryID?: true
    Name?: true
    StreetAddress?: true
    City?: true
    PostalCode?: true
    Province?: true
    Telephone?: true
    Fax?: true
    Website?: true
    _all?: true
  }

  export type RecordInfoAggregateArgs = {
    /**
     * Filter which recordInfo to aggregate.
     */
    where?: recordInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recordInfos to fetch.
     */
    orderBy?: Enumerable<recordInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recordInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recordInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recordInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recordInfos
    **/
    _count?: true | RecordInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecordInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecordInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecordInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecordInfoMaxAggregateInputType
  }

  export type GetRecordInfoAggregateType<T extends RecordInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateRecordInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecordInfo[P]>
      : GetScalarType<T[P], AggregateRecordInfo[P]>
  }




  export type RecordInfoGroupByArgs = {
    where?: recordInfoWhereInput
    orderBy?: Enumerable<recordInfoOrderByWithAggregationInput>
    by: RecordInfoScalarFieldEnum[]
    having?: recordInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecordInfoCountAggregateInputType | true
    _avg?: RecordInfoAvgAggregateInputType
    _sum?: RecordInfoSumAggregateInputType
    _min?: RecordInfoMinAggregateInputType
    _max?: RecordInfoMaxAggregateInputType
  }


  export type RecordInfoGroupByOutputType = {
    recordInfo_ID: number
    categoryID: number | null
    Name: string | null
    StreetAddress: string | null
    City: string | null
    PostalCode: string | null
    Province: string | null
    Telephone: string | null
    Fax: string | null
    Website: string | null
    _count: RecordInfoCountAggregateOutputType | null
    _avg: RecordInfoAvgAggregateOutputType | null
    _sum: RecordInfoSumAggregateOutputType | null
    _min: RecordInfoMinAggregateOutputType | null
    _max: RecordInfoMaxAggregateOutputType | null
  }

  type GetRecordInfoGroupByPayload<T extends RecordInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RecordInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecordInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecordInfoGroupByOutputType[P]>
            : GetScalarType<T[P], RecordInfoGroupByOutputType[P]>
        }
      >
    >


  export type recordInfoSelect = {
    recordInfo_ID?: boolean
    categoryID?: boolean
    Name?: boolean
    StreetAddress?: boolean
    City?: boolean
    PostalCode?: boolean
    Province?: boolean
    Telephone?: boolean
    Fax?: boolean
    Website?: boolean
  }


  export type recordInfoGetPayload<S extends boolean | null | undefined | recordInfoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? recordInfo :
    S extends undefined ? never :
    S extends { include: any } & (recordInfoArgs | recordInfoFindManyArgs)
    ? recordInfo 
    : S extends { select: any } & (recordInfoArgs | recordInfoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof recordInfo ? recordInfo[P] : never
  } 
      : recordInfo


  type recordInfoCountArgs = 
    Omit<recordInfoFindManyArgs, 'select' | 'include'> & {
      select?: RecordInfoCountAggregateInputType | true
    }

  export interface recordInfoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RecordInfo that matches the filter.
     * @param {recordInfoFindUniqueArgs} args - Arguments to find a RecordInfo
     * @example
     * // Get one RecordInfo
     * const recordInfo = await prisma.recordInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends recordInfoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, recordInfoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'recordInfo'> extends True ? Prisma__recordInfoClient<recordInfoGetPayload<T>> : Prisma__recordInfoClient<recordInfoGetPayload<T> | null, null>

    /**
     * Find one RecordInfo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {recordInfoFindUniqueOrThrowArgs} args - Arguments to find a RecordInfo
     * @example
     * // Get one RecordInfo
     * const recordInfo = await prisma.recordInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends recordInfoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, recordInfoFindUniqueOrThrowArgs>
    ): Prisma__recordInfoClient<recordInfoGetPayload<T>>

    /**
     * Find the first RecordInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recordInfoFindFirstArgs} args - Arguments to find a RecordInfo
     * @example
     * // Get one RecordInfo
     * const recordInfo = await prisma.recordInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends recordInfoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, recordInfoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'recordInfo'> extends True ? Prisma__recordInfoClient<recordInfoGetPayload<T>> : Prisma__recordInfoClient<recordInfoGetPayload<T> | null, null>

    /**
     * Find the first RecordInfo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recordInfoFindFirstOrThrowArgs} args - Arguments to find a RecordInfo
     * @example
     * // Get one RecordInfo
     * const recordInfo = await prisma.recordInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends recordInfoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, recordInfoFindFirstOrThrowArgs>
    ): Prisma__recordInfoClient<recordInfoGetPayload<T>>

    /**
     * Find zero or more RecordInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recordInfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecordInfos
     * const recordInfos = await prisma.recordInfo.findMany()
     * 
     * // Get first 10 RecordInfos
     * const recordInfos = await prisma.recordInfo.findMany({ take: 10 })
     * 
     * // Only select the `recordInfo_ID`
     * const recordInfoWithRecordInfo_IDOnly = await prisma.recordInfo.findMany({ select: { recordInfo_ID: true } })
     * 
    **/
    findMany<T extends recordInfoFindManyArgs>(
      args?: SelectSubset<T, recordInfoFindManyArgs>
    ): Prisma.PrismaPromise<Array<recordInfoGetPayload<T>>>

    /**
     * Create a RecordInfo.
     * @param {recordInfoCreateArgs} args - Arguments to create a RecordInfo.
     * @example
     * // Create one RecordInfo
     * const RecordInfo = await prisma.recordInfo.create({
     *   data: {
     *     // ... data to create a RecordInfo
     *   }
     * })
     * 
    **/
    create<T extends recordInfoCreateArgs>(
      args: SelectSubset<T, recordInfoCreateArgs>
    ): Prisma__recordInfoClient<recordInfoGetPayload<T>>

    /**
     * Create many RecordInfos.
     *     @param {recordInfoCreateManyArgs} args - Arguments to create many RecordInfos.
     *     @example
     *     // Create many RecordInfos
     *     const recordInfo = await prisma.recordInfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends recordInfoCreateManyArgs>(
      args?: SelectSubset<T, recordInfoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecordInfo.
     * @param {recordInfoDeleteArgs} args - Arguments to delete one RecordInfo.
     * @example
     * // Delete one RecordInfo
     * const RecordInfo = await prisma.recordInfo.delete({
     *   where: {
     *     // ... filter to delete one RecordInfo
     *   }
     * })
     * 
    **/
    delete<T extends recordInfoDeleteArgs>(
      args: SelectSubset<T, recordInfoDeleteArgs>
    ): Prisma__recordInfoClient<recordInfoGetPayload<T>>

    /**
     * Update one RecordInfo.
     * @param {recordInfoUpdateArgs} args - Arguments to update one RecordInfo.
     * @example
     * // Update one RecordInfo
     * const recordInfo = await prisma.recordInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends recordInfoUpdateArgs>(
      args: SelectSubset<T, recordInfoUpdateArgs>
    ): Prisma__recordInfoClient<recordInfoGetPayload<T>>

    /**
     * Delete zero or more RecordInfos.
     * @param {recordInfoDeleteManyArgs} args - Arguments to filter RecordInfos to delete.
     * @example
     * // Delete a few RecordInfos
     * const { count } = await prisma.recordInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends recordInfoDeleteManyArgs>(
      args?: SelectSubset<T, recordInfoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecordInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recordInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecordInfos
     * const recordInfo = await prisma.recordInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends recordInfoUpdateManyArgs>(
      args: SelectSubset<T, recordInfoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecordInfo.
     * @param {recordInfoUpsertArgs} args - Arguments to update or create a RecordInfo.
     * @example
     * // Update or create a RecordInfo
     * const recordInfo = await prisma.recordInfo.upsert({
     *   create: {
     *     // ... data to create a RecordInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecordInfo we want to update
     *   }
     * })
    **/
    upsert<T extends recordInfoUpsertArgs>(
      args: SelectSubset<T, recordInfoUpsertArgs>
    ): Prisma__recordInfoClient<recordInfoGetPayload<T>>

    /**
     * Count the number of RecordInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recordInfoCountArgs} args - Arguments to filter RecordInfos to count.
     * @example
     * // Count the number of RecordInfos
     * const count = await prisma.recordInfo.count({
     *   where: {
     *     // ... the filter for the RecordInfos we want to count
     *   }
     * })
    **/
    count<T extends recordInfoCountArgs>(
      args?: Subset<T, recordInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecordInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecordInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecordInfoAggregateArgs>(args: Subset<T, RecordInfoAggregateArgs>): Prisma.PrismaPromise<GetRecordInfoAggregateType<T>>

    /**
     * Group by RecordInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecordInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecordInfoGroupByArgs['orderBy'] }
        : { orderBy?: RecordInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecordInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecordInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for recordInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__recordInfoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * recordInfo base type for findUnique actions
   */
  export type recordInfoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the recordInfo
     */
    select?: recordInfoSelect | null
    /**
     * Filter, which recordInfo to fetch.
     */
    where: recordInfoWhereUniqueInput
  }

  /**
   * recordInfo findUnique
   */
  export interface recordInfoFindUniqueArgs extends recordInfoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * recordInfo findUniqueOrThrow
   */
  export type recordInfoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the recordInfo
     */
    select?: recordInfoSelect | null
    /**
     * Filter, which recordInfo to fetch.
     */
    where: recordInfoWhereUniqueInput
  }


  /**
   * recordInfo base type for findFirst actions
   */
  export type recordInfoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the recordInfo
     */
    select?: recordInfoSelect | null
    /**
     * Filter, which recordInfo to fetch.
     */
    where?: recordInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recordInfos to fetch.
     */
    orderBy?: Enumerable<recordInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recordInfos.
     */
    cursor?: recordInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recordInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recordInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recordInfos.
     */
    distinct?: Enumerable<RecordInfoScalarFieldEnum>
  }

  /**
   * recordInfo findFirst
   */
  export interface recordInfoFindFirstArgs extends recordInfoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * recordInfo findFirstOrThrow
   */
  export type recordInfoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the recordInfo
     */
    select?: recordInfoSelect | null
    /**
     * Filter, which recordInfo to fetch.
     */
    where?: recordInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recordInfos to fetch.
     */
    orderBy?: Enumerable<recordInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recordInfos.
     */
    cursor?: recordInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recordInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recordInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recordInfos.
     */
    distinct?: Enumerable<RecordInfoScalarFieldEnum>
  }


  /**
   * recordInfo findMany
   */
  export type recordInfoFindManyArgs = {
    /**
     * Select specific fields to fetch from the recordInfo
     */
    select?: recordInfoSelect | null
    /**
     * Filter, which recordInfos to fetch.
     */
    where?: recordInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recordInfos to fetch.
     */
    orderBy?: Enumerable<recordInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recordInfos.
     */
    cursor?: recordInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recordInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recordInfos.
     */
    skip?: number
    distinct?: Enumerable<RecordInfoScalarFieldEnum>
  }


  /**
   * recordInfo create
   */
  export type recordInfoCreateArgs = {
    /**
     * Select specific fields to fetch from the recordInfo
     */
    select?: recordInfoSelect | null
    /**
     * The data needed to create a recordInfo.
     */
    data?: XOR<recordInfoCreateInput, recordInfoUncheckedCreateInput>
  }


  /**
   * recordInfo createMany
   */
  export type recordInfoCreateManyArgs = {
    /**
     * The data used to create many recordInfos.
     */
    data: Enumerable<recordInfoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * recordInfo update
   */
  export type recordInfoUpdateArgs = {
    /**
     * Select specific fields to fetch from the recordInfo
     */
    select?: recordInfoSelect | null
    /**
     * The data needed to update a recordInfo.
     */
    data: XOR<recordInfoUpdateInput, recordInfoUncheckedUpdateInput>
    /**
     * Choose, which recordInfo to update.
     */
    where: recordInfoWhereUniqueInput
  }


  /**
   * recordInfo updateMany
   */
  export type recordInfoUpdateManyArgs = {
    /**
     * The data used to update recordInfos.
     */
    data: XOR<recordInfoUpdateManyMutationInput, recordInfoUncheckedUpdateManyInput>
    /**
     * Filter which recordInfos to update
     */
    where?: recordInfoWhereInput
  }


  /**
   * recordInfo upsert
   */
  export type recordInfoUpsertArgs = {
    /**
     * Select specific fields to fetch from the recordInfo
     */
    select?: recordInfoSelect | null
    /**
     * The filter to search for the recordInfo to update in case it exists.
     */
    where: recordInfoWhereUniqueInput
    /**
     * In case the recordInfo found by the `where` argument doesn't exist, create a new recordInfo with this data.
     */
    create: XOR<recordInfoCreateInput, recordInfoUncheckedCreateInput>
    /**
     * In case the recordInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recordInfoUpdateInput, recordInfoUncheckedUpdateInput>
  }


  /**
   * recordInfo delete
   */
  export type recordInfoDeleteArgs = {
    /**
     * Select specific fields to fetch from the recordInfo
     */
    select?: recordInfoSelect | null
    /**
     * Filter which recordInfo to delete.
     */
    where: recordInfoWhereUniqueInput
  }


  /**
   * recordInfo deleteMany
   */
  export type recordInfoDeleteManyArgs = {
    /**
     * Filter which recordInfos to delete
     */
    where?: recordInfoWhereInput
  }


  /**
   * recordInfo without action
   */
  export type recordInfoArgs = {
    /**
     * Select specific fields to fetch from the recordInfo
     */
    select?: recordInfoSelect | null
  }



  /**
   * Model tbl_BMORun2024_Barrage
   */


  export type AggregateTbl_BMORun2024_Barrage = {
    _count: Tbl_BMORun2024_BarrageCountAggregateOutputType | null
    _avg: Tbl_BMORun2024_BarrageAvgAggregateOutputType | null
    _sum: Tbl_BMORun2024_BarrageSumAggregateOutputType | null
    _min: Tbl_BMORun2024_BarrageMinAggregateOutputType | null
    _max: Tbl_BMORun2024_BarrageMaxAggregateOutputType | null
  }

  export type Tbl_BMORun2024_BarrageAvgAggregateOutputType = {
    ID: number | null
    donor_Amount: Decimal | null
  }

  export type Tbl_BMORun2024_BarrageSumAggregateOutputType = {
    ID: number | null
    donor_Amount: Decimal | null
  }

  export type Tbl_BMORun2024_BarrageMinAggregateOutputType = {
    ID: number | null
    donor_Fname: string | null
    donor_Lname: string | null
    donor_Org: string | null
    donor_Amount: Decimal | null
    createdAt: string | null
  }

  export type Tbl_BMORun2024_BarrageMaxAggregateOutputType = {
    ID: number | null
    donor_Fname: string | null
    donor_Lname: string | null
    donor_Org: string | null
    donor_Amount: Decimal | null
    createdAt: string | null
  }

  export type Tbl_BMORun2024_BarrageCountAggregateOutputType = {
    ID: number
    donor_Fname: number
    donor_Lname: number
    donor_Org: number
    donor_Amount: number
    createdAt: number
    _all: number
  }


  export type Tbl_BMORun2024_BarrageAvgAggregateInputType = {
    ID?: true
    donor_Amount?: true
  }

  export type Tbl_BMORun2024_BarrageSumAggregateInputType = {
    ID?: true
    donor_Amount?: true
  }

  export type Tbl_BMORun2024_BarrageMinAggregateInputType = {
    ID?: true
    donor_Fname?: true
    donor_Lname?: true
    donor_Org?: true
    donor_Amount?: true
    createdAt?: true
  }

  export type Tbl_BMORun2024_BarrageMaxAggregateInputType = {
    ID?: true
    donor_Fname?: true
    donor_Lname?: true
    donor_Org?: true
    donor_Amount?: true
    createdAt?: true
  }

  export type Tbl_BMORun2024_BarrageCountAggregateInputType = {
    ID?: true
    donor_Fname?: true
    donor_Lname?: true
    donor_Org?: true
    donor_Amount?: true
    createdAt?: true
    _all?: true
  }

  export type Tbl_BMORun2024_BarrageAggregateArgs = {
    /**
     * Filter which tbl_BMORun2024_Barrage to aggregate.
     */
    where?: tbl_BMORun2024_BarrageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_BMORun2024_Barrages to fetch.
     */
    orderBy?: Enumerable<tbl_BMORun2024_BarrageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tbl_BMORun2024_BarrageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_BMORun2024_Barrages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_BMORun2024_Barrages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tbl_BMORun2024_Barrages
    **/
    _count?: true | Tbl_BMORun2024_BarrageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tbl_BMORun2024_BarrageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tbl_BMORun2024_BarrageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tbl_BMORun2024_BarrageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tbl_BMORun2024_BarrageMaxAggregateInputType
  }

  export type GetTbl_BMORun2024_BarrageAggregateType<T extends Tbl_BMORun2024_BarrageAggregateArgs> = {
        [P in keyof T & keyof AggregateTbl_BMORun2024_Barrage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTbl_BMORun2024_Barrage[P]>
      : GetScalarType<T[P], AggregateTbl_BMORun2024_Barrage[P]>
  }




  export type Tbl_BMORun2024_BarrageGroupByArgs = {
    where?: tbl_BMORun2024_BarrageWhereInput
    orderBy?: Enumerable<tbl_BMORun2024_BarrageOrderByWithAggregationInput>
    by: Tbl_BMORun2024_BarrageScalarFieldEnum[]
    having?: tbl_BMORun2024_BarrageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tbl_BMORun2024_BarrageCountAggregateInputType | true
    _avg?: Tbl_BMORun2024_BarrageAvgAggregateInputType
    _sum?: Tbl_BMORun2024_BarrageSumAggregateInputType
    _min?: Tbl_BMORun2024_BarrageMinAggregateInputType
    _max?: Tbl_BMORun2024_BarrageMaxAggregateInputType
  }


  export type Tbl_BMORun2024_BarrageGroupByOutputType = {
    ID: number
    donor_Fname: string | null
    donor_Lname: string | null
    donor_Org: string | null
    donor_Amount: Decimal | null
    createdAt: string
    _count: Tbl_BMORun2024_BarrageCountAggregateOutputType | null
    _avg: Tbl_BMORun2024_BarrageAvgAggregateOutputType | null
    _sum: Tbl_BMORun2024_BarrageSumAggregateOutputType | null
    _min: Tbl_BMORun2024_BarrageMinAggregateOutputType | null
    _max: Tbl_BMORun2024_BarrageMaxAggregateOutputType | null
  }

  type GetTbl_BMORun2024_BarrageGroupByPayload<T extends Tbl_BMORun2024_BarrageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Tbl_BMORun2024_BarrageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tbl_BMORun2024_BarrageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tbl_BMORun2024_BarrageGroupByOutputType[P]>
            : GetScalarType<T[P], Tbl_BMORun2024_BarrageGroupByOutputType[P]>
        }
      >
    >


  export type tbl_BMORun2024_BarrageSelect = {
    ID?: boolean
    donor_Fname?: boolean
    donor_Lname?: boolean
    donor_Org?: boolean
    donor_Amount?: boolean
    createdAt?: boolean
  }


  export type tbl_BMORun2024_BarrageGetPayload<S extends boolean | null | undefined | tbl_BMORun2024_BarrageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tbl_BMORun2024_Barrage :
    S extends undefined ? never :
    S extends { include: any } & (tbl_BMORun2024_BarrageArgs | tbl_BMORun2024_BarrageFindManyArgs)
    ? tbl_BMORun2024_Barrage 
    : S extends { select: any } & (tbl_BMORun2024_BarrageArgs | tbl_BMORun2024_BarrageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof tbl_BMORun2024_Barrage ? tbl_BMORun2024_Barrage[P] : never
  } 
      : tbl_BMORun2024_Barrage


  type tbl_BMORun2024_BarrageCountArgs = 
    Omit<tbl_BMORun2024_BarrageFindManyArgs, 'select' | 'include'> & {
      select?: Tbl_BMORun2024_BarrageCountAggregateInputType | true
    }

  export interface tbl_BMORun2024_BarrageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tbl_BMORun2024_Barrage that matches the filter.
     * @param {tbl_BMORun2024_BarrageFindUniqueArgs} args - Arguments to find a Tbl_BMORun2024_Barrage
     * @example
     * // Get one Tbl_BMORun2024_Barrage
     * const tbl_BMORun2024_Barrage = await prisma.tbl_BMORun2024_Barrage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tbl_BMORun2024_BarrageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tbl_BMORun2024_BarrageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tbl_BMORun2024_Barrage'> extends True ? Prisma__tbl_BMORun2024_BarrageClient<tbl_BMORun2024_BarrageGetPayload<T>> : Prisma__tbl_BMORun2024_BarrageClient<tbl_BMORun2024_BarrageGetPayload<T> | null, null>

    /**
     * Find one Tbl_BMORun2024_Barrage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tbl_BMORun2024_BarrageFindUniqueOrThrowArgs} args - Arguments to find a Tbl_BMORun2024_Barrage
     * @example
     * // Get one Tbl_BMORun2024_Barrage
     * const tbl_BMORun2024_Barrage = await prisma.tbl_BMORun2024_Barrage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tbl_BMORun2024_BarrageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tbl_BMORun2024_BarrageFindUniqueOrThrowArgs>
    ): Prisma__tbl_BMORun2024_BarrageClient<tbl_BMORun2024_BarrageGetPayload<T>>

    /**
     * Find the first Tbl_BMORun2024_Barrage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_BMORun2024_BarrageFindFirstArgs} args - Arguments to find a Tbl_BMORun2024_Barrage
     * @example
     * // Get one Tbl_BMORun2024_Barrage
     * const tbl_BMORun2024_Barrage = await prisma.tbl_BMORun2024_Barrage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tbl_BMORun2024_BarrageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tbl_BMORun2024_BarrageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tbl_BMORun2024_Barrage'> extends True ? Prisma__tbl_BMORun2024_BarrageClient<tbl_BMORun2024_BarrageGetPayload<T>> : Prisma__tbl_BMORun2024_BarrageClient<tbl_BMORun2024_BarrageGetPayload<T> | null, null>

    /**
     * Find the first Tbl_BMORun2024_Barrage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_BMORun2024_BarrageFindFirstOrThrowArgs} args - Arguments to find a Tbl_BMORun2024_Barrage
     * @example
     * // Get one Tbl_BMORun2024_Barrage
     * const tbl_BMORun2024_Barrage = await prisma.tbl_BMORun2024_Barrage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tbl_BMORun2024_BarrageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tbl_BMORun2024_BarrageFindFirstOrThrowArgs>
    ): Prisma__tbl_BMORun2024_BarrageClient<tbl_BMORun2024_BarrageGetPayload<T>>

    /**
     * Find zero or more Tbl_BMORun2024_Barrages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_BMORun2024_BarrageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tbl_BMORun2024_Barrages
     * const tbl_BMORun2024_Barrages = await prisma.tbl_BMORun2024_Barrage.findMany()
     * 
     * // Get first 10 Tbl_BMORun2024_Barrages
     * const tbl_BMORun2024_Barrages = await prisma.tbl_BMORun2024_Barrage.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tbl_BMORun2024_BarrageWithIDOnly = await prisma.tbl_BMORun2024_Barrage.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends tbl_BMORun2024_BarrageFindManyArgs>(
      args?: SelectSubset<T, tbl_BMORun2024_BarrageFindManyArgs>
    ): Prisma.PrismaPromise<Array<tbl_BMORun2024_BarrageGetPayload<T>>>

    /**
     * Create a Tbl_BMORun2024_Barrage.
     * @param {tbl_BMORun2024_BarrageCreateArgs} args - Arguments to create a Tbl_BMORun2024_Barrage.
     * @example
     * // Create one Tbl_BMORun2024_Barrage
     * const Tbl_BMORun2024_Barrage = await prisma.tbl_BMORun2024_Barrage.create({
     *   data: {
     *     // ... data to create a Tbl_BMORun2024_Barrage
     *   }
     * })
     * 
    **/
    create<T extends tbl_BMORun2024_BarrageCreateArgs>(
      args: SelectSubset<T, tbl_BMORun2024_BarrageCreateArgs>
    ): Prisma__tbl_BMORun2024_BarrageClient<tbl_BMORun2024_BarrageGetPayload<T>>

    /**
     * Create many Tbl_BMORun2024_Barrages.
     *     @param {tbl_BMORun2024_BarrageCreateManyArgs} args - Arguments to create many Tbl_BMORun2024_Barrages.
     *     @example
     *     // Create many Tbl_BMORun2024_Barrages
     *     const tbl_BMORun2024_Barrage = await prisma.tbl_BMORun2024_Barrage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tbl_BMORun2024_BarrageCreateManyArgs>(
      args?: SelectSubset<T, tbl_BMORun2024_BarrageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tbl_BMORun2024_Barrage.
     * @param {tbl_BMORun2024_BarrageDeleteArgs} args - Arguments to delete one Tbl_BMORun2024_Barrage.
     * @example
     * // Delete one Tbl_BMORun2024_Barrage
     * const Tbl_BMORun2024_Barrage = await prisma.tbl_BMORun2024_Barrage.delete({
     *   where: {
     *     // ... filter to delete one Tbl_BMORun2024_Barrage
     *   }
     * })
     * 
    **/
    delete<T extends tbl_BMORun2024_BarrageDeleteArgs>(
      args: SelectSubset<T, tbl_BMORun2024_BarrageDeleteArgs>
    ): Prisma__tbl_BMORun2024_BarrageClient<tbl_BMORun2024_BarrageGetPayload<T>>

    /**
     * Update one Tbl_BMORun2024_Barrage.
     * @param {tbl_BMORun2024_BarrageUpdateArgs} args - Arguments to update one Tbl_BMORun2024_Barrage.
     * @example
     * // Update one Tbl_BMORun2024_Barrage
     * const tbl_BMORun2024_Barrage = await prisma.tbl_BMORun2024_Barrage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tbl_BMORun2024_BarrageUpdateArgs>(
      args: SelectSubset<T, tbl_BMORun2024_BarrageUpdateArgs>
    ): Prisma__tbl_BMORun2024_BarrageClient<tbl_BMORun2024_BarrageGetPayload<T>>

    /**
     * Delete zero or more Tbl_BMORun2024_Barrages.
     * @param {tbl_BMORun2024_BarrageDeleteManyArgs} args - Arguments to filter Tbl_BMORun2024_Barrages to delete.
     * @example
     * // Delete a few Tbl_BMORun2024_Barrages
     * const { count } = await prisma.tbl_BMORun2024_Barrage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tbl_BMORun2024_BarrageDeleteManyArgs>(
      args?: SelectSubset<T, tbl_BMORun2024_BarrageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tbl_BMORun2024_Barrages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_BMORun2024_BarrageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tbl_BMORun2024_Barrages
     * const tbl_BMORun2024_Barrage = await prisma.tbl_BMORun2024_Barrage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tbl_BMORun2024_BarrageUpdateManyArgs>(
      args: SelectSubset<T, tbl_BMORun2024_BarrageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tbl_BMORun2024_Barrage.
     * @param {tbl_BMORun2024_BarrageUpsertArgs} args - Arguments to update or create a Tbl_BMORun2024_Barrage.
     * @example
     * // Update or create a Tbl_BMORun2024_Barrage
     * const tbl_BMORun2024_Barrage = await prisma.tbl_BMORun2024_Barrage.upsert({
     *   create: {
     *     // ... data to create a Tbl_BMORun2024_Barrage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tbl_BMORun2024_Barrage we want to update
     *   }
     * })
    **/
    upsert<T extends tbl_BMORun2024_BarrageUpsertArgs>(
      args: SelectSubset<T, tbl_BMORun2024_BarrageUpsertArgs>
    ): Prisma__tbl_BMORun2024_BarrageClient<tbl_BMORun2024_BarrageGetPayload<T>>

    /**
     * Count the number of Tbl_BMORun2024_Barrages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_BMORun2024_BarrageCountArgs} args - Arguments to filter Tbl_BMORun2024_Barrages to count.
     * @example
     * // Count the number of Tbl_BMORun2024_Barrages
     * const count = await prisma.tbl_BMORun2024_Barrage.count({
     *   where: {
     *     // ... the filter for the Tbl_BMORun2024_Barrages we want to count
     *   }
     * })
    **/
    count<T extends tbl_BMORun2024_BarrageCountArgs>(
      args?: Subset<T, tbl_BMORun2024_BarrageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tbl_BMORun2024_BarrageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tbl_BMORun2024_Barrage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_BMORun2024_BarrageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tbl_BMORun2024_BarrageAggregateArgs>(args: Subset<T, Tbl_BMORun2024_BarrageAggregateArgs>): Prisma.PrismaPromise<GetTbl_BMORun2024_BarrageAggregateType<T>>

    /**
     * Group by Tbl_BMORun2024_Barrage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_BMORun2024_BarrageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tbl_BMORun2024_BarrageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tbl_BMORun2024_BarrageGroupByArgs['orderBy'] }
        : { orderBy?: Tbl_BMORun2024_BarrageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tbl_BMORun2024_BarrageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTbl_BMORun2024_BarrageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tbl_BMORun2024_Barrage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tbl_BMORun2024_BarrageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tbl_BMORun2024_Barrage base type for findUnique actions
   */
  export type tbl_BMORun2024_BarrageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tbl_BMORun2024_Barrage
     */
    select?: tbl_BMORun2024_BarrageSelect | null
    /**
     * Filter, which tbl_BMORun2024_Barrage to fetch.
     */
    where: tbl_BMORun2024_BarrageWhereUniqueInput
  }

  /**
   * tbl_BMORun2024_Barrage findUnique
   */
  export interface tbl_BMORun2024_BarrageFindUniqueArgs extends tbl_BMORun2024_BarrageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tbl_BMORun2024_Barrage findUniqueOrThrow
   */
  export type tbl_BMORun2024_BarrageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tbl_BMORun2024_Barrage
     */
    select?: tbl_BMORun2024_BarrageSelect | null
    /**
     * Filter, which tbl_BMORun2024_Barrage to fetch.
     */
    where: tbl_BMORun2024_BarrageWhereUniqueInput
  }


  /**
   * tbl_BMORun2024_Barrage base type for findFirst actions
   */
  export type tbl_BMORun2024_BarrageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tbl_BMORun2024_Barrage
     */
    select?: tbl_BMORun2024_BarrageSelect | null
    /**
     * Filter, which tbl_BMORun2024_Barrage to fetch.
     */
    where?: tbl_BMORun2024_BarrageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_BMORun2024_Barrages to fetch.
     */
    orderBy?: Enumerable<tbl_BMORun2024_BarrageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbl_BMORun2024_Barrages.
     */
    cursor?: tbl_BMORun2024_BarrageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_BMORun2024_Barrages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_BMORun2024_Barrages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbl_BMORun2024_Barrages.
     */
    distinct?: Enumerable<Tbl_BMORun2024_BarrageScalarFieldEnum>
  }

  /**
   * tbl_BMORun2024_Barrage findFirst
   */
  export interface tbl_BMORun2024_BarrageFindFirstArgs extends tbl_BMORun2024_BarrageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tbl_BMORun2024_Barrage findFirstOrThrow
   */
  export type tbl_BMORun2024_BarrageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tbl_BMORun2024_Barrage
     */
    select?: tbl_BMORun2024_BarrageSelect | null
    /**
     * Filter, which tbl_BMORun2024_Barrage to fetch.
     */
    where?: tbl_BMORun2024_BarrageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_BMORun2024_Barrages to fetch.
     */
    orderBy?: Enumerable<tbl_BMORun2024_BarrageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbl_BMORun2024_Barrages.
     */
    cursor?: tbl_BMORun2024_BarrageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_BMORun2024_Barrages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_BMORun2024_Barrages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbl_BMORun2024_Barrages.
     */
    distinct?: Enumerable<Tbl_BMORun2024_BarrageScalarFieldEnum>
  }


  /**
   * tbl_BMORun2024_Barrage findMany
   */
  export type tbl_BMORun2024_BarrageFindManyArgs = {
    /**
     * Select specific fields to fetch from the tbl_BMORun2024_Barrage
     */
    select?: tbl_BMORun2024_BarrageSelect | null
    /**
     * Filter, which tbl_BMORun2024_Barrages to fetch.
     */
    where?: tbl_BMORun2024_BarrageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_BMORun2024_Barrages to fetch.
     */
    orderBy?: Enumerable<tbl_BMORun2024_BarrageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tbl_BMORun2024_Barrages.
     */
    cursor?: tbl_BMORun2024_BarrageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_BMORun2024_Barrages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_BMORun2024_Barrages.
     */
    skip?: number
    distinct?: Enumerable<Tbl_BMORun2024_BarrageScalarFieldEnum>
  }


  /**
   * tbl_BMORun2024_Barrage create
   */
  export type tbl_BMORun2024_BarrageCreateArgs = {
    /**
     * Select specific fields to fetch from the tbl_BMORun2024_Barrage
     */
    select?: tbl_BMORun2024_BarrageSelect | null
    /**
     * The data needed to create a tbl_BMORun2024_Barrage.
     */
    data: XOR<tbl_BMORun2024_BarrageCreateInput, tbl_BMORun2024_BarrageUncheckedCreateInput>
  }


  /**
   * tbl_BMORun2024_Barrage createMany
   */
  export type tbl_BMORun2024_BarrageCreateManyArgs = {
    /**
     * The data used to create many tbl_BMORun2024_Barrages.
     */
    data: Enumerable<tbl_BMORun2024_BarrageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tbl_BMORun2024_Barrage update
   */
  export type tbl_BMORun2024_BarrageUpdateArgs = {
    /**
     * Select specific fields to fetch from the tbl_BMORun2024_Barrage
     */
    select?: tbl_BMORun2024_BarrageSelect | null
    /**
     * The data needed to update a tbl_BMORun2024_Barrage.
     */
    data: XOR<tbl_BMORun2024_BarrageUpdateInput, tbl_BMORun2024_BarrageUncheckedUpdateInput>
    /**
     * Choose, which tbl_BMORun2024_Barrage to update.
     */
    where: tbl_BMORun2024_BarrageWhereUniqueInput
  }


  /**
   * tbl_BMORun2024_Barrage updateMany
   */
  export type tbl_BMORun2024_BarrageUpdateManyArgs = {
    /**
     * The data used to update tbl_BMORun2024_Barrages.
     */
    data: XOR<tbl_BMORun2024_BarrageUpdateManyMutationInput, tbl_BMORun2024_BarrageUncheckedUpdateManyInput>
    /**
     * Filter which tbl_BMORun2024_Barrages to update
     */
    where?: tbl_BMORun2024_BarrageWhereInput
  }


  /**
   * tbl_BMORun2024_Barrage upsert
   */
  export type tbl_BMORun2024_BarrageUpsertArgs = {
    /**
     * Select specific fields to fetch from the tbl_BMORun2024_Barrage
     */
    select?: tbl_BMORun2024_BarrageSelect | null
    /**
     * The filter to search for the tbl_BMORun2024_Barrage to update in case it exists.
     */
    where: tbl_BMORun2024_BarrageWhereUniqueInput
    /**
     * In case the tbl_BMORun2024_Barrage found by the `where` argument doesn't exist, create a new tbl_BMORun2024_Barrage with this data.
     */
    create: XOR<tbl_BMORun2024_BarrageCreateInput, tbl_BMORun2024_BarrageUncheckedCreateInput>
    /**
     * In case the tbl_BMORun2024_Barrage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tbl_BMORun2024_BarrageUpdateInput, tbl_BMORun2024_BarrageUncheckedUpdateInput>
  }


  /**
   * tbl_BMORun2024_Barrage delete
   */
  export type tbl_BMORun2024_BarrageDeleteArgs = {
    /**
     * Select specific fields to fetch from the tbl_BMORun2024_Barrage
     */
    select?: tbl_BMORun2024_BarrageSelect | null
    /**
     * Filter which tbl_BMORun2024_Barrage to delete.
     */
    where: tbl_BMORun2024_BarrageWhereUniqueInput
  }


  /**
   * tbl_BMORun2024_Barrage deleteMany
   */
  export type tbl_BMORun2024_BarrageDeleteManyArgs = {
    /**
     * Filter which tbl_BMORun2024_Barrages to delete
     */
    where?: tbl_BMORun2024_BarrageWhereInput
  }


  /**
   * tbl_BMORun2024_Barrage without action
   */
  export type tbl_BMORun2024_BarrageArgs = {
    /**
     * Select specific fields to fetch from the tbl_BMORun2024_Barrage
     */
    select?: tbl_BMORun2024_BarrageSelect | null
  }



  /**
   * Model tbl_ETransferInfo
   */


  export type AggregateTbl_ETransferInfo = {
    _count: Tbl_ETransferInfoCountAggregateOutputType | null
    _avg: Tbl_ETransferInfoAvgAggregateOutputType | null
    _sum: Tbl_ETransferInfoSumAggregateOutputType | null
    _min: Tbl_ETransferInfoMinAggregateOutputType | null
    _max: Tbl_ETransferInfoMaxAggregateOutputType | null
  }

  export type Tbl_ETransferInfoAvgAggregateOutputType = {
    id: number | null
  }

  export type Tbl_ETransferInfoSumAggregateOutputType = {
    id: number | null
  }

  export type Tbl_ETransferInfoMinAggregateOutputType = {
    id: number | null
    fname: string | null
    lname: string | null
    userAddress: string | null
    userTel: string | null
    useremail: string | null
    todaydate: Date | null
    RegDate: Date | null
    RegTime: Date | null
    userIP: string | null
  }

  export type Tbl_ETransferInfoMaxAggregateOutputType = {
    id: number | null
    fname: string | null
    lname: string | null
    userAddress: string | null
    userTel: string | null
    useremail: string | null
    todaydate: Date | null
    RegDate: Date | null
    RegTime: Date | null
    userIP: string | null
  }

  export type Tbl_ETransferInfoCountAggregateOutputType = {
    id: number
    fname: number
    lname: number
    userAddress: number
    userTel: number
    useremail: number
    todaydate: number
    RegDate: number
    RegTime: number
    userIP: number
    _all: number
  }


  export type Tbl_ETransferInfoAvgAggregateInputType = {
    id?: true
  }

  export type Tbl_ETransferInfoSumAggregateInputType = {
    id?: true
  }

  export type Tbl_ETransferInfoMinAggregateInputType = {
    id?: true
    fname?: true
    lname?: true
    userAddress?: true
    userTel?: true
    useremail?: true
    todaydate?: true
    RegDate?: true
    RegTime?: true
    userIP?: true
  }

  export type Tbl_ETransferInfoMaxAggregateInputType = {
    id?: true
    fname?: true
    lname?: true
    userAddress?: true
    userTel?: true
    useremail?: true
    todaydate?: true
    RegDate?: true
    RegTime?: true
    userIP?: true
  }

  export type Tbl_ETransferInfoCountAggregateInputType = {
    id?: true
    fname?: true
    lname?: true
    userAddress?: true
    userTel?: true
    useremail?: true
    todaydate?: true
    RegDate?: true
    RegTime?: true
    userIP?: true
    _all?: true
  }

  export type Tbl_ETransferInfoAggregateArgs = {
    /**
     * Filter which tbl_ETransferInfo to aggregate.
     */
    where?: tbl_ETransferInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_ETransferInfos to fetch.
     */
    orderBy?: Enumerable<tbl_ETransferInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tbl_ETransferInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_ETransferInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_ETransferInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tbl_ETransferInfos
    **/
    _count?: true | Tbl_ETransferInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tbl_ETransferInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tbl_ETransferInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tbl_ETransferInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tbl_ETransferInfoMaxAggregateInputType
  }

  export type GetTbl_ETransferInfoAggregateType<T extends Tbl_ETransferInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateTbl_ETransferInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTbl_ETransferInfo[P]>
      : GetScalarType<T[P], AggregateTbl_ETransferInfo[P]>
  }




  export type Tbl_ETransferInfoGroupByArgs = {
    where?: tbl_ETransferInfoWhereInput
    orderBy?: Enumerable<tbl_ETransferInfoOrderByWithAggregationInput>
    by: Tbl_ETransferInfoScalarFieldEnum[]
    having?: tbl_ETransferInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tbl_ETransferInfoCountAggregateInputType | true
    _avg?: Tbl_ETransferInfoAvgAggregateInputType
    _sum?: Tbl_ETransferInfoSumAggregateInputType
    _min?: Tbl_ETransferInfoMinAggregateInputType
    _max?: Tbl_ETransferInfoMaxAggregateInputType
  }


  export type Tbl_ETransferInfoGroupByOutputType = {
    id: number
    fname: string
    lname: string
    userAddress: string
    userTel: string
    useremail: string
    todaydate: Date
    RegDate: Date
    RegTime: Date
    userIP: string
    _count: Tbl_ETransferInfoCountAggregateOutputType | null
    _avg: Tbl_ETransferInfoAvgAggregateOutputType | null
    _sum: Tbl_ETransferInfoSumAggregateOutputType | null
    _min: Tbl_ETransferInfoMinAggregateOutputType | null
    _max: Tbl_ETransferInfoMaxAggregateOutputType | null
  }

  type GetTbl_ETransferInfoGroupByPayload<T extends Tbl_ETransferInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Tbl_ETransferInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tbl_ETransferInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tbl_ETransferInfoGroupByOutputType[P]>
            : GetScalarType<T[P], Tbl_ETransferInfoGroupByOutputType[P]>
        }
      >
    >


  export type tbl_ETransferInfoSelect = {
    id?: boolean
    fname?: boolean
    lname?: boolean
    userAddress?: boolean
    userTel?: boolean
    useremail?: boolean
    todaydate?: boolean
    RegDate?: boolean
    RegTime?: boolean
    userIP?: boolean
  }


  export type tbl_ETransferInfoGetPayload<S extends boolean | null | undefined | tbl_ETransferInfoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tbl_ETransferInfo :
    S extends undefined ? never :
    S extends { include: any } & (tbl_ETransferInfoArgs | tbl_ETransferInfoFindManyArgs)
    ? tbl_ETransferInfo 
    : S extends { select: any } & (tbl_ETransferInfoArgs | tbl_ETransferInfoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof tbl_ETransferInfo ? tbl_ETransferInfo[P] : never
  } 
      : tbl_ETransferInfo


  type tbl_ETransferInfoCountArgs = 
    Omit<tbl_ETransferInfoFindManyArgs, 'select' | 'include'> & {
      select?: Tbl_ETransferInfoCountAggregateInputType | true
    }

  export interface tbl_ETransferInfoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tbl_ETransferInfo that matches the filter.
     * @param {tbl_ETransferInfoFindUniqueArgs} args - Arguments to find a Tbl_ETransferInfo
     * @example
     * // Get one Tbl_ETransferInfo
     * const tbl_ETransferInfo = await prisma.tbl_ETransferInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tbl_ETransferInfoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tbl_ETransferInfoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tbl_ETransferInfo'> extends True ? Prisma__tbl_ETransferInfoClient<tbl_ETransferInfoGetPayload<T>> : Prisma__tbl_ETransferInfoClient<tbl_ETransferInfoGetPayload<T> | null, null>

    /**
     * Find one Tbl_ETransferInfo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tbl_ETransferInfoFindUniqueOrThrowArgs} args - Arguments to find a Tbl_ETransferInfo
     * @example
     * // Get one Tbl_ETransferInfo
     * const tbl_ETransferInfo = await prisma.tbl_ETransferInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tbl_ETransferInfoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tbl_ETransferInfoFindUniqueOrThrowArgs>
    ): Prisma__tbl_ETransferInfoClient<tbl_ETransferInfoGetPayload<T>>

    /**
     * Find the first Tbl_ETransferInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_ETransferInfoFindFirstArgs} args - Arguments to find a Tbl_ETransferInfo
     * @example
     * // Get one Tbl_ETransferInfo
     * const tbl_ETransferInfo = await prisma.tbl_ETransferInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tbl_ETransferInfoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tbl_ETransferInfoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tbl_ETransferInfo'> extends True ? Prisma__tbl_ETransferInfoClient<tbl_ETransferInfoGetPayload<T>> : Prisma__tbl_ETransferInfoClient<tbl_ETransferInfoGetPayload<T> | null, null>

    /**
     * Find the first Tbl_ETransferInfo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_ETransferInfoFindFirstOrThrowArgs} args - Arguments to find a Tbl_ETransferInfo
     * @example
     * // Get one Tbl_ETransferInfo
     * const tbl_ETransferInfo = await prisma.tbl_ETransferInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tbl_ETransferInfoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tbl_ETransferInfoFindFirstOrThrowArgs>
    ): Prisma__tbl_ETransferInfoClient<tbl_ETransferInfoGetPayload<T>>

    /**
     * Find zero or more Tbl_ETransferInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_ETransferInfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tbl_ETransferInfos
     * const tbl_ETransferInfos = await prisma.tbl_ETransferInfo.findMany()
     * 
     * // Get first 10 Tbl_ETransferInfos
     * const tbl_ETransferInfos = await prisma.tbl_ETransferInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tbl_ETransferInfoWithIdOnly = await prisma.tbl_ETransferInfo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tbl_ETransferInfoFindManyArgs>(
      args?: SelectSubset<T, tbl_ETransferInfoFindManyArgs>
    ): Prisma.PrismaPromise<Array<tbl_ETransferInfoGetPayload<T>>>

    /**
     * Create a Tbl_ETransferInfo.
     * @param {tbl_ETransferInfoCreateArgs} args - Arguments to create a Tbl_ETransferInfo.
     * @example
     * // Create one Tbl_ETransferInfo
     * const Tbl_ETransferInfo = await prisma.tbl_ETransferInfo.create({
     *   data: {
     *     // ... data to create a Tbl_ETransferInfo
     *   }
     * })
     * 
    **/
    create<T extends tbl_ETransferInfoCreateArgs>(
      args: SelectSubset<T, tbl_ETransferInfoCreateArgs>
    ): Prisma__tbl_ETransferInfoClient<tbl_ETransferInfoGetPayload<T>>

    /**
     * Create many Tbl_ETransferInfos.
     *     @param {tbl_ETransferInfoCreateManyArgs} args - Arguments to create many Tbl_ETransferInfos.
     *     @example
     *     // Create many Tbl_ETransferInfos
     *     const tbl_ETransferInfo = await prisma.tbl_ETransferInfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tbl_ETransferInfoCreateManyArgs>(
      args?: SelectSubset<T, tbl_ETransferInfoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tbl_ETransferInfo.
     * @param {tbl_ETransferInfoDeleteArgs} args - Arguments to delete one Tbl_ETransferInfo.
     * @example
     * // Delete one Tbl_ETransferInfo
     * const Tbl_ETransferInfo = await prisma.tbl_ETransferInfo.delete({
     *   where: {
     *     // ... filter to delete one Tbl_ETransferInfo
     *   }
     * })
     * 
    **/
    delete<T extends tbl_ETransferInfoDeleteArgs>(
      args: SelectSubset<T, tbl_ETransferInfoDeleteArgs>
    ): Prisma__tbl_ETransferInfoClient<tbl_ETransferInfoGetPayload<T>>

    /**
     * Update one Tbl_ETransferInfo.
     * @param {tbl_ETransferInfoUpdateArgs} args - Arguments to update one Tbl_ETransferInfo.
     * @example
     * // Update one Tbl_ETransferInfo
     * const tbl_ETransferInfo = await prisma.tbl_ETransferInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tbl_ETransferInfoUpdateArgs>(
      args: SelectSubset<T, tbl_ETransferInfoUpdateArgs>
    ): Prisma__tbl_ETransferInfoClient<tbl_ETransferInfoGetPayload<T>>

    /**
     * Delete zero or more Tbl_ETransferInfos.
     * @param {tbl_ETransferInfoDeleteManyArgs} args - Arguments to filter Tbl_ETransferInfos to delete.
     * @example
     * // Delete a few Tbl_ETransferInfos
     * const { count } = await prisma.tbl_ETransferInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tbl_ETransferInfoDeleteManyArgs>(
      args?: SelectSubset<T, tbl_ETransferInfoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tbl_ETransferInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_ETransferInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tbl_ETransferInfos
     * const tbl_ETransferInfo = await prisma.tbl_ETransferInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tbl_ETransferInfoUpdateManyArgs>(
      args: SelectSubset<T, tbl_ETransferInfoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tbl_ETransferInfo.
     * @param {tbl_ETransferInfoUpsertArgs} args - Arguments to update or create a Tbl_ETransferInfo.
     * @example
     * // Update or create a Tbl_ETransferInfo
     * const tbl_ETransferInfo = await prisma.tbl_ETransferInfo.upsert({
     *   create: {
     *     // ... data to create a Tbl_ETransferInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tbl_ETransferInfo we want to update
     *   }
     * })
    **/
    upsert<T extends tbl_ETransferInfoUpsertArgs>(
      args: SelectSubset<T, tbl_ETransferInfoUpsertArgs>
    ): Prisma__tbl_ETransferInfoClient<tbl_ETransferInfoGetPayload<T>>

    /**
     * Count the number of Tbl_ETransferInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_ETransferInfoCountArgs} args - Arguments to filter Tbl_ETransferInfos to count.
     * @example
     * // Count the number of Tbl_ETransferInfos
     * const count = await prisma.tbl_ETransferInfo.count({
     *   where: {
     *     // ... the filter for the Tbl_ETransferInfos we want to count
     *   }
     * })
    **/
    count<T extends tbl_ETransferInfoCountArgs>(
      args?: Subset<T, tbl_ETransferInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tbl_ETransferInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tbl_ETransferInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_ETransferInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tbl_ETransferInfoAggregateArgs>(args: Subset<T, Tbl_ETransferInfoAggregateArgs>): Prisma.PrismaPromise<GetTbl_ETransferInfoAggregateType<T>>

    /**
     * Group by Tbl_ETransferInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_ETransferInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tbl_ETransferInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tbl_ETransferInfoGroupByArgs['orderBy'] }
        : { orderBy?: Tbl_ETransferInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tbl_ETransferInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTbl_ETransferInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tbl_ETransferInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tbl_ETransferInfoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tbl_ETransferInfo base type for findUnique actions
   */
  export type tbl_ETransferInfoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tbl_ETransferInfo
     */
    select?: tbl_ETransferInfoSelect | null
    /**
     * Filter, which tbl_ETransferInfo to fetch.
     */
    where: tbl_ETransferInfoWhereUniqueInput
  }

  /**
   * tbl_ETransferInfo findUnique
   */
  export interface tbl_ETransferInfoFindUniqueArgs extends tbl_ETransferInfoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tbl_ETransferInfo findUniqueOrThrow
   */
  export type tbl_ETransferInfoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tbl_ETransferInfo
     */
    select?: tbl_ETransferInfoSelect | null
    /**
     * Filter, which tbl_ETransferInfo to fetch.
     */
    where: tbl_ETransferInfoWhereUniqueInput
  }


  /**
   * tbl_ETransferInfo base type for findFirst actions
   */
  export type tbl_ETransferInfoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tbl_ETransferInfo
     */
    select?: tbl_ETransferInfoSelect | null
    /**
     * Filter, which tbl_ETransferInfo to fetch.
     */
    where?: tbl_ETransferInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_ETransferInfos to fetch.
     */
    orderBy?: Enumerable<tbl_ETransferInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbl_ETransferInfos.
     */
    cursor?: tbl_ETransferInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_ETransferInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_ETransferInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbl_ETransferInfos.
     */
    distinct?: Enumerable<Tbl_ETransferInfoScalarFieldEnum>
  }

  /**
   * tbl_ETransferInfo findFirst
   */
  export interface tbl_ETransferInfoFindFirstArgs extends tbl_ETransferInfoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tbl_ETransferInfo findFirstOrThrow
   */
  export type tbl_ETransferInfoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tbl_ETransferInfo
     */
    select?: tbl_ETransferInfoSelect | null
    /**
     * Filter, which tbl_ETransferInfo to fetch.
     */
    where?: tbl_ETransferInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_ETransferInfos to fetch.
     */
    orderBy?: Enumerable<tbl_ETransferInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbl_ETransferInfos.
     */
    cursor?: tbl_ETransferInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_ETransferInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_ETransferInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbl_ETransferInfos.
     */
    distinct?: Enumerable<Tbl_ETransferInfoScalarFieldEnum>
  }


  /**
   * tbl_ETransferInfo findMany
   */
  export type tbl_ETransferInfoFindManyArgs = {
    /**
     * Select specific fields to fetch from the tbl_ETransferInfo
     */
    select?: tbl_ETransferInfoSelect | null
    /**
     * Filter, which tbl_ETransferInfos to fetch.
     */
    where?: tbl_ETransferInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_ETransferInfos to fetch.
     */
    orderBy?: Enumerable<tbl_ETransferInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tbl_ETransferInfos.
     */
    cursor?: tbl_ETransferInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_ETransferInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_ETransferInfos.
     */
    skip?: number
    distinct?: Enumerable<Tbl_ETransferInfoScalarFieldEnum>
  }


  /**
   * tbl_ETransferInfo create
   */
  export type tbl_ETransferInfoCreateArgs = {
    /**
     * Select specific fields to fetch from the tbl_ETransferInfo
     */
    select?: tbl_ETransferInfoSelect | null
    /**
     * The data needed to create a tbl_ETransferInfo.
     */
    data: XOR<tbl_ETransferInfoCreateInput, tbl_ETransferInfoUncheckedCreateInput>
  }


  /**
   * tbl_ETransferInfo createMany
   */
  export type tbl_ETransferInfoCreateManyArgs = {
    /**
     * The data used to create many tbl_ETransferInfos.
     */
    data: Enumerable<tbl_ETransferInfoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tbl_ETransferInfo update
   */
  export type tbl_ETransferInfoUpdateArgs = {
    /**
     * Select specific fields to fetch from the tbl_ETransferInfo
     */
    select?: tbl_ETransferInfoSelect | null
    /**
     * The data needed to update a tbl_ETransferInfo.
     */
    data: XOR<tbl_ETransferInfoUpdateInput, tbl_ETransferInfoUncheckedUpdateInput>
    /**
     * Choose, which tbl_ETransferInfo to update.
     */
    where: tbl_ETransferInfoWhereUniqueInput
  }


  /**
   * tbl_ETransferInfo updateMany
   */
  export type tbl_ETransferInfoUpdateManyArgs = {
    /**
     * The data used to update tbl_ETransferInfos.
     */
    data: XOR<tbl_ETransferInfoUpdateManyMutationInput, tbl_ETransferInfoUncheckedUpdateManyInput>
    /**
     * Filter which tbl_ETransferInfos to update
     */
    where?: tbl_ETransferInfoWhereInput
  }


  /**
   * tbl_ETransferInfo upsert
   */
  export type tbl_ETransferInfoUpsertArgs = {
    /**
     * Select specific fields to fetch from the tbl_ETransferInfo
     */
    select?: tbl_ETransferInfoSelect | null
    /**
     * The filter to search for the tbl_ETransferInfo to update in case it exists.
     */
    where: tbl_ETransferInfoWhereUniqueInput
    /**
     * In case the tbl_ETransferInfo found by the `where` argument doesn't exist, create a new tbl_ETransferInfo with this data.
     */
    create: XOR<tbl_ETransferInfoCreateInput, tbl_ETransferInfoUncheckedCreateInput>
    /**
     * In case the tbl_ETransferInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tbl_ETransferInfoUpdateInput, tbl_ETransferInfoUncheckedUpdateInput>
  }


  /**
   * tbl_ETransferInfo delete
   */
  export type tbl_ETransferInfoDeleteArgs = {
    /**
     * Select specific fields to fetch from the tbl_ETransferInfo
     */
    select?: tbl_ETransferInfoSelect | null
    /**
     * Filter which tbl_ETransferInfo to delete.
     */
    where: tbl_ETransferInfoWhereUniqueInput
  }


  /**
   * tbl_ETransferInfo deleteMany
   */
  export type tbl_ETransferInfoDeleteManyArgs = {
    /**
     * Filter which tbl_ETransferInfos to delete
     */
    where?: tbl_ETransferInfoWhereInput
  }


  /**
   * tbl_ETransferInfo without action
   */
  export type tbl_ETransferInfoArgs = {
    /**
     * Select specific fields to fetch from the tbl_ETransferInfo
     */
    select?: tbl_ETransferInfoSelect | null
  }



  /**
   * Model tbl_TshirtContest
   */


  export type AggregateTbl_TshirtContest = {
    _count: Tbl_TshirtContestCountAggregateOutputType | null
    _avg: Tbl_TshirtContestAvgAggregateOutputType | null
    _sum: Tbl_TshirtContestSumAggregateOutputType | null
    _min: Tbl_TshirtContestMinAggregateOutputType | null
    _max: Tbl_TshirtContestMaxAggregateOutputType | null
  }

  export type Tbl_TshirtContestAvgAggregateOutputType = {
    id: number | null
  }

  export type Tbl_TshirtContestSumAggregateOutputType = {
    id: number | null
  }

  export type Tbl_TshirtContestMinAggregateOutputType = {
    id: number | null
    fname: string | null
    lname: string | null
    tel: string | null
    email: string | null
    notes: string | null
    artwork: string | null
    imgPreview: string | null
    ip: string | null
    submitTime: Date | null
  }

  export type Tbl_TshirtContestMaxAggregateOutputType = {
    id: number | null
    fname: string | null
    lname: string | null
    tel: string | null
    email: string | null
    notes: string | null
    artwork: string | null
    imgPreview: string | null
    ip: string | null
    submitTime: Date | null
  }

  export type Tbl_TshirtContestCountAggregateOutputType = {
    id: number
    fname: number
    lname: number
    tel: number
    email: number
    notes: number
    artwork: number
    imgPreview: number
    ip: number
    submitTime: number
    _all: number
  }


  export type Tbl_TshirtContestAvgAggregateInputType = {
    id?: true
  }

  export type Tbl_TshirtContestSumAggregateInputType = {
    id?: true
  }

  export type Tbl_TshirtContestMinAggregateInputType = {
    id?: true
    fname?: true
    lname?: true
    tel?: true
    email?: true
    notes?: true
    artwork?: true
    imgPreview?: true
    ip?: true
    submitTime?: true
  }

  export type Tbl_TshirtContestMaxAggregateInputType = {
    id?: true
    fname?: true
    lname?: true
    tel?: true
    email?: true
    notes?: true
    artwork?: true
    imgPreview?: true
    ip?: true
    submitTime?: true
  }

  export type Tbl_TshirtContestCountAggregateInputType = {
    id?: true
    fname?: true
    lname?: true
    tel?: true
    email?: true
    notes?: true
    artwork?: true
    imgPreview?: true
    ip?: true
    submitTime?: true
    _all?: true
  }

  export type Tbl_TshirtContestAggregateArgs = {
    /**
     * Filter which tbl_TshirtContest to aggregate.
     */
    where?: tbl_TshirtContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_TshirtContests to fetch.
     */
    orderBy?: Enumerable<tbl_TshirtContestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tbl_TshirtContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_TshirtContests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_TshirtContests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tbl_TshirtContests
    **/
    _count?: true | Tbl_TshirtContestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tbl_TshirtContestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tbl_TshirtContestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tbl_TshirtContestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tbl_TshirtContestMaxAggregateInputType
  }

  export type GetTbl_TshirtContestAggregateType<T extends Tbl_TshirtContestAggregateArgs> = {
        [P in keyof T & keyof AggregateTbl_TshirtContest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTbl_TshirtContest[P]>
      : GetScalarType<T[P], AggregateTbl_TshirtContest[P]>
  }




  export type Tbl_TshirtContestGroupByArgs = {
    where?: tbl_TshirtContestWhereInput
    orderBy?: Enumerable<tbl_TshirtContestOrderByWithAggregationInput>
    by: Tbl_TshirtContestScalarFieldEnum[]
    having?: tbl_TshirtContestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tbl_TshirtContestCountAggregateInputType | true
    _avg?: Tbl_TshirtContestAvgAggregateInputType
    _sum?: Tbl_TshirtContestSumAggregateInputType
    _min?: Tbl_TshirtContestMinAggregateInputType
    _max?: Tbl_TshirtContestMaxAggregateInputType
  }


  export type Tbl_TshirtContestGroupByOutputType = {
    id: number
    fname: string
    lname: string
    tel: string
    email: string
    notes: string
    artwork: string
    imgPreview: string
    ip: string
    submitTime: Date
    _count: Tbl_TshirtContestCountAggregateOutputType | null
    _avg: Tbl_TshirtContestAvgAggregateOutputType | null
    _sum: Tbl_TshirtContestSumAggregateOutputType | null
    _min: Tbl_TshirtContestMinAggregateOutputType | null
    _max: Tbl_TshirtContestMaxAggregateOutputType | null
  }

  type GetTbl_TshirtContestGroupByPayload<T extends Tbl_TshirtContestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Tbl_TshirtContestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tbl_TshirtContestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tbl_TshirtContestGroupByOutputType[P]>
            : GetScalarType<T[P], Tbl_TshirtContestGroupByOutputType[P]>
        }
      >
    >


  export type tbl_TshirtContestSelect = {
    id?: boolean
    fname?: boolean
    lname?: boolean
    tel?: boolean
    email?: boolean
    notes?: boolean
    artwork?: boolean
    imgPreview?: boolean
    ip?: boolean
    submitTime?: boolean
  }


  export type tbl_TshirtContestGetPayload<S extends boolean | null | undefined | tbl_TshirtContestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tbl_TshirtContest :
    S extends undefined ? never :
    S extends { include: any } & (tbl_TshirtContestArgs | tbl_TshirtContestFindManyArgs)
    ? tbl_TshirtContest 
    : S extends { select: any } & (tbl_TshirtContestArgs | tbl_TshirtContestFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof tbl_TshirtContest ? tbl_TshirtContest[P] : never
  } 
      : tbl_TshirtContest


  type tbl_TshirtContestCountArgs = 
    Omit<tbl_TshirtContestFindManyArgs, 'select' | 'include'> & {
      select?: Tbl_TshirtContestCountAggregateInputType | true
    }

  export interface tbl_TshirtContestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tbl_TshirtContest that matches the filter.
     * @param {tbl_TshirtContestFindUniqueArgs} args - Arguments to find a Tbl_TshirtContest
     * @example
     * // Get one Tbl_TshirtContest
     * const tbl_TshirtContest = await prisma.tbl_TshirtContest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tbl_TshirtContestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tbl_TshirtContestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tbl_TshirtContest'> extends True ? Prisma__tbl_TshirtContestClient<tbl_TshirtContestGetPayload<T>> : Prisma__tbl_TshirtContestClient<tbl_TshirtContestGetPayload<T> | null, null>

    /**
     * Find one Tbl_TshirtContest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tbl_TshirtContestFindUniqueOrThrowArgs} args - Arguments to find a Tbl_TshirtContest
     * @example
     * // Get one Tbl_TshirtContest
     * const tbl_TshirtContest = await prisma.tbl_TshirtContest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tbl_TshirtContestFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tbl_TshirtContestFindUniqueOrThrowArgs>
    ): Prisma__tbl_TshirtContestClient<tbl_TshirtContestGetPayload<T>>

    /**
     * Find the first Tbl_TshirtContest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_TshirtContestFindFirstArgs} args - Arguments to find a Tbl_TshirtContest
     * @example
     * // Get one Tbl_TshirtContest
     * const tbl_TshirtContest = await prisma.tbl_TshirtContest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tbl_TshirtContestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tbl_TshirtContestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tbl_TshirtContest'> extends True ? Prisma__tbl_TshirtContestClient<tbl_TshirtContestGetPayload<T>> : Prisma__tbl_TshirtContestClient<tbl_TshirtContestGetPayload<T> | null, null>

    /**
     * Find the first Tbl_TshirtContest that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_TshirtContestFindFirstOrThrowArgs} args - Arguments to find a Tbl_TshirtContest
     * @example
     * // Get one Tbl_TshirtContest
     * const tbl_TshirtContest = await prisma.tbl_TshirtContest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tbl_TshirtContestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tbl_TshirtContestFindFirstOrThrowArgs>
    ): Prisma__tbl_TshirtContestClient<tbl_TshirtContestGetPayload<T>>

    /**
     * Find zero or more Tbl_TshirtContests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_TshirtContestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tbl_TshirtContests
     * const tbl_TshirtContests = await prisma.tbl_TshirtContest.findMany()
     * 
     * // Get first 10 Tbl_TshirtContests
     * const tbl_TshirtContests = await prisma.tbl_TshirtContest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tbl_TshirtContestWithIdOnly = await prisma.tbl_TshirtContest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tbl_TshirtContestFindManyArgs>(
      args?: SelectSubset<T, tbl_TshirtContestFindManyArgs>
    ): Prisma.PrismaPromise<Array<tbl_TshirtContestGetPayload<T>>>

    /**
     * Create a Tbl_TshirtContest.
     * @param {tbl_TshirtContestCreateArgs} args - Arguments to create a Tbl_TshirtContest.
     * @example
     * // Create one Tbl_TshirtContest
     * const Tbl_TshirtContest = await prisma.tbl_TshirtContest.create({
     *   data: {
     *     // ... data to create a Tbl_TshirtContest
     *   }
     * })
     * 
    **/
    create<T extends tbl_TshirtContestCreateArgs>(
      args: SelectSubset<T, tbl_TshirtContestCreateArgs>
    ): Prisma__tbl_TshirtContestClient<tbl_TshirtContestGetPayload<T>>

    /**
     * Create many Tbl_TshirtContests.
     *     @param {tbl_TshirtContestCreateManyArgs} args - Arguments to create many Tbl_TshirtContests.
     *     @example
     *     // Create many Tbl_TshirtContests
     *     const tbl_TshirtContest = await prisma.tbl_TshirtContest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tbl_TshirtContestCreateManyArgs>(
      args?: SelectSubset<T, tbl_TshirtContestCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tbl_TshirtContest.
     * @param {tbl_TshirtContestDeleteArgs} args - Arguments to delete one Tbl_TshirtContest.
     * @example
     * // Delete one Tbl_TshirtContest
     * const Tbl_TshirtContest = await prisma.tbl_TshirtContest.delete({
     *   where: {
     *     // ... filter to delete one Tbl_TshirtContest
     *   }
     * })
     * 
    **/
    delete<T extends tbl_TshirtContestDeleteArgs>(
      args: SelectSubset<T, tbl_TshirtContestDeleteArgs>
    ): Prisma__tbl_TshirtContestClient<tbl_TshirtContestGetPayload<T>>

    /**
     * Update one Tbl_TshirtContest.
     * @param {tbl_TshirtContestUpdateArgs} args - Arguments to update one Tbl_TshirtContest.
     * @example
     * // Update one Tbl_TshirtContest
     * const tbl_TshirtContest = await prisma.tbl_TshirtContest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tbl_TshirtContestUpdateArgs>(
      args: SelectSubset<T, tbl_TshirtContestUpdateArgs>
    ): Prisma__tbl_TshirtContestClient<tbl_TshirtContestGetPayload<T>>

    /**
     * Delete zero or more Tbl_TshirtContests.
     * @param {tbl_TshirtContestDeleteManyArgs} args - Arguments to filter Tbl_TshirtContests to delete.
     * @example
     * // Delete a few Tbl_TshirtContests
     * const { count } = await prisma.tbl_TshirtContest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tbl_TshirtContestDeleteManyArgs>(
      args?: SelectSubset<T, tbl_TshirtContestDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tbl_TshirtContests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_TshirtContestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tbl_TshirtContests
     * const tbl_TshirtContest = await prisma.tbl_TshirtContest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tbl_TshirtContestUpdateManyArgs>(
      args: SelectSubset<T, tbl_TshirtContestUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tbl_TshirtContest.
     * @param {tbl_TshirtContestUpsertArgs} args - Arguments to update or create a Tbl_TshirtContest.
     * @example
     * // Update or create a Tbl_TshirtContest
     * const tbl_TshirtContest = await prisma.tbl_TshirtContest.upsert({
     *   create: {
     *     // ... data to create a Tbl_TshirtContest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tbl_TshirtContest we want to update
     *   }
     * })
    **/
    upsert<T extends tbl_TshirtContestUpsertArgs>(
      args: SelectSubset<T, tbl_TshirtContestUpsertArgs>
    ): Prisma__tbl_TshirtContestClient<tbl_TshirtContestGetPayload<T>>

    /**
     * Count the number of Tbl_TshirtContests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_TshirtContestCountArgs} args - Arguments to filter Tbl_TshirtContests to count.
     * @example
     * // Count the number of Tbl_TshirtContests
     * const count = await prisma.tbl_TshirtContest.count({
     *   where: {
     *     // ... the filter for the Tbl_TshirtContests we want to count
     *   }
     * })
    **/
    count<T extends tbl_TshirtContestCountArgs>(
      args?: Subset<T, tbl_TshirtContestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tbl_TshirtContestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tbl_TshirtContest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_TshirtContestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tbl_TshirtContestAggregateArgs>(args: Subset<T, Tbl_TshirtContestAggregateArgs>): Prisma.PrismaPromise<GetTbl_TshirtContestAggregateType<T>>

    /**
     * Group by Tbl_TshirtContest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_TshirtContestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tbl_TshirtContestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tbl_TshirtContestGroupByArgs['orderBy'] }
        : { orderBy?: Tbl_TshirtContestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tbl_TshirtContestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTbl_TshirtContestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tbl_TshirtContest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tbl_TshirtContestClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tbl_TshirtContest base type for findUnique actions
   */
  export type tbl_TshirtContestFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tbl_TshirtContest
     */
    select?: tbl_TshirtContestSelect | null
    /**
     * Filter, which tbl_TshirtContest to fetch.
     */
    where: tbl_TshirtContestWhereUniqueInput
  }

  /**
   * tbl_TshirtContest findUnique
   */
  export interface tbl_TshirtContestFindUniqueArgs extends tbl_TshirtContestFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tbl_TshirtContest findUniqueOrThrow
   */
  export type tbl_TshirtContestFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tbl_TshirtContest
     */
    select?: tbl_TshirtContestSelect | null
    /**
     * Filter, which tbl_TshirtContest to fetch.
     */
    where: tbl_TshirtContestWhereUniqueInput
  }


  /**
   * tbl_TshirtContest base type for findFirst actions
   */
  export type tbl_TshirtContestFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tbl_TshirtContest
     */
    select?: tbl_TshirtContestSelect | null
    /**
     * Filter, which tbl_TshirtContest to fetch.
     */
    where?: tbl_TshirtContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_TshirtContests to fetch.
     */
    orderBy?: Enumerable<tbl_TshirtContestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbl_TshirtContests.
     */
    cursor?: tbl_TshirtContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_TshirtContests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_TshirtContests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbl_TshirtContests.
     */
    distinct?: Enumerable<Tbl_TshirtContestScalarFieldEnum>
  }

  /**
   * tbl_TshirtContest findFirst
   */
  export interface tbl_TshirtContestFindFirstArgs extends tbl_TshirtContestFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tbl_TshirtContest findFirstOrThrow
   */
  export type tbl_TshirtContestFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tbl_TshirtContest
     */
    select?: tbl_TshirtContestSelect | null
    /**
     * Filter, which tbl_TshirtContest to fetch.
     */
    where?: tbl_TshirtContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_TshirtContests to fetch.
     */
    orderBy?: Enumerable<tbl_TshirtContestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbl_TshirtContests.
     */
    cursor?: tbl_TshirtContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_TshirtContests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_TshirtContests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbl_TshirtContests.
     */
    distinct?: Enumerable<Tbl_TshirtContestScalarFieldEnum>
  }


  /**
   * tbl_TshirtContest findMany
   */
  export type tbl_TshirtContestFindManyArgs = {
    /**
     * Select specific fields to fetch from the tbl_TshirtContest
     */
    select?: tbl_TshirtContestSelect | null
    /**
     * Filter, which tbl_TshirtContests to fetch.
     */
    where?: tbl_TshirtContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_TshirtContests to fetch.
     */
    orderBy?: Enumerable<tbl_TshirtContestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tbl_TshirtContests.
     */
    cursor?: tbl_TshirtContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_TshirtContests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_TshirtContests.
     */
    skip?: number
    distinct?: Enumerable<Tbl_TshirtContestScalarFieldEnum>
  }


  /**
   * tbl_TshirtContest create
   */
  export type tbl_TshirtContestCreateArgs = {
    /**
     * Select specific fields to fetch from the tbl_TshirtContest
     */
    select?: tbl_TshirtContestSelect | null
    /**
     * The data needed to create a tbl_TshirtContest.
     */
    data: XOR<tbl_TshirtContestCreateInput, tbl_TshirtContestUncheckedCreateInput>
  }


  /**
   * tbl_TshirtContest createMany
   */
  export type tbl_TshirtContestCreateManyArgs = {
    /**
     * The data used to create many tbl_TshirtContests.
     */
    data: Enumerable<tbl_TshirtContestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tbl_TshirtContest update
   */
  export type tbl_TshirtContestUpdateArgs = {
    /**
     * Select specific fields to fetch from the tbl_TshirtContest
     */
    select?: tbl_TshirtContestSelect | null
    /**
     * The data needed to update a tbl_TshirtContest.
     */
    data: XOR<tbl_TshirtContestUpdateInput, tbl_TshirtContestUncheckedUpdateInput>
    /**
     * Choose, which tbl_TshirtContest to update.
     */
    where: tbl_TshirtContestWhereUniqueInput
  }


  /**
   * tbl_TshirtContest updateMany
   */
  export type tbl_TshirtContestUpdateManyArgs = {
    /**
     * The data used to update tbl_TshirtContests.
     */
    data: XOR<tbl_TshirtContestUpdateManyMutationInput, tbl_TshirtContestUncheckedUpdateManyInput>
    /**
     * Filter which tbl_TshirtContests to update
     */
    where?: tbl_TshirtContestWhereInput
  }


  /**
   * tbl_TshirtContest upsert
   */
  export type tbl_TshirtContestUpsertArgs = {
    /**
     * Select specific fields to fetch from the tbl_TshirtContest
     */
    select?: tbl_TshirtContestSelect | null
    /**
     * The filter to search for the tbl_TshirtContest to update in case it exists.
     */
    where: tbl_TshirtContestWhereUniqueInput
    /**
     * In case the tbl_TshirtContest found by the `where` argument doesn't exist, create a new tbl_TshirtContest with this data.
     */
    create: XOR<tbl_TshirtContestCreateInput, tbl_TshirtContestUncheckedCreateInput>
    /**
     * In case the tbl_TshirtContest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tbl_TshirtContestUpdateInput, tbl_TshirtContestUncheckedUpdateInput>
  }


  /**
   * tbl_TshirtContest delete
   */
  export type tbl_TshirtContestDeleteArgs = {
    /**
     * Select specific fields to fetch from the tbl_TshirtContest
     */
    select?: tbl_TshirtContestSelect | null
    /**
     * Filter which tbl_TshirtContest to delete.
     */
    where: tbl_TshirtContestWhereUniqueInput
  }


  /**
   * tbl_TshirtContest deleteMany
   */
  export type tbl_TshirtContestDeleteManyArgs = {
    /**
     * Filter which tbl_TshirtContests to delete
     */
    where?: tbl_TshirtContestWhereInput
  }


  /**
   * tbl_TshirtContest without action
   */
  export type tbl_TshirtContestArgs = {
    /**
     * Select specific fields to fetch from the tbl_TshirtContest
     */
    select?: tbl_TshirtContestSelect | null
  }



  /**
   * Model tbl_barrage_at_us_2023
   */


  export type AggregateTbl_barrage_at_us_2023 = {
    _count: Tbl_barrage_at_us_2023CountAggregateOutputType | null
    _avg: Tbl_barrage_at_us_2023AvgAggregateOutputType | null
    _sum: Tbl_barrage_at_us_2023SumAggregateOutputType | null
    _min: Tbl_barrage_at_us_2023MinAggregateOutputType | null
    _max: Tbl_barrage_at_us_2023MaxAggregateOutputType | null
  }

  export type Tbl_barrage_at_us_2023AvgAggregateOutputType = {
    id: number | null
  }

  export type Tbl_barrage_at_us_2023SumAggregateOutputType = {
    id: number | null
  }

  export type Tbl_barrage_at_us_2023MinAggregateOutputType = {
    id: number | null
    barrageContent: string | null
  }

  export type Tbl_barrage_at_us_2023MaxAggregateOutputType = {
    id: number | null
    barrageContent: string | null
  }

  export type Tbl_barrage_at_us_2023CountAggregateOutputType = {
    id: number
    barrageContent: number
    _all: number
  }


  export type Tbl_barrage_at_us_2023AvgAggregateInputType = {
    id?: true
  }

  export type Tbl_barrage_at_us_2023SumAggregateInputType = {
    id?: true
  }

  export type Tbl_barrage_at_us_2023MinAggregateInputType = {
    id?: true
    barrageContent?: true
  }

  export type Tbl_barrage_at_us_2023MaxAggregateInputType = {
    id?: true
    barrageContent?: true
  }

  export type Tbl_barrage_at_us_2023CountAggregateInputType = {
    id?: true
    barrageContent?: true
    _all?: true
  }

  export type Tbl_barrage_at_us_2023AggregateArgs = {
    /**
     * Filter which tbl_barrage_at_us_2023 to aggregate.
     */
    where?: tbl_barrage_at_us_2023WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_barrage_at_us_2023s to fetch.
     */
    orderBy?: Enumerable<tbl_barrage_at_us_2023OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tbl_barrage_at_us_2023WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_barrage_at_us_2023s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_barrage_at_us_2023s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tbl_barrage_at_us_2023s
    **/
    _count?: true | Tbl_barrage_at_us_2023CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tbl_barrage_at_us_2023AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tbl_barrage_at_us_2023SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tbl_barrage_at_us_2023MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tbl_barrage_at_us_2023MaxAggregateInputType
  }

  export type GetTbl_barrage_at_us_2023AggregateType<T extends Tbl_barrage_at_us_2023AggregateArgs> = {
        [P in keyof T & keyof AggregateTbl_barrage_at_us_2023]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTbl_barrage_at_us_2023[P]>
      : GetScalarType<T[P], AggregateTbl_barrage_at_us_2023[P]>
  }




  export type Tbl_barrage_at_us_2023GroupByArgs = {
    where?: tbl_barrage_at_us_2023WhereInput
    orderBy?: Enumerable<tbl_barrage_at_us_2023OrderByWithAggregationInput>
    by: Tbl_barrage_at_us_2023ScalarFieldEnum[]
    having?: tbl_barrage_at_us_2023ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tbl_barrage_at_us_2023CountAggregateInputType | true
    _avg?: Tbl_barrage_at_us_2023AvgAggregateInputType
    _sum?: Tbl_barrage_at_us_2023SumAggregateInputType
    _min?: Tbl_barrage_at_us_2023MinAggregateInputType
    _max?: Tbl_barrage_at_us_2023MaxAggregateInputType
  }


  export type Tbl_barrage_at_us_2023GroupByOutputType = {
    id: number
    barrageContent: string
    _count: Tbl_barrage_at_us_2023CountAggregateOutputType | null
    _avg: Tbl_barrage_at_us_2023AvgAggregateOutputType | null
    _sum: Tbl_barrage_at_us_2023SumAggregateOutputType | null
    _min: Tbl_barrage_at_us_2023MinAggregateOutputType | null
    _max: Tbl_barrage_at_us_2023MaxAggregateOutputType | null
  }

  type GetTbl_barrage_at_us_2023GroupByPayload<T extends Tbl_barrage_at_us_2023GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Tbl_barrage_at_us_2023GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tbl_barrage_at_us_2023GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tbl_barrage_at_us_2023GroupByOutputType[P]>
            : GetScalarType<T[P], Tbl_barrage_at_us_2023GroupByOutputType[P]>
        }
      >
    >


  export type tbl_barrage_at_us_2023Select = {
    id?: boolean
    barrageContent?: boolean
  }


  export type tbl_barrage_at_us_2023GetPayload<S extends boolean | null | undefined | tbl_barrage_at_us_2023Args> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tbl_barrage_at_us_2023 :
    S extends undefined ? never :
    S extends { include: any } & (tbl_barrage_at_us_2023Args | tbl_barrage_at_us_2023FindManyArgs)
    ? tbl_barrage_at_us_2023 
    : S extends { select: any } & (tbl_barrage_at_us_2023Args | tbl_barrage_at_us_2023FindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof tbl_barrage_at_us_2023 ? tbl_barrage_at_us_2023[P] : never
  } 
      : tbl_barrage_at_us_2023


  type tbl_barrage_at_us_2023CountArgs = 
    Omit<tbl_barrage_at_us_2023FindManyArgs, 'select' | 'include'> & {
      select?: Tbl_barrage_at_us_2023CountAggregateInputType | true
    }

  export interface tbl_barrage_at_us_2023Delegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tbl_barrage_at_us_2023 that matches the filter.
     * @param {tbl_barrage_at_us_2023FindUniqueArgs} args - Arguments to find a Tbl_barrage_at_us_2023
     * @example
     * // Get one Tbl_barrage_at_us_2023
     * const tbl_barrage_at_us_2023 = await prisma.tbl_barrage_at_us_2023.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tbl_barrage_at_us_2023FindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tbl_barrage_at_us_2023FindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tbl_barrage_at_us_2023'> extends True ? Prisma__tbl_barrage_at_us_2023Client<tbl_barrage_at_us_2023GetPayload<T>> : Prisma__tbl_barrage_at_us_2023Client<tbl_barrage_at_us_2023GetPayload<T> | null, null>

    /**
     * Find one Tbl_barrage_at_us_2023 that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tbl_barrage_at_us_2023FindUniqueOrThrowArgs} args - Arguments to find a Tbl_barrage_at_us_2023
     * @example
     * // Get one Tbl_barrage_at_us_2023
     * const tbl_barrage_at_us_2023 = await prisma.tbl_barrage_at_us_2023.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tbl_barrage_at_us_2023FindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tbl_barrage_at_us_2023FindUniqueOrThrowArgs>
    ): Prisma__tbl_barrage_at_us_2023Client<tbl_barrage_at_us_2023GetPayload<T>>

    /**
     * Find the first Tbl_barrage_at_us_2023 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_barrage_at_us_2023FindFirstArgs} args - Arguments to find a Tbl_barrage_at_us_2023
     * @example
     * // Get one Tbl_barrage_at_us_2023
     * const tbl_barrage_at_us_2023 = await prisma.tbl_barrage_at_us_2023.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tbl_barrage_at_us_2023FindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tbl_barrage_at_us_2023FindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tbl_barrage_at_us_2023'> extends True ? Prisma__tbl_barrage_at_us_2023Client<tbl_barrage_at_us_2023GetPayload<T>> : Prisma__tbl_barrage_at_us_2023Client<tbl_barrage_at_us_2023GetPayload<T> | null, null>

    /**
     * Find the first Tbl_barrage_at_us_2023 that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_barrage_at_us_2023FindFirstOrThrowArgs} args - Arguments to find a Tbl_barrage_at_us_2023
     * @example
     * // Get one Tbl_barrage_at_us_2023
     * const tbl_barrage_at_us_2023 = await prisma.tbl_barrage_at_us_2023.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tbl_barrage_at_us_2023FindFirstOrThrowArgs>(
      args?: SelectSubset<T, tbl_barrage_at_us_2023FindFirstOrThrowArgs>
    ): Prisma__tbl_barrage_at_us_2023Client<tbl_barrage_at_us_2023GetPayload<T>>

    /**
     * Find zero or more Tbl_barrage_at_us_2023s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_barrage_at_us_2023FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tbl_barrage_at_us_2023s
     * const tbl_barrage_at_us_2023s = await prisma.tbl_barrage_at_us_2023.findMany()
     * 
     * // Get first 10 Tbl_barrage_at_us_2023s
     * const tbl_barrage_at_us_2023s = await prisma.tbl_barrage_at_us_2023.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tbl_barrage_at_us_2023WithIdOnly = await prisma.tbl_barrage_at_us_2023.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tbl_barrage_at_us_2023FindManyArgs>(
      args?: SelectSubset<T, tbl_barrage_at_us_2023FindManyArgs>
    ): Prisma.PrismaPromise<Array<tbl_barrage_at_us_2023GetPayload<T>>>

    /**
     * Create a Tbl_barrage_at_us_2023.
     * @param {tbl_barrage_at_us_2023CreateArgs} args - Arguments to create a Tbl_barrage_at_us_2023.
     * @example
     * // Create one Tbl_barrage_at_us_2023
     * const Tbl_barrage_at_us_2023 = await prisma.tbl_barrage_at_us_2023.create({
     *   data: {
     *     // ... data to create a Tbl_barrage_at_us_2023
     *   }
     * })
     * 
    **/
    create<T extends tbl_barrage_at_us_2023CreateArgs>(
      args: SelectSubset<T, tbl_barrage_at_us_2023CreateArgs>
    ): Prisma__tbl_barrage_at_us_2023Client<tbl_barrage_at_us_2023GetPayload<T>>

    /**
     * Create many Tbl_barrage_at_us_2023s.
     *     @param {tbl_barrage_at_us_2023CreateManyArgs} args - Arguments to create many Tbl_barrage_at_us_2023s.
     *     @example
     *     // Create many Tbl_barrage_at_us_2023s
     *     const tbl_barrage_at_us_2023 = await prisma.tbl_barrage_at_us_2023.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tbl_barrage_at_us_2023CreateManyArgs>(
      args?: SelectSubset<T, tbl_barrage_at_us_2023CreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tbl_barrage_at_us_2023.
     * @param {tbl_barrage_at_us_2023DeleteArgs} args - Arguments to delete one Tbl_barrage_at_us_2023.
     * @example
     * // Delete one Tbl_barrage_at_us_2023
     * const Tbl_barrage_at_us_2023 = await prisma.tbl_barrage_at_us_2023.delete({
     *   where: {
     *     // ... filter to delete one Tbl_barrage_at_us_2023
     *   }
     * })
     * 
    **/
    delete<T extends tbl_barrage_at_us_2023DeleteArgs>(
      args: SelectSubset<T, tbl_barrage_at_us_2023DeleteArgs>
    ): Prisma__tbl_barrage_at_us_2023Client<tbl_barrage_at_us_2023GetPayload<T>>

    /**
     * Update one Tbl_barrage_at_us_2023.
     * @param {tbl_barrage_at_us_2023UpdateArgs} args - Arguments to update one Tbl_barrage_at_us_2023.
     * @example
     * // Update one Tbl_barrage_at_us_2023
     * const tbl_barrage_at_us_2023 = await prisma.tbl_barrage_at_us_2023.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tbl_barrage_at_us_2023UpdateArgs>(
      args: SelectSubset<T, tbl_barrage_at_us_2023UpdateArgs>
    ): Prisma__tbl_barrage_at_us_2023Client<tbl_barrage_at_us_2023GetPayload<T>>

    /**
     * Delete zero or more Tbl_barrage_at_us_2023s.
     * @param {tbl_barrage_at_us_2023DeleteManyArgs} args - Arguments to filter Tbl_barrage_at_us_2023s to delete.
     * @example
     * // Delete a few Tbl_barrage_at_us_2023s
     * const { count } = await prisma.tbl_barrage_at_us_2023.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tbl_barrage_at_us_2023DeleteManyArgs>(
      args?: SelectSubset<T, tbl_barrage_at_us_2023DeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tbl_barrage_at_us_2023s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_barrage_at_us_2023UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tbl_barrage_at_us_2023s
     * const tbl_barrage_at_us_2023 = await prisma.tbl_barrage_at_us_2023.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tbl_barrage_at_us_2023UpdateManyArgs>(
      args: SelectSubset<T, tbl_barrage_at_us_2023UpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tbl_barrage_at_us_2023.
     * @param {tbl_barrage_at_us_2023UpsertArgs} args - Arguments to update or create a Tbl_barrage_at_us_2023.
     * @example
     * // Update or create a Tbl_barrage_at_us_2023
     * const tbl_barrage_at_us_2023 = await prisma.tbl_barrage_at_us_2023.upsert({
     *   create: {
     *     // ... data to create a Tbl_barrage_at_us_2023
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tbl_barrage_at_us_2023 we want to update
     *   }
     * })
    **/
    upsert<T extends tbl_barrage_at_us_2023UpsertArgs>(
      args: SelectSubset<T, tbl_barrage_at_us_2023UpsertArgs>
    ): Prisma__tbl_barrage_at_us_2023Client<tbl_barrage_at_us_2023GetPayload<T>>

    /**
     * Count the number of Tbl_barrage_at_us_2023s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_barrage_at_us_2023CountArgs} args - Arguments to filter Tbl_barrage_at_us_2023s to count.
     * @example
     * // Count the number of Tbl_barrage_at_us_2023s
     * const count = await prisma.tbl_barrage_at_us_2023.count({
     *   where: {
     *     // ... the filter for the Tbl_barrage_at_us_2023s we want to count
     *   }
     * })
    **/
    count<T extends tbl_barrage_at_us_2023CountArgs>(
      args?: Subset<T, tbl_barrage_at_us_2023CountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tbl_barrage_at_us_2023CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tbl_barrage_at_us_2023.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_barrage_at_us_2023AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tbl_barrage_at_us_2023AggregateArgs>(args: Subset<T, Tbl_barrage_at_us_2023AggregateArgs>): Prisma.PrismaPromise<GetTbl_barrage_at_us_2023AggregateType<T>>

    /**
     * Group by Tbl_barrage_at_us_2023.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_barrage_at_us_2023GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tbl_barrage_at_us_2023GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tbl_barrage_at_us_2023GroupByArgs['orderBy'] }
        : { orderBy?: Tbl_barrage_at_us_2023GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tbl_barrage_at_us_2023GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTbl_barrage_at_us_2023GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tbl_barrage_at_us_2023.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tbl_barrage_at_us_2023Client<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tbl_barrage_at_us_2023 base type for findUnique actions
   */
  export type tbl_barrage_at_us_2023FindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tbl_barrage_at_us_2023
     */
    select?: tbl_barrage_at_us_2023Select | null
    /**
     * Filter, which tbl_barrage_at_us_2023 to fetch.
     */
    where: tbl_barrage_at_us_2023WhereUniqueInput
  }

  /**
   * tbl_barrage_at_us_2023 findUnique
   */
  export interface tbl_barrage_at_us_2023FindUniqueArgs extends tbl_barrage_at_us_2023FindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tbl_barrage_at_us_2023 findUniqueOrThrow
   */
  export type tbl_barrage_at_us_2023FindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tbl_barrage_at_us_2023
     */
    select?: tbl_barrage_at_us_2023Select | null
    /**
     * Filter, which tbl_barrage_at_us_2023 to fetch.
     */
    where: tbl_barrage_at_us_2023WhereUniqueInput
  }


  /**
   * tbl_barrage_at_us_2023 base type for findFirst actions
   */
  export type tbl_barrage_at_us_2023FindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tbl_barrage_at_us_2023
     */
    select?: tbl_barrage_at_us_2023Select | null
    /**
     * Filter, which tbl_barrage_at_us_2023 to fetch.
     */
    where?: tbl_barrage_at_us_2023WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_barrage_at_us_2023s to fetch.
     */
    orderBy?: Enumerable<tbl_barrage_at_us_2023OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbl_barrage_at_us_2023s.
     */
    cursor?: tbl_barrage_at_us_2023WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_barrage_at_us_2023s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_barrage_at_us_2023s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbl_barrage_at_us_2023s.
     */
    distinct?: Enumerable<Tbl_barrage_at_us_2023ScalarFieldEnum>
  }

  /**
   * tbl_barrage_at_us_2023 findFirst
   */
  export interface tbl_barrage_at_us_2023FindFirstArgs extends tbl_barrage_at_us_2023FindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tbl_barrage_at_us_2023 findFirstOrThrow
   */
  export type tbl_barrage_at_us_2023FindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tbl_barrage_at_us_2023
     */
    select?: tbl_barrage_at_us_2023Select | null
    /**
     * Filter, which tbl_barrage_at_us_2023 to fetch.
     */
    where?: tbl_barrage_at_us_2023WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_barrage_at_us_2023s to fetch.
     */
    orderBy?: Enumerable<tbl_barrage_at_us_2023OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbl_barrage_at_us_2023s.
     */
    cursor?: tbl_barrage_at_us_2023WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_barrage_at_us_2023s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_barrage_at_us_2023s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbl_barrage_at_us_2023s.
     */
    distinct?: Enumerable<Tbl_barrage_at_us_2023ScalarFieldEnum>
  }


  /**
   * tbl_barrage_at_us_2023 findMany
   */
  export type tbl_barrage_at_us_2023FindManyArgs = {
    /**
     * Select specific fields to fetch from the tbl_barrage_at_us_2023
     */
    select?: tbl_barrage_at_us_2023Select | null
    /**
     * Filter, which tbl_barrage_at_us_2023s to fetch.
     */
    where?: tbl_barrage_at_us_2023WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_barrage_at_us_2023s to fetch.
     */
    orderBy?: Enumerable<tbl_barrage_at_us_2023OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tbl_barrage_at_us_2023s.
     */
    cursor?: tbl_barrage_at_us_2023WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_barrage_at_us_2023s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_barrage_at_us_2023s.
     */
    skip?: number
    distinct?: Enumerable<Tbl_barrage_at_us_2023ScalarFieldEnum>
  }


  /**
   * tbl_barrage_at_us_2023 create
   */
  export type tbl_barrage_at_us_2023CreateArgs = {
    /**
     * Select specific fields to fetch from the tbl_barrage_at_us_2023
     */
    select?: tbl_barrage_at_us_2023Select | null
    /**
     * The data needed to create a tbl_barrage_at_us_2023.
     */
    data: XOR<tbl_barrage_at_us_2023CreateInput, tbl_barrage_at_us_2023UncheckedCreateInput>
  }


  /**
   * tbl_barrage_at_us_2023 createMany
   */
  export type tbl_barrage_at_us_2023CreateManyArgs = {
    /**
     * The data used to create many tbl_barrage_at_us_2023s.
     */
    data: Enumerable<tbl_barrage_at_us_2023CreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tbl_barrage_at_us_2023 update
   */
  export type tbl_barrage_at_us_2023UpdateArgs = {
    /**
     * Select specific fields to fetch from the tbl_barrage_at_us_2023
     */
    select?: tbl_barrage_at_us_2023Select | null
    /**
     * The data needed to update a tbl_barrage_at_us_2023.
     */
    data: XOR<tbl_barrage_at_us_2023UpdateInput, tbl_barrage_at_us_2023UncheckedUpdateInput>
    /**
     * Choose, which tbl_barrage_at_us_2023 to update.
     */
    where: tbl_barrage_at_us_2023WhereUniqueInput
  }


  /**
   * tbl_barrage_at_us_2023 updateMany
   */
  export type tbl_barrage_at_us_2023UpdateManyArgs = {
    /**
     * The data used to update tbl_barrage_at_us_2023s.
     */
    data: XOR<tbl_barrage_at_us_2023UpdateManyMutationInput, tbl_barrage_at_us_2023UncheckedUpdateManyInput>
    /**
     * Filter which tbl_barrage_at_us_2023s to update
     */
    where?: tbl_barrage_at_us_2023WhereInput
  }


  /**
   * tbl_barrage_at_us_2023 upsert
   */
  export type tbl_barrage_at_us_2023UpsertArgs = {
    /**
     * Select specific fields to fetch from the tbl_barrage_at_us_2023
     */
    select?: tbl_barrage_at_us_2023Select | null
    /**
     * The filter to search for the tbl_barrage_at_us_2023 to update in case it exists.
     */
    where: tbl_barrage_at_us_2023WhereUniqueInput
    /**
     * In case the tbl_barrage_at_us_2023 found by the `where` argument doesn't exist, create a new tbl_barrage_at_us_2023 with this data.
     */
    create: XOR<tbl_barrage_at_us_2023CreateInput, tbl_barrage_at_us_2023UncheckedCreateInput>
    /**
     * In case the tbl_barrage_at_us_2023 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tbl_barrage_at_us_2023UpdateInput, tbl_barrage_at_us_2023UncheckedUpdateInput>
  }


  /**
   * tbl_barrage_at_us_2023 delete
   */
  export type tbl_barrage_at_us_2023DeleteArgs = {
    /**
     * Select specific fields to fetch from the tbl_barrage_at_us_2023
     */
    select?: tbl_barrage_at_us_2023Select | null
    /**
     * Filter which tbl_barrage_at_us_2023 to delete.
     */
    where: tbl_barrage_at_us_2023WhereUniqueInput
  }


  /**
   * tbl_barrage_at_us_2023 deleteMany
   */
  export type tbl_barrage_at_us_2023DeleteManyArgs = {
    /**
     * Filter which tbl_barrage_at_us_2023s to delete
     */
    where?: tbl_barrage_at_us_2023WhereInput
  }


  /**
   * tbl_barrage_at_us_2023 without action
   */
  export type tbl_barrage_at_us_2023Args = {
    /**
     * Select specific fields to fetch from the tbl_barrage_at_us_2023
     */
    select?: tbl_barrage_at_us_2023Select | null
  }



  /**
   * Model tbl_next_auth
   */


  export type AggregateTbl_next_auth = {
    _count: Tbl_next_authCountAggregateOutputType | null
    _avg: Tbl_next_authAvgAggregateOutputType | null
    _sum: Tbl_next_authSumAggregateOutputType | null
    _min: Tbl_next_authMinAggregateOutputType | null
    _max: Tbl_next_authMaxAggregateOutputType | null
  }

  export type Tbl_next_authAvgAggregateOutputType = {
    id: number | null
  }

  export type Tbl_next_authSumAggregateOutputType = {
    id: number | null
  }

  export type Tbl_next_authMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    email: string | null
    isVerified: boolean | null
    isAdmin: boolean | null
  }

  export type Tbl_next_authMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    email: string | null
    isVerified: boolean | null
    isAdmin: boolean | null
  }

  export type Tbl_next_authCountAggregateOutputType = {
    id: number
    username: number
    password: number
    email: number
    isVerified: number
    isAdmin: number
    _all: number
  }


  export type Tbl_next_authAvgAggregateInputType = {
    id?: true
  }

  export type Tbl_next_authSumAggregateInputType = {
    id?: true
  }

  export type Tbl_next_authMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    isVerified?: true
    isAdmin?: true
  }

  export type Tbl_next_authMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    isVerified?: true
    isAdmin?: true
  }

  export type Tbl_next_authCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    isVerified?: true
    isAdmin?: true
    _all?: true
  }

  export type Tbl_next_authAggregateArgs = {
    /**
     * Filter which tbl_next_auth to aggregate.
     */
    where?: tbl_next_authWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_next_auths to fetch.
     */
    orderBy?: Enumerable<tbl_next_authOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tbl_next_authWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_next_auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_next_auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tbl_next_auths
    **/
    _count?: true | Tbl_next_authCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tbl_next_authAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tbl_next_authSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tbl_next_authMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tbl_next_authMaxAggregateInputType
  }

  export type GetTbl_next_authAggregateType<T extends Tbl_next_authAggregateArgs> = {
        [P in keyof T & keyof AggregateTbl_next_auth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTbl_next_auth[P]>
      : GetScalarType<T[P], AggregateTbl_next_auth[P]>
  }




  export type Tbl_next_authGroupByArgs = {
    where?: tbl_next_authWhereInput
    orderBy?: Enumerable<tbl_next_authOrderByWithAggregationInput>
    by: Tbl_next_authScalarFieldEnum[]
    having?: tbl_next_authScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tbl_next_authCountAggregateInputType | true
    _avg?: Tbl_next_authAvgAggregateInputType
    _sum?: Tbl_next_authSumAggregateInputType
    _min?: Tbl_next_authMinAggregateInputType
    _max?: Tbl_next_authMaxAggregateInputType
  }


  export type Tbl_next_authGroupByOutputType = {
    id: number
    username: string
    password: string
    email: string
    isVerified: boolean
    isAdmin: boolean
    _count: Tbl_next_authCountAggregateOutputType | null
    _avg: Tbl_next_authAvgAggregateOutputType | null
    _sum: Tbl_next_authSumAggregateOutputType | null
    _min: Tbl_next_authMinAggregateOutputType | null
    _max: Tbl_next_authMaxAggregateOutputType | null
  }

  type GetTbl_next_authGroupByPayload<T extends Tbl_next_authGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Tbl_next_authGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tbl_next_authGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tbl_next_authGroupByOutputType[P]>
            : GetScalarType<T[P], Tbl_next_authGroupByOutputType[P]>
        }
      >
    >


  export type tbl_next_authSelect = {
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    isVerified?: boolean
    isAdmin?: boolean
  }


  export type tbl_next_authGetPayload<S extends boolean | null | undefined | tbl_next_authArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tbl_next_auth :
    S extends undefined ? never :
    S extends { include: any } & (tbl_next_authArgs | tbl_next_authFindManyArgs)
    ? tbl_next_auth 
    : S extends { select: any } & (tbl_next_authArgs | tbl_next_authFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof tbl_next_auth ? tbl_next_auth[P] : never
  } 
      : tbl_next_auth


  type tbl_next_authCountArgs = 
    Omit<tbl_next_authFindManyArgs, 'select' | 'include'> & {
      select?: Tbl_next_authCountAggregateInputType | true
    }

  export interface tbl_next_authDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tbl_next_auth that matches the filter.
     * @param {tbl_next_authFindUniqueArgs} args - Arguments to find a Tbl_next_auth
     * @example
     * // Get one Tbl_next_auth
     * const tbl_next_auth = await prisma.tbl_next_auth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tbl_next_authFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tbl_next_authFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tbl_next_auth'> extends True ? Prisma__tbl_next_authClient<tbl_next_authGetPayload<T>> : Prisma__tbl_next_authClient<tbl_next_authGetPayload<T> | null, null>

    /**
     * Find one Tbl_next_auth that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tbl_next_authFindUniqueOrThrowArgs} args - Arguments to find a Tbl_next_auth
     * @example
     * // Get one Tbl_next_auth
     * const tbl_next_auth = await prisma.tbl_next_auth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tbl_next_authFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tbl_next_authFindUniqueOrThrowArgs>
    ): Prisma__tbl_next_authClient<tbl_next_authGetPayload<T>>

    /**
     * Find the first Tbl_next_auth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_next_authFindFirstArgs} args - Arguments to find a Tbl_next_auth
     * @example
     * // Get one Tbl_next_auth
     * const tbl_next_auth = await prisma.tbl_next_auth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tbl_next_authFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tbl_next_authFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tbl_next_auth'> extends True ? Prisma__tbl_next_authClient<tbl_next_authGetPayload<T>> : Prisma__tbl_next_authClient<tbl_next_authGetPayload<T> | null, null>

    /**
     * Find the first Tbl_next_auth that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_next_authFindFirstOrThrowArgs} args - Arguments to find a Tbl_next_auth
     * @example
     * // Get one Tbl_next_auth
     * const tbl_next_auth = await prisma.tbl_next_auth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tbl_next_authFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tbl_next_authFindFirstOrThrowArgs>
    ): Prisma__tbl_next_authClient<tbl_next_authGetPayload<T>>

    /**
     * Find zero or more Tbl_next_auths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_next_authFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tbl_next_auths
     * const tbl_next_auths = await prisma.tbl_next_auth.findMany()
     * 
     * // Get first 10 Tbl_next_auths
     * const tbl_next_auths = await prisma.tbl_next_auth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tbl_next_authWithIdOnly = await prisma.tbl_next_auth.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tbl_next_authFindManyArgs>(
      args?: SelectSubset<T, tbl_next_authFindManyArgs>
    ): Prisma.PrismaPromise<Array<tbl_next_authGetPayload<T>>>

    /**
     * Create a Tbl_next_auth.
     * @param {tbl_next_authCreateArgs} args - Arguments to create a Tbl_next_auth.
     * @example
     * // Create one Tbl_next_auth
     * const Tbl_next_auth = await prisma.tbl_next_auth.create({
     *   data: {
     *     // ... data to create a Tbl_next_auth
     *   }
     * })
     * 
    **/
    create<T extends tbl_next_authCreateArgs>(
      args: SelectSubset<T, tbl_next_authCreateArgs>
    ): Prisma__tbl_next_authClient<tbl_next_authGetPayload<T>>

    /**
     * Create many Tbl_next_auths.
     *     @param {tbl_next_authCreateManyArgs} args - Arguments to create many Tbl_next_auths.
     *     @example
     *     // Create many Tbl_next_auths
     *     const tbl_next_auth = await prisma.tbl_next_auth.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tbl_next_authCreateManyArgs>(
      args?: SelectSubset<T, tbl_next_authCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tbl_next_auth.
     * @param {tbl_next_authDeleteArgs} args - Arguments to delete one Tbl_next_auth.
     * @example
     * // Delete one Tbl_next_auth
     * const Tbl_next_auth = await prisma.tbl_next_auth.delete({
     *   where: {
     *     // ... filter to delete one Tbl_next_auth
     *   }
     * })
     * 
    **/
    delete<T extends tbl_next_authDeleteArgs>(
      args: SelectSubset<T, tbl_next_authDeleteArgs>
    ): Prisma__tbl_next_authClient<tbl_next_authGetPayload<T>>

    /**
     * Update one Tbl_next_auth.
     * @param {tbl_next_authUpdateArgs} args - Arguments to update one Tbl_next_auth.
     * @example
     * // Update one Tbl_next_auth
     * const tbl_next_auth = await prisma.tbl_next_auth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tbl_next_authUpdateArgs>(
      args: SelectSubset<T, tbl_next_authUpdateArgs>
    ): Prisma__tbl_next_authClient<tbl_next_authGetPayload<T>>

    /**
     * Delete zero or more Tbl_next_auths.
     * @param {tbl_next_authDeleteManyArgs} args - Arguments to filter Tbl_next_auths to delete.
     * @example
     * // Delete a few Tbl_next_auths
     * const { count } = await prisma.tbl_next_auth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tbl_next_authDeleteManyArgs>(
      args?: SelectSubset<T, tbl_next_authDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tbl_next_auths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_next_authUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tbl_next_auths
     * const tbl_next_auth = await prisma.tbl_next_auth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tbl_next_authUpdateManyArgs>(
      args: SelectSubset<T, tbl_next_authUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tbl_next_auth.
     * @param {tbl_next_authUpsertArgs} args - Arguments to update or create a Tbl_next_auth.
     * @example
     * // Update or create a Tbl_next_auth
     * const tbl_next_auth = await prisma.tbl_next_auth.upsert({
     *   create: {
     *     // ... data to create a Tbl_next_auth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tbl_next_auth we want to update
     *   }
     * })
    **/
    upsert<T extends tbl_next_authUpsertArgs>(
      args: SelectSubset<T, tbl_next_authUpsertArgs>
    ): Prisma__tbl_next_authClient<tbl_next_authGetPayload<T>>

    /**
     * Count the number of Tbl_next_auths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_next_authCountArgs} args - Arguments to filter Tbl_next_auths to count.
     * @example
     * // Count the number of Tbl_next_auths
     * const count = await prisma.tbl_next_auth.count({
     *   where: {
     *     // ... the filter for the Tbl_next_auths we want to count
     *   }
     * })
    **/
    count<T extends tbl_next_authCountArgs>(
      args?: Subset<T, tbl_next_authCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tbl_next_authCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tbl_next_auth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_next_authAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tbl_next_authAggregateArgs>(args: Subset<T, Tbl_next_authAggregateArgs>): Prisma.PrismaPromise<GetTbl_next_authAggregateType<T>>

    /**
     * Group by Tbl_next_auth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_next_authGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tbl_next_authGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tbl_next_authGroupByArgs['orderBy'] }
        : { orderBy?: Tbl_next_authGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tbl_next_authGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTbl_next_authGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tbl_next_auth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tbl_next_authClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tbl_next_auth base type for findUnique actions
   */
  export type tbl_next_authFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tbl_next_auth
     */
    select?: tbl_next_authSelect | null
    /**
     * Filter, which tbl_next_auth to fetch.
     */
    where: tbl_next_authWhereUniqueInput
  }

  /**
   * tbl_next_auth findUnique
   */
  export interface tbl_next_authFindUniqueArgs extends tbl_next_authFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tbl_next_auth findUniqueOrThrow
   */
  export type tbl_next_authFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tbl_next_auth
     */
    select?: tbl_next_authSelect | null
    /**
     * Filter, which tbl_next_auth to fetch.
     */
    where: tbl_next_authWhereUniqueInput
  }


  /**
   * tbl_next_auth base type for findFirst actions
   */
  export type tbl_next_authFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tbl_next_auth
     */
    select?: tbl_next_authSelect | null
    /**
     * Filter, which tbl_next_auth to fetch.
     */
    where?: tbl_next_authWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_next_auths to fetch.
     */
    orderBy?: Enumerable<tbl_next_authOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbl_next_auths.
     */
    cursor?: tbl_next_authWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_next_auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_next_auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbl_next_auths.
     */
    distinct?: Enumerable<Tbl_next_authScalarFieldEnum>
  }

  /**
   * tbl_next_auth findFirst
   */
  export interface tbl_next_authFindFirstArgs extends tbl_next_authFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tbl_next_auth findFirstOrThrow
   */
  export type tbl_next_authFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tbl_next_auth
     */
    select?: tbl_next_authSelect | null
    /**
     * Filter, which tbl_next_auth to fetch.
     */
    where?: tbl_next_authWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_next_auths to fetch.
     */
    orderBy?: Enumerable<tbl_next_authOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbl_next_auths.
     */
    cursor?: tbl_next_authWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_next_auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_next_auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbl_next_auths.
     */
    distinct?: Enumerable<Tbl_next_authScalarFieldEnum>
  }


  /**
   * tbl_next_auth findMany
   */
  export type tbl_next_authFindManyArgs = {
    /**
     * Select specific fields to fetch from the tbl_next_auth
     */
    select?: tbl_next_authSelect | null
    /**
     * Filter, which tbl_next_auths to fetch.
     */
    where?: tbl_next_authWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_next_auths to fetch.
     */
    orderBy?: Enumerable<tbl_next_authOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tbl_next_auths.
     */
    cursor?: tbl_next_authWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_next_auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_next_auths.
     */
    skip?: number
    distinct?: Enumerable<Tbl_next_authScalarFieldEnum>
  }


  /**
   * tbl_next_auth create
   */
  export type tbl_next_authCreateArgs = {
    /**
     * Select specific fields to fetch from the tbl_next_auth
     */
    select?: tbl_next_authSelect | null
    /**
     * The data needed to create a tbl_next_auth.
     */
    data: XOR<tbl_next_authCreateInput, tbl_next_authUncheckedCreateInput>
  }


  /**
   * tbl_next_auth createMany
   */
  export type tbl_next_authCreateManyArgs = {
    /**
     * The data used to create many tbl_next_auths.
     */
    data: Enumerable<tbl_next_authCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tbl_next_auth update
   */
  export type tbl_next_authUpdateArgs = {
    /**
     * Select specific fields to fetch from the tbl_next_auth
     */
    select?: tbl_next_authSelect | null
    /**
     * The data needed to update a tbl_next_auth.
     */
    data: XOR<tbl_next_authUpdateInput, tbl_next_authUncheckedUpdateInput>
    /**
     * Choose, which tbl_next_auth to update.
     */
    where: tbl_next_authWhereUniqueInput
  }


  /**
   * tbl_next_auth updateMany
   */
  export type tbl_next_authUpdateManyArgs = {
    /**
     * The data used to update tbl_next_auths.
     */
    data: XOR<tbl_next_authUpdateManyMutationInput, tbl_next_authUncheckedUpdateManyInput>
    /**
     * Filter which tbl_next_auths to update
     */
    where?: tbl_next_authWhereInput
  }


  /**
   * tbl_next_auth upsert
   */
  export type tbl_next_authUpsertArgs = {
    /**
     * Select specific fields to fetch from the tbl_next_auth
     */
    select?: tbl_next_authSelect | null
    /**
     * The filter to search for the tbl_next_auth to update in case it exists.
     */
    where: tbl_next_authWhereUniqueInput
    /**
     * In case the tbl_next_auth found by the `where` argument doesn't exist, create a new tbl_next_auth with this data.
     */
    create: XOR<tbl_next_authCreateInput, tbl_next_authUncheckedCreateInput>
    /**
     * In case the tbl_next_auth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tbl_next_authUpdateInput, tbl_next_authUncheckedUpdateInput>
  }


  /**
   * tbl_next_auth delete
   */
  export type tbl_next_authDeleteArgs = {
    /**
     * Select specific fields to fetch from the tbl_next_auth
     */
    select?: tbl_next_authSelect | null
    /**
     * Filter which tbl_next_auth to delete.
     */
    where: tbl_next_authWhereUniqueInput
  }


  /**
   * tbl_next_auth deleteMany
   */
  export type tbl_next_authDeleteManyArgs = {
    /**
     * Filter which tbl_next_auths to delete
     */
    where?: tbl_next_authWhereInput
  }


  /**
   * tbl_next_auth without action
   */
  export type tbl_next_authArgs = {
    /**
     * Select specific fields to fetch from the tbl_next_auth
     */
    select?: tbl_next_authSelect | null
  }



  /**
   * Model tbl_onlineconcert2022_donors
   */


  export type AggregateTbl_onlineconcert2022_donors = {
    _count: Tbl_onlineconcert2022_donorsCountAggregateOutputType | null
    _avg: Tbl_onlineconcert2022_donorsAvgAggregateOutputType | null
    _sum: Tbl_onlineconcert2022_donorsSumAggregateOutputType | null
    _min: Tbl_onlineconcert2022_donorsMinAggregateOutputType | null
    _max: Tbl_onlineconcert2022_donorsMaxAggregateOutputType | null
  }

  export type Tbl_onlineconcert2022_donorsAvgAggregateOutputType = {
    donor_id: number | null
    donor_amount: number | null
  }

  export type Tbl_onlineconcert2022_donorsSumAggregateOutputType = {
    donor_id: number | null
    donor_amount: number | null
  }

  export type Tbl_onlineconcert2022_donorsMinAggregateOutputType = {
    donor_id: number | null
    donor_fname: string | null
    donor_lname: string | null
    donor_amount: number | null
  }

  export type Tbl_onlineconcert2022_donorsMaxAggregateOutputType = {
    donor_id: number | null
    donor_fname: string | null
    donor_lname: string | null
    donor_amount: number | null
  }

  export type Tbl_onlineconcert2022_donorsCountAggregateOutputType = {
    donor_id: number
    donor_fname: number
    donor_lname: number
    donor_amount: number
    _all: number
  }


  export type Tbl_onlineconcert2022_donorsAvgAggregateInputType = {
    donor_id?: true
    donor_amount?: true
  }

  export type Tbl_onlineconcert2022_donorsSumAggregateInputType = {
    donor_id?: true
    donor_amount?: true
  }

  export type Tbl_onlineconcert2022_donorsMinAggregateInputType = {
    donor_id?: true
    donor_fname?: true
    donor_lname?: true
    donor_amount?: true
  }

  export type Tbl_onlineconcert2022_donorsMaxAggregateInputType = {
    donor_id?: true
    donor_fname?: true
    donor_lname?: true
    donor_amount?: true
  }

  export type Tbl_onlineconcert2022_donorsCountAggregateInputType = {
    donor_id?: true
    donor_fname?: true
    donor_lname?: true
    donor_amount?: true
    _all?: true
  }

  export type Tbl_onlineconcert2022_donorsAggregateArgs = {
    /**
     * Filter which tbl_onlineconcert2022_donors to aggregate.
     */
    where?: tbl_onlineconcert2022_donorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_onlineconcert2022_donors to fetch.
     */
    orderBy?: Enumerable<tbl_onlineconcert2022_donorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tbl_onlineconcert2022_donorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_onlineconcert2022_donors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_onlineconcert2022_donors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tbl_onlineconcert2022_donors
    **/
    _count?: true | Tbl_onlineconcert2022_donorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tbl_onlineconcert2022_donorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tbl_onlineconcert2022_donorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tbl_onlineconcert2022_donorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tbl_onlineconcert2022_donorsMaxAggregateInputType
  }

  export type GetTbl_onlineconcert2022_donorsAggregateType<T extends Tbl_onlineconcert2022_donorsAggregateArgs> = {
        [P in keyof T & keyof AggregateTbl_onlineconcert2022_donors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTbl_onlineconcert2022_donors[P]>
      : GetScalarType<T[P], AggregateTbl_onlineconcert2022_donors[P]>
  }




  export type Tbl_onlineconcert2022_donorsGroupByArgs = {
    where?: tbl_onlineconcert2022_donorsWhereInput
    orderBy?: Enumerable<tbl_onlineconcert2022_donorsOrderByWithAggregationInput>
    by: Tbl_onlineconcert2022_donorsScalarFieldEnum[]
    having?: tbl_onlineconcert2022_donorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tbl_onlineconcert2022_donorsCountAggregateInputType | true
    _avg?: Tbl_onlineconcert2022_donorsAvgAggregateInputType
    _sum?: Tbl_onlineconcert2022_donorsSumAggregateInputType
    _min?: Tbl_onlineconcert2022_donorsMinAggregateInputType
    _max?: Tbl_onlineconcert2022_donorsMaxAggregateInputType
  }


  export type Tbl_onlineconcert2022_donorsGroupByOutputType = {
    donor_id: number
    donor_fname: string
    donor_lname: string
    donor_amount: number
    _count: Tbl_onlineconcert2022_donorsCountAggregateOutputType | null
    _avg: Tbl_onlineconcert2022_donorsAvgAggregateOutputType | null
    _sum: Tbl_onlineconcert2022_donorsSumAggregateOutputType | null
    _min: Tbl_onlineconcert2022_donorsMinAggregateOutputType | null
    _max: Tbl_onlineconcert2022_donorsMaxAggregateOutputType | null
  }

  type GetTbl_onlineconcert2022_donorsGroupByPayload<T extends Tbl_onlineconcert2022_donorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Tbl_onlineconcert2022_donorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tbl_onlineconcert2022_donorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tbl_onlineconcert2022_donorsGroupByOutputType[P]>
            : GetScalarType<T[P], Tbl_onlineconcert2022_donorsGroupByOutputType[P]>
        }
      >
    >


  export type tbl_onlineconcert2022_donorsSelect = {
    donor_id?: boolean
    donor_fname?: boolean
    donor_lname?: boolean
    donor_amount?: boolean
  }


  export type tbl_onlineconcert2022_donorsGetPayload<S extends boolean | null | undefined | tbl_onlineconcert2022_donorsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tbl_onlineconcert2022_donors :
    S extends undefined ? never :
    S extends { include: any } & (tbl_onlineconcert2022_donorsArgs | tbl_onlineconcert2022_donorsFindManyArgs)
    ? tbl_onlineconcert2022_donors 
    : S extends { select: any } & (tbl_onlineconcert2022_donorsArgs | tbl_onlineconcert2022_donorsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof tbl_onlineconcert2022_donors ? tbl_onlineconcert2022_donors[P] : never
  } 
      : tbl_onlineconcert2022_donors


  type tbl_onlineconcert2022_donorsCountArgs = 
    Omit<tbl_onlineconcert2022_donorsFindManyArgs, 'select' | 'include'> & {
      select?: Tbl_onlineconcert2022_donorsCountAggregateInputType | true
    }

  export interface tbl_onlineconcert2022_donorsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tbl_onlineconcert2022_donors that matches the filter.
     * @param {tbl_onlineconcert2022_donorsFindUniqueArgs} args - Arguments to find a Tbl_onlineconcert2022_donors
     * @example
     * // Get one Tbl_onlineconcert2022_donors
     * const tbl_onlineconcert2022_donors = await prisma.tbl_onlineconcert2022_donors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tbl_onlineconcert2022_donorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tbl_onlineconcert2022_donorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tbl_onlineconcert2022_donors'> extends True ? Prisma__tbl_onlineconcert2022_donorsClient<tbl_onlineconcert2022_donorsGetPayload<T>> : Prisma__tbl_onlineconcert2022_donorsClient<tbl_onlineconcert2022_donorsGetPayload<T> | null, null>

    /**
     * Find one Tbl_onlineconcert2022_donors that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tbl_onlineconcert2022_donorsFindUniqueOrThrowArgs} args - Arguments to find a Tbl_onlineconcert2022_donors
     * @example
     * // Get one Tbl_onlineconcert2022_donors
     * const tbl_onlineconcert2022_donors = await prisma.tbl_onlineconcert2022_donors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tbl_onlineconcert2022_donorsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tbl_onlineconcert2022_donorsFindUniqueOrThrowArgs>
    ): Prisma__tbl_onlineconcert2022_donorsClient<tbl_onlineconcert2022_donorsGetPayload<T>>

    /**
     * Find the first Tbl_onlineconcert2022_donors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_onlineconcert2022_donorsFindFirstArgs} args - Arguments to find a Tbl_onlineconcert2022_donors
     * @example
     * // Get one Tbl_onlineconcert2022_donors
     * const tbl_onlineconcert2022_donors = await prisma.tbl_onlineconcert2022_donors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tbl_onlineconcert2022_donorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tbl_onlineconcert2022_donorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tbl_onlineconcert2022_donors'> extends True ? Prisma__tbl_onlineconcert2022_donorsClient<tbl_onlineconcert2022_donorsGetPayload<T>> : Prisma__tbl_onlineconcert2022_donorsClient<tbl_onlineconcert2022_donorsGetPayload<T> | null, null>

    /**
     * Find the first Tbl_onlineconcert2022_donors that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_onlineconcert2022_donorsFindFirstOrThrowArgs} args - Arguments to find a Tbl_onlineconcert2022_donors
     * @example
     * // Get one Tbl_onlineconcert2022_donors
     * const tbl_onlineconcert2022_donors = await prisma.tbl_onlineconcert2022_donors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tbl_onlineconcert2022_donorsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tbl_onlineconcert2022_donorsFindFirstOrThrowArgs>
    ): Prisma__tbl_onlineconcert2022_donorsClient<tbl_onlineconcert2022_donorsGetPayload<T>>

    /**
     * Find zero or more Tbl_onlineconcert2022_donors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_onlineconcert2022_donorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tbl_onlineconcert2022_donors
     * const tbl_onlineconcert2022_donors = await prisma.tbl_onlineconcert2022_donors.findMany()
     * 
     * // Get first 10 Tbl_onlineconcert2022_donors
     * const tbl_onlineconcert2022_donors = await prisma.tbl_onlineconcert2022_donors.findMany({ take: 10 })
     * 
     * // Only select the `donor_id`
     * const tbl_onlineconcert2022_donorsWithDonor_idOnly = await prisma.tbl_onlineconcert2022_donors.findMany({ select: { donor_id: true } })
     * 
    **/
    findMany<T extends tbl_onlineconcert2022_donorsFindManyArgs>(
      args?: SelectSubset<T, tbl_onlineconcert2022_donorsFindManyArgs>
    ): Prisma.PrismaPromise<Array<tbl_onlineconcert2022_donorsGetPayload<T>>>

    /**
     * Create a Tbl_onlineconcert2022_donors.
     * @param {tbl_onlineconcert2022_donorsCreateArgs} args - Arguments to create a Tbl_onlineconcert2022_donors.
     * @example
     * // Create one Tbl_onlineconcert2022_donors
     * const Tbl_onlineconcert2022_donors = await prisma.tbl_onlineconcert2022_donors.create({
     *   data: {
     *     // ... data to create a Tbl_onlineconcert2022_donors
     *   }
     * })
     * 
    **/
    create<T extends tbl_onlineconcert2022_donorsCreateArgs>(
      args: SelectSubset<T, tbl_onlineconcert2022_donorsCreateArgs>
    ): Prisma__tbl_onlineconcert2022_donorsClient<tbl_onlineconcert2022_donorsGetPayload<T>>

    /**
     * Create many Tbl_onlineconcert2022_donors.
     *     @param {tbl_onlineconcert2022_donorsCreateManyArgs} args - Arguments to create many Tbl_onlineconcert2022_donors.
     *     @example
     *     // Create many Tbl_onlineconcert2022_donors
     *     const tbl_onlineconcert2022_donors = await prisma.tbl_onlineconcert2022_donors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tbl_onlineconcert2022_donorsCreateManyArgs>(
      args?: SelectSubset<T, tbl_onlineconcert2022_donorsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tbl_onlineconcert2022_donors.
     * @param {tbl_onlineconcert2022_donorsDeleteArgs} args - Arguments to delete one Tbl_onlineconcert2022_donors.
     * @example
     * // Delete one Tbl_onlineconcert2022_donors
     * const Tbl_onlineconcert2022_donors = await prisma.tbl_onlineconcert2022_donors.delete({
     *   where: {
     *     // ... filter to delete one Tbl_onlineconcert2022_donors
     *   }
     * })
     * 
    **/
    delete<T extends tbl_onlineconcert2022_donorsDeleteArgs>(
      args: SelectSubset<T, tbl_onlineconcert2022_donorsDeleteArgs>
    ): Prisma__tbl_onlineconcert2022_donorsClient<tbl_onlineconcert2022_donorsGetPayload<T>>

    /**
     * Update one Tbl_onlineconcert2022_donors.
     * @param {tbl_onlineconcert2022_donorsUpdateArgs} args - Arguments to update one Tbl_onlineconcert2022_donors.
     * @example
     * // Update one Tbl_onlineconcert2022_donors
     * const tbl_onlineconcert2022_donors = await prisma.tbl_onlineconcert2022_donors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tbl_onlineconcert2022_donorsUpdateArgs>(
      args: SelectSubset<T, tbl_onlineconcert2022_donorsUpdateArgs>
    ): Prisma__tbl_onlineconcert2022_donorsClient<tbl_onlineconcert2022_donorsGetPayload<T>>

    /**
     * Delete zero or more Tbl_onlineconcert2022_donors.
     * @param {tbl_onlineconcert2022_donorsDeleteManyArgs} args - Arguments to filter Tbl_onlineconcert2022_donors to delete.
     * @example
     * // Delete a few Tbl_onlineconcert2022_donors
     * const { count } = await prisma.tbl_onlineconcert2022_donors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tbl_onlineconcert2022_donorsDeleteManyArgs>(
      args?: SelectSubset<T, tbl_onlineconcert2022_donorsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tbl_onlineconcert2022_donors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_onlineconcert2022_donorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tbl_onlineconcert2022_donors
     * const tbl_onlineconcert2022_donors = await prisma.tbl_onlineconcert2022_donors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tbl_onlineconcert2022_donorsUpdateManyArgs>(
      args: SelectSubset<T, tbl_onlineconcert2022_donorsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tbl_onlineconcert2022_donors.
     * @param {tbl_onlineconcert2022_donorsUpsertArgs} args - Arguments to update or create a Tbl_onlineconcert2022_donors.
     * @example
     * // Update or create a Tbl_onlineconcert2022_donors
     * const tbl_onlineconcert2022_donors = await prisma.tbl_onlineconcert2022_donors.upsert({
     *   create: {
     *     // ... data to create a Tbl_onlineconcert2022_donors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tbl_onlineconcert2022_donors we want to update
     *   }
     * })
    **/
    upsert<T extends tbl_onlineconcert2022_donorsUpsertArgs>(
      args: SelectSubset<T, tbl_onlineconcert2022_donorsUpsertArgs>
    ): Prisma__tbl_onlineconcert2022_donorsClient<tbl_onlineconcert2022_donorsGetPayload<T>>

    /**
     * Count the number of Tbl_onlineconcert2022_donors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tbl_onlineconcert2022_donorsCountArgs} args - Arguments to filter Tbl_onlineconcert2022_donors to count.
     * @example
     * // Count the number of Tbl_onlineconcert2022_donors
     * const count = await prisma.tbl_onlineconcert2022_donors.count({
     *   where: {
     *     // ... the filter for the Tbl_onlineconcert2022_donors we want to count
     *   }
     * })
    **/
    count<T extends tbl_onlineconcert2022_donorsCountArgs>(
      args?: Subset<T, tbl_onlineconcert2022_donorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tbl_onlineconcert2022_donorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tbl_onlineconcert2022_donors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_onlineconcert2022_donorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tbl_onlineconcert2022_donorsAggregateArgs>(args: Subset<T, Tbl_onlineconcert2022_donorsAggregateArgs>): Prisma.PrismaPromise<GetTbl_onlineconcert2022_donorsAggregateType<T>>

    /**
     * Group by Tbl_onlineconcert2022_donors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tbl_onlineconcert2022_donorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tbl_onlineconcert2022_donorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tbl_onlineconcert2022_donorsGroupByArgs['orderBy'] }
        : { orderBy?: Tbl_onlineconcert2022_donorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tbl_onlineconcert2022_donorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTbl_onlineconcert2022_donorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tbl_onlineconcert2022_donors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tbl_onlineconcert2022_donorsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tbl_onlineconcert2022_donors base type for findUnique actions
   */
  export type tbl_onlineconcert2022_donorsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tbl_onlineconcert2022_donors
     */
    select?: tbl_onlineconcert2022_donorsSelect | null
    /**
     * Filter, which tbl_onlineconcert2022_donors to fetch.
     */
    where: tbl_onlineconcert2022_donorsWhereUniqueInput
  }

  /**
   * tbl_onlineconcert2022_donors findUnique
   */
  export interface tbl_onlineconcert2022_donorsFindUniqueArgs extends tbl_onlineconcert2022_donorsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tbl_onlineconcert2022_donors findUniqueOrThrow
   */
  export type tbl_onlineconcert2022_donorsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tbl_onlineconcert2022_donors
     */
    select?: tbl_onlineconcert2022_donorsSelect | null
    /**
     * Filter, which tbl_onlineconcert2022_donors to fetch.
     */
    where: tbl_onlineconcert2022_donorsWhereUniqueInput
  }


  /**
   * tbl_onlineconcert2022_donors base type for findFirst actions
   */
  export type tbl_onlineconcert2022_donorsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tbl_onlineconcert2022_donors
     */
    select?: tbl_onlineconcert2022_donorsSelect | null
    /**
     * Filter, which tbl_onlineconcert2022_donors to fetch.
     */
    where?: tbl_onlineconcert2022_donorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_onlineconcert2022_donors to fetch.
     */
    orderBy?: Enumerable<tbl_onlineconcert2022_donorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbl_onlineconcert2022_donors.
     */
    cursor?: tbl_onlineconcert2022_donorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_onlineconcert2022_donors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_onlineconcert2022_donors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbl_onlineconcert2022_donors.
     */
    distinct?: Enumerable<Tbl_onlineconcert2022_donorsScalarFieldEnum>
  }

  /**
   * tbl_onlineconcert2022_donors findFirst
   */
  export interface tbl_onlineconcert2022_donorsFindFirstArgs extends tbl_onlineconcert2022_donorsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tbl_onlineconcert2022_donors findFirstOrThrow
   */
  export type tbl_onlineconcert2022_donorsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tbl_onlineconcert2022_donors
     */
    select?: tbl_onlineconcert2022_donorsSelect | null
    /**
     * Filter, which tbl_onlineconcert2022_donors to fetch.
     */
    where?: tbl_onlineconcert2022_donorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_onlineconcert2022_donors to fetch.
     */
    orderBy?: Enumerable<tbl_onlineconcert2022_donorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tbl_onlineconcert2022_donors.
     */
    cursor?: tbl_onlineconcert2022_donorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_onlineconcert2022_donors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_onlineconcert2022_donors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tbl_onlineconcert2022_donors.
     */
    distinct?: Enumerable<Tbl_onlineconcert2022_donorsScalarFieldEnum>
  }


  /**
   * tbl_onlineconcert2022_donors findMany
   */
  export type tbl_onlineconcert2022_donorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the tbl_onlineconcert2022_donors
     */
    select?: tbl_onlineconcert2022_donorsSelect | null
    /**
     * Filter, which tbl_onlineconcert2022_donors to fetch.
     */
    where?: tbl_onlineconcert2022_donorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tbl_onlineconcert2022_donors to fetch.
     */
    orderBy?: Enumerable<tbl_onlineconcert2022_donorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tbl_onlineconcert2022_donors.
     */
    cursor?: tbl_onlineconcert2022_donorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tbl_onlineconcert2022_donors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tbl_onlineconcert2022_donors.
     */
    skip?: number
    distinct?: Enumerable<Tbl_onlineconcert2022_donorsScalarFieldEnum>
  }


  /**
   * tbl_onlineconcert2022_donors create
   */
  export type tbl_onlineconcert2022_donorsCreateArgs = {
    /**
     * Select specific fields to fetch from the tbl_onlineconcert2022_donors
     */
    select?: tbl_onlineconcert2022_donorsSelect | null
    /**
     * The data needed to create a tbl_onlineconcert2022_donors.
     */
    data: XOR<tbl_onlineconcert2022_donorsCreateInput, tbl_onlineconcert2022_donorsUncheckedCreateInput>
  }


  /**
   * tbl_onlineconcert2022_donors createMany
   */
  export type tbl_onlineconcert2022_donorsCreateManyArgs = {
    /**
     * The data used to create many tbl_onlineconcert2022_donors.
     */
    data: Enumerable<tbl_onlineconcert2022_donorsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tbl_onlineconcert2022_donors update
   */
  export type tbl_onlineconcert2022_donorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the tbl_onlineconcert2022_donors
     */
    select?: tbl_onlineconcert2022_donorsSelect | null
    /**
     * The data needed to update a tbl_onlineconcert2022_donors.
     */
    data: XOR<tbl_onlineconcert2022_donorsUpdateInput, tbl_onlineconcert2022_donorsUncheckedUpdateInput>
    /**
     * Choose, which tbl_onlineconcert2022_donors to update.
     */
    where: tbl_onlineconcert2022_donorsWhereUniqueInput
  }


  /**
   * tbl_onlineconcert2022_donors updateMany
   */
  export type tbl_onlineconcert2022_donorsUpdateManyArgs = {
    /**
     * The data used to update tbl_onlineconcert2022_donors.
     */
    data: XOR<tbl_onlineconcert2022_donorsUpdateManyMutationInput, tbl_onlineconcert2022_donorsUncheckedUpdateManyInput>
    /**
     * Filter which tbl_onlineconcert2022_donors to update
     */
    where?: tbl_onlineconcert2022_donorsWhereInput
  }


  /**
   * tbl_onlineconcert2022_donors upsert
   */
  export type tbl_onlineconcert2022_donorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the tbl_onlineconcert2022_donors
     */
    select?: tbl_onlineconcert2022_donorsSelect | null
    /**
     * The filter to search for the tbl_onlineconcert2022_donors to update in case it exists.
     */
    where: tbl_onlineconcert2022_donorsWhereUniqueInput
    /**
     * In case the tbl_onlineconcert2022_donors found by the `where` argument doesn't exist, create a new tbl_onlineconcert2022_donors with this data.
     */
    create: XOR<tbl_onlineconcert2022_donorsCreateInput, tbl_onlineconcert2022_donorsUncheckedCreateInput>
    /**
     * In case the tbl_onlineconcert2022_donors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tbl_onlineconcert2022_donorsUpdateInput, tbl_onlineconcert2022_donorsUncheckedUpdateInput>
  }


  /**
   * tbl_onlineconcert2022_donors delete
   */
  export type tbl_onlineconcert2022_donorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the tbl_onlineconcert2022_donors
     */
    select?: tbl_onlineconcert2022_donorsSelect | null
    /**
     * Filter which tbl_onlineconcert2022_donors to delete.
     */
    where: tbl_onlineconcert2022_donorsWhereUniqueInput
  }


  /**
   * tbl_onlineconcert2022_donors deleteMany
   */
  export type tbl_onlineconcert2022_donorsDeleteManyArgs = {
    /**
     * Filter which tbl_onlineconcert2022_donors to delete
     */
    where?: tbl_onlineconcert2022_donorsWhereInput
  }


  /**
   * tbl_onlineconcert2022_donors without action
   */
  export type tbl_onlineconcert2022_donorsArgs = {
    /**
     * Select specific fields to fetch from the tbl_onlineconcert2022_donors
     */
    select?: tbl_onlineconcert2022_donorsSelect | null
  }



  /**
   * Model users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    Username: string | null
    Password: string | null
    id: number | null
  }

  export type UsersMaxAggregateOutputType = {
    Username: string | null
    Password: string | null
    id: number | null
  }

  export type UsersCountAggregateOutputType = {
    Username: number
    Password: number
    id: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    Username?: true
    Password?: true
    id?: true
  }

  export type UsersMaxAggregateInputType = {
    Username?: true
    Password?: true
    id?: true
  }

  export type UsersCountAggregateInputType = {
    Username?: true
    Password?: true
    id?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs = {
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithAggregationInput>
    by: UsersScalarFieldEnum[]
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    Username: string
    Password: string
    id: number
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect = {
    Username?: boolean
    Password?: boolean
    id?: boolean
  }


  export type usersGetPayload<S extends boolean | null | undefined | usersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? users :
    S extends undefined ? never :
    S extends { include: any } & (usersArgs | usersFindManyArgs)
    ? users 
    : S extends { select: any } & (usersArgs | usersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof users ? users[P] : never
  } 
      : users


  type usersCountArgs = 
    Omit<usersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'users'> extends True ? Prisma__usersClient<usersGetPayload<T>> : Prisma__usersClient<usersGetPayload<T> | null, null>

    /**
     * Find one Users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'users'> extends True ? Prisma__usersClient<usersGetPayload<T>> : Prisma__usersClient<usersGetPayload<T> | null, null>

    /**
     * Find the first Users that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `Username`
     * const usersWithUsernameOnly = await prisma.users.findMany({ select: { Username: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs>(
      args?: SelectSubset<T, usersFindManyArgs>
    ): Prisma.PrismaPromise<Array<usersGetPayload<T>>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs>(
      args: SelectSubset<T, usersCreateArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs>(
      args?: SelectSubset<T, usersCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs>(
      args: SelectSubset<T, usersDeleteArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs>(
      args: SelectSubset<T, usersUpdateArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs>(
      args?: SelectSubset<T, usersDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs>(
      args: SelectSubset<T, usersUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs>(
      args: SelectSubset<T, usersUpsertArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * users base type for findUnique actions
   */
  export type usersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUnique
   */
  export interface usersFindUniqueArgs extends usersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users base type for findFirst actions
   */
  export type usersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UsersScalarFieldEnum>
  }

  /**
   * users findFirst
   */
  export interface usersFindFirstArgs extends usersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users findMany
   */
  export type usersFindManyArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users create
   */
  export type usersCreateArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs = {
    /**
     * The data used to create many users.
     */
    data: Enumerable<usersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * users update
   */
  export type usersUpdateArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }


  /**
   * users without action
   */
  export type usersArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TBEventReg_ACM2017ScalarFieldEnum: {
    ID: 'ID',
    EventTitle: 'EventTitle',
    RegName: 'RegName',
    RegEmail: 'RegEmail',
    RegTel: 'RegTel',
    RegAddress: 'RegAddress',
    RegAffiliate: 'RegAffiliate',
    RegPreamble: 'RegPreamble',
    RegQuestion: 'RegQuestion',
    RegDate: 'RegDate',
    RegIP: 'RegIP'
  };

  export type TBEventReg_ACM2017ScalarFieldEnum = (typeof TBEventReg_ACM2017ScalarFieldEnum)[keyof typeof TBEventReg_ACM2017ScalarFieldEnum]


  export const TBEventReg_ACM2018ScalarFieldEnum: {
    ID: 'ID',
    EventTitle: 'EventTitle',
    RegName: 'RegName',
    RegEmail: 'RegEmail',
    RegTel: 'RegTel',
    RegAddress: 'RegAddress',
    RegAffiliate: 'RegAffiliate',
    RegPreamble: 'RegPreamble',
    RegQuestion: 'RegQuestion',
    RegDate: 'RegDate',
    RegIP: 'RegIP'
  };

  export type TBEventReg_ACM2018ScalarFieldEnum = (typeof TBEventReg_ACM2018ScalarFieldEnum)[keyof typeof TBEventReg_ACM2018ScalarFieldEnum]


  export const TBEventReg_ACM2022ScalarFieldEnum: {
    ID: 'ID',
    EventTitle: 'EventTitle',
    RegName: 'RegName',
    RegEmail: 'RegEmail',
    RegTel: 'RegTel',
    RegAddress: 'RegAddress',
    RegAffiliate: 'RegAffiliate',
    RegPreamble: 'RegPreamble',
    RegQuestion: 'RegQuestion',
    RegDate: 'RegDate',
    RegIP: 'RegIP'
  };

  export type TBEventReg_ACM2022ScalarFieldEnum = (typeof TBEventReg_ACM2022ScalarFieldEnum)[keyof typeof TBEventReg_ACM2022ScalarFieldEnum]


  export const TBEventReg_ChessChampionship2019ScalarFieldEnum: {
    ID: 'ID',
    EventTitle: 'EventTitle',
    RegNameFirst: 'RegNameFirst',
    RegNameLast: 'RegNameLast',
    RegDOB: 'RegDOB',
    RegEmail: 'RegEmail',
    RegTel: 'RegTel',
    ParentNameFirst: 'ParentNameFirst',
    ParentNameLast: 'ParentNameLast',
    ParentTel: 'ParentTel',
    ParentEmail: 'ParentEmail',
    RegDate: 'RegDate',
    RegIP: 'RegIP'
  };

  export type TBEventReg_ChessChampionship2019ScalarFieldEnum = (typeof TBEventReg_ChessChampionship2019ScalarFieldEnum)[keyof typeof TBEventReg_ChessChampionship2019ScalarFieldEnum]


  export const TBEventReg_SEEE_2017ScalarFieldEnum: {
    ID: 'ID',
    EventTitle: 'EventTitle',
    RegName: 'RegName',
    RegEmail: 'RegEmail',
    RegTel: 'RegTel',
    RegAddress: 'RegAddress',
    RegDate: 'RegDate',
    RegIP: 'RegIP',
    RegLunch: 'RegLunch'
  };

  export type TBEventReg_SEEE_2017ScalarFieldEnum = (typeof TBEventReg_SEEE_2017ScalarFieldEnum)[keyof typeof TBEventReg_SEEE_2017ScalarFieldEnum]


  export const TBEventReg_SEEE_2017_VenderInfoScalarFieldEnum: {
    ID: 'ID',
    VenderCompTitle: 'VenderCompTitle',
    VenderResource: 'VenderResource',
    VenderEmail: 'VenderEmail',
    VenderDescrip: 'VenderDescrip',
    VenderBooth: 'VenderBooth',
    VenderTel: 'VenderTel',
    AMorPM: 'AMorPM',
    AM1: 'AM1',
    AM2: 'AM2',
    AM3: 'AM3',
    AM4: 'AM4',
    AM5: 'AM5',
    AM6: 'AM6',
    PM1: 'PM1',
    PM2: 'PM2',
    PM3: 'PM3',
    PM4: 'PM4',
    PM5: 'PM5',
    PM6: 'PM6'
  };

  export type TBEventReg_SEEE_2017_VenderInfoScalarFieldEnum = (typeof TBEventReg_SEEE_2017_VenderInfoScalarFieldEnum)[keyof typeof TBEventReg_SEEE_2017_VenderInfoScalarFieldEnum]


  export const TBEventReg_SEEE_2018ScalarFieldEnum: {
    ID: 'ID',
    EventTitle: 'EventTitle',
    RegName: 'RegName',
    RegEmail: 'RegEmail',
    RegTel: 'RegTel',
    RegAddress: 'RegAddress',
    RegDate: 'RegDate',
    RegIP: 'RegIP',
    RegLunch: 'RegLunch'
  };

  export type TBEventReg_SEEE_2018ScalarFieldEnum = (typeof TBEventReg_SEEE_2018ScalarFieldEnum)[keyof typeof TBEventReg_SEEE_2018ScalarFieldEnum]


  export const TBEventReg_SEEE_2018_VenderInfoScalarFieldEnum: {
    ID: 'ID',
    VenderCompTitle: 'VenderCompTitle',
    VenderContactPerson: 'VenderContactPerson',
    VenderResource: 'VenderResource',
    VenderEmail: 'VenderEmail',
    VenderDescrip: 'VenderDescrip',
    VenderBooth: 'VenderBooth',
    VenderTel: 'VenderTel',
    TimeSlot1: 'TimeSlot1',
    TimeSlot2: 'TimeSlot2',
    TimeSlot3: 'TimeSlot3',
    TimeSlot4: 'TimeSlot4',
    TimeSlot5: 'TimeSlot5',
    TimeSlot6: 'TimeSlot6',
    TimeSlot7: 'TimeSlot7',
    TimeSlot8: 'TimeSlot8',
    TimeSlot9: 'TimeSlot9',
    TimeSlot10: 'TimeSlot10'
  };

  export type TBEventReg_SEEE_2018_VenderInfoScalarFieldEnum = (typeof TBEventReg_SEEE_2018_VenderInfoScalarFieldEnum)[keyof typeof TBEventReg_SEEE_2018_VenderInfoScalarFieldEnum]


  export const TBEventReg_SpringIntoActionScalarFieldEnum: {
    ID: 'ID',
    EventTitle: 'EventTitle',
    RegName: 'RegName',
    RegEmail: 'RegEmail',
    RegTel: 'RegTel',
    RegAddress: 'RegAddress',
    RegDate: 'RegDate',
    RegIP: 'RegIP'
  };

  export type TBEventReg_SpringIntoActionScalarFieldEnum = (typeof TBEventReg_SpringIntoActionScalarFieldEnum)[keyof typeof TBEventReg_SpringIntoActionScalarFieldEnum]


  export const TBInvisibleIllness2019ScalarFieldEnum: {
    IndexID: 'IndexID',
    RegName: 'RegName',
    RegEmail: 'RegEmail',
    RegTel: 'RegTel',
    IfRCDMember: 'IfRCDMember',
    RegDate: 'RegDate',
    RegIP: 'RegIP'
  };

  export type TBInvisibleIllness2019ScalarFieldEnum = (typeof TBInvisibleIllness2019ScalarFieldEnum)[keyof typeof TBInvisibleIllness2019ScalarFieldEnum]


  export const TB_2017Gala_KaraokaScalarFieldEnum: {
    ID: 'ID',
    NominatorName: 'NominatorName',
    NominatorTelEmail: 'NominatorTelEmail',
    NomineeName: 'NomineeName',
    NomineeTelEmail: 'NomineeTelEmail',
    KaraokeName: 'KaraokeName',
    BringCD: 'BringCD',
    RegDateTime: 'RegDateTime'
  };

  export type TB_2017Gala_KaraokaScalarFieldEnum = (typeof TB_2017Gala_KaraokaScalarFieldEnum)[keyof typeof TB_2017Gala_KaraokaScalarFieldEnum]


  export const Tbl_barrage_ILAcrossCanadaDay2023ScalarFieldEnum: {
    barrage_id: 'barrage_id',
    barrage_content: 'barrage_content',
    createdAt: 'createdAt'
  };

  export type Tbl_barrage_ILAcrossCanadaDay2023ScalarFieldEnum = (typeof Tbl_barrage_ILAcrossCanadaDay2023ScalarFieldEnum)[keyof typeof Tbl_barrage_ILAcrossCanadaDay2023ScalarFieldEnum]


  export const Auth_groupScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Auth_groupScalarFieldEnum = (typeof Auth_groupScalarFieldEnum)[keyof typeof Auth_groupScalarFieldEnum]


  export const Auth_group_permissionsScalarFieldEnum: {
    id: 'id',
    group_id: 'group_id',
    permission_id: 'permission_id'
  };

  export type Auth_group_permissionsScalarFieldEnum = (typeof Auth_group_permissionsScalarFieldEnum)[keyof typeof Auth_group_permissionsScalarFieldEnum]


  export const Auth_permissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    content_type_id: 'content_type_id',
    codename: 'codename'
  };

  export type Auth_permissionScalarFieldEnum = (typeof Auth_permissionScalarFieldEnum)[keyof typeof Auth_permissionScalarFieldEnum]


  export const Auth_userScalarFieldEnum: {
    id: 'id',
    password: 'password',
    last_login: 'last_login',
    is_superuser: 'is_superuser',
    username: 'username',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    is_staff: 'is_staff',
    is_active: 'is_active',
    date_joined: 'date_joined'
  };

  export type Auth_userScalarFieldEnum = (typeof Auth_userScalarFieldEnum)[keyof typeof Auth_userScalarFieldEnum]


  export const Auth_user_groupsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    group_id: 'group_id'
  };

  export type Auth_user_groupsScalarFieldEnum = (typeof Auth_user_groupsScalarFieldEnum)[keyof typeof Auth_user_groupsScalarFieldEnum]


  export const Auth_user_user_permissionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    permission_id: 'permission_id'
  };

  export type Auth_user_user_permissionsScalarFieldEnum = (typeof Auth_user_user_permissionsScalarFieldEnum)[keyof typeof Auth_user_user_permissionsScalarFieldEnum]


  export const CategoryListScalarFieldEnum: {
    categorytype: 'categorytype',
    hide: 'hide',
    categoryID: 'categoryID'
  };

  export type CategoryListScalarFieldEnum = (typeof CategoryListScalarFieldEnum)[keyof typeof CategoryListScalarFieldEnum]


  export const Django_admin_logScalarFieldEnum: {
    id: 'id',
    action_time: 'action_time',
    object_id: 'object_id',
    object_repr: 'object_repr',
    action_flag: 'action_flag',
    change_message: 'change_message',
    content_type_id: 'content_type_id',
    user_id: 'user_id'
  };

  export type Django_admin_logScalarFieldEnum = (typeof Django_admin_logScalarFieldEnum)[keyof typeof Django_admin_logScalarFieldEnum]


  export const Django_content_typeScalarFieldEnum: {
    id: 'id',
    app_label: 'app_label',
    model: 'model'
  };

  export type Django_content_typeScalarFieldEnum = (typeof Django_content_typeScalarFieldEnum)[keyof typeof Django_content_typeScalarFieldEnum]


  export const Django_migrationsScalarFieldEnum: {
    id: 'id',
    app: 'app',
    name: 'name',
    applied: 'applied'
  };

  export type Django_migrationsScalarFieldEnum = (typeof Django_migrationsScalarFieldEnum)[keyof typeof Django_migrationsScalarFieldEnum]


  export const Django_sessionScalarFieldEnum: {
    session_key: 'session_key',
    session_data: 'session_data',
    expire_date: 'expire_date'
  };

  export type Django_sessionScalarFieldEnum = (typeof Django_sessionScalarFieldEnum)[keyof typeof Django_sessionScalarFieldEnum]


  export const EventsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    color: 'color',
    start: 'start',
    end: 'end'
  };

  export type EventsScalarFieldEnum = (typeof EventsScalarFieldEnum)[keyof typeof EventsScalarFieldEnum]


  export const RecordInfoScalarFieldEnum: {
    recordInfo_ID: 'recordInfo_ID',
    categoryID: 'categoryID',
    Name: 'Name',
    StreetAddress: 'StreetAddress',
    City: 'City',
    PostalCode: 'PostalCode',
    Province: 'Province',
    Telephone: 'Telephone',
    Fax: 'Fax',
    Website: 'Website'
  };

  export type RecordInfoScalarFieldEnum = (typeof RecordInfoScalarFieldEnum)[keyof typeof RecordInfoScalarFieldEnum]


  export const Tbl_BMORun2024_BarrageScalarFieldEnum: {
    ID: 'ID',
    donor_Fname: 'donor_Fname',
    donor_Lname: 'donor_Lname',
    donor_Org: 'donor_Org',
    donor_Amount: 'donor_Amount',
    createdAt: 'createdAt'
  };

  export type Tbl_BMORun2024_BarrageScalarFieldEnum = (typeof Tbl_BMORun2024_BarrageScalarFieldEnum)[keyof typeof Tbl_BMORun2024_BarrageScalarFieldEnum]


  export const Tbl_ETransferInfoScalarFieldEnum: {
    id: 'id',
    fname: 'fname',
    lname: 'lname',
    userAddress: 'userAddress',
    userTel: 'userTel',
    useremail: 'useremail',
    todaydate: 'todaydate',
    RegDate: 'RegDate',
    RegTime: 'RegTime',
    userIP: 'userIP'
  };

  export type Tbl_ETransferInfoScalarFieldEnum = (typeof Tbl_ETransferInfoScalarFieldEnum)[keyof typeof Tbl_ETransferInfoScalarFieldEnum]


  export const Tbl_TshirtContestScalarFieldEnum: {
    id: 'id',
    fname: 'fname',
    lname: 'lname',
    tel: 'tel',
    email: 'email',
    notes: 'notes',
    artwork: 'artwork',
    imgPreview: 'imgPreview',
    ip: 'ip',
    submitTime: 'submitTime'
  };

  export type Tbl_TshirtContestScalarFieldEnum = (typeof Tbl_TshirtContestScalarFieldEnum)[keyof typeof Tbl_TshirtContestScalarFieldEnum]


  export const Tbl_barrage_at_us_2023ScalarFieldEnum: {
    id: 'id',
    barrageContent: 'barrageContent'
  };

  export type Tbl_barrage_at_us_2023ScalarFieldEnum = (typeof Tbl_barrage_at_us_2023ScalarFieldEnum)[keyof typeof Tbl_barrage_at_us_2023ScalarFieldEnum]


  export const Tbl_next_authScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    email: 'email',
    isVerified: 'isVerified',
    isAdmin: 'isAdmin'
  };

  export type Tbl_next_authScalarFieldEnum = (typeof Tbl_next_authScalarFieldEnum)[keyof typeof Tbl_next_authScalarFieldEnum]


  export const Tbl_onlineconcert2022_donorsScalarFieldEnum: {
    donor_id: 'donor_id',
    donor_fname: 'donor_fname',
    donor_lname: 'donor_lname',
    donor_amount: 'donor_amount'
  };

  export type Tbl_onlineconcert2022_donorsScalarFieldEnum = (typeof Tbl_onlineconcert2022_donorsScalarFieldEnum)[keyof typeof Tbl_onlineconcert2022_donorsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    Username: 'Username',
    Password: 'Password',
    id: 'id'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type TBEventReg_ACM2017WhereInput = {
    AND?: Enumerable<TBEventReg_ACM2017WhereInput>
    OR?: Enumerable<TBEventReg_ACM2017WhereInput>
    NOT?: Enumerable<TBEventReg_ACM2017WhereInput>
    ID?: IntFilter<"TBEventReg_ACM2017"> | number
    EventTitle?: StringNullableFilter<"TBEventReg_ACM2017"> | string | null
    RegName?: StringNullableFilter<"TBEventReg_ACM2017"> | string | null
    RegEmail?: StringNullableFilter<"TBEventReg_ACM2017"> | string | null
    RegTel?: StringNullableFilter<"TBEventReg_ACM2017"> | string | null
    RegAddress?: StringNullableFilter<"TBEventReg_ACM2017"> | string | null
    RegAffiliate?: StringNullableFilter<"TBEventReg_ACM2017"> | string | null
    RegPreamble?: StringFilter<"TBEventReg_ACM2017"> | string
    RegQuestion?: StringFilter<"TBEventReg_ACM2017"> | string
    RegDate?: DateTimeNullableFilter<"TBEventReg_ACM2017"> | Date | string | null
    RegIP?: StringFilter<"TBEventReg_ACM2017"> | string
  }

  export type TBEventReg_ACM2017OrderByWithRelationInput = {
    ID?: SortOrder
    EventTitle?: SortOrderInput | SortOrder
    RegName?: SortOrderInput | SortOrder
    RegEmail?: SortOrderInput | SortOrder
    RegTel?: SortOrderInput | SortOrder
    RegAddress?: SortOrderInput | SortOrder
    RegAffiliate?: SortOrderInput | SortOrder
    RegPreamble?: SortOrder
    RegQuestion?: SortOrder
    RegDate?: SortOrderInput | SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ACM2017WhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: Enumerable<TBEventReg_ACM2017WhereInput>
    OR?: Enumerable<TBEventReg_ACM2017WhereInput>
    NOT?: Enumerable<TBEventReg_ACM2017WhereInput>
    EventTitle?: StringNullableFilter<"TBEventReg_ACM2017"> | string | null
    RegName?: StringNullableFilter<"TBEventReg_ACM2017"> | string | null
    RegEmail?: StringNullableFilter<"TBEventReg_ACM2017"> | string | null
    RegTel?: StringNullableFilter<"TBEventReg_ACM2017"> | string | null
    RegAddress?: StringNullableFilter<"TBEventReg_ACM2017"> | string | null
    RegAffiliate?: StringNullableFilter<"TBEventReg_ACM2017"> | string | null
    RegPreamble?: StringFilter<"TBEventReg_ACM2017"> | string
    RegQuestion?: StringFilter<"TBEventReg_ACM2017"> | string
    RegDate?: DateTimeNullableFilter<"TBEventReg_ACM2017"> | Date | string | null
    RegIP?: StringFilter<"TBEventReg_ACM2017"> | string
  }, "ID">

  export type TBEventReg_ACM2017OrderByWithAggregationInput = {
    ID?: SortOrder
    EventTitle?: SortOrderInput | SortOrder
    RegName?: SortOrderInput | SortOrder
    RegEmail?: SortOrderInput | SortOrder
    RegTel?: SortOrderInput | SortOrder
    RegAddress?: SortOrderInput | SortOrder
    RegAffiliate?: SortOrderInput | SortOrder
    RegPreamble?: SortOrder
    RegQuestion?: SortOrder
    RegDate?: SortOrderInput | SortOrder
    RegIP?: SortOrder
    _count?: TBEventReg_ACM2017CountOrderByAggregateInput
    _avg?: TBEventReg_ACM2017AvgOrderByAggregateInput
    _max?: TBEventReg_ACM2017MaxOrderByAggregateInput
    _min?: TBEventReg_ACM2017MinOrderByAggregateInput
    _sum?: TBEventReg_ACM2017SumOrderByAggregateInput
  }

  export type TBEventReg_ACM2017ScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TBEventReg_ACM2017ScalarWhereWithAggregatesInput>
    OR?: Enumerable<TBEventReg_ACM2017ScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TBEventReg_ACM2017ScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter<"TBEventReg_ACM2017"> | number
    EventTitle?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2017"> | string | null
    RegName?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2017"> | string | null
    RegEmail?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2017"> | string | null
    RegTel?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2017"> | string | null
    RegAddress?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2017"> | string | null
    RegAffiliate?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2017"> | string | null
    RegPreamble?: StringWithAggregatesFilter<"TBEventReg_ACM2017"> | string
    RegQuestion?: StringWithAggregatesFilter<"TBEventReg_ACM2017"> | string
    RegDate?: DateTimeNullableWithAggregatesFilter<"TBEventReg_ACM2017"> | Date | string | null
    RegIP?: StringWithAggregatesFilter<"TBEventReg_ACM2017"> | string
  }

  export type TBEventReg_ACM2018WhereInput = {
    AND?: Enumerable<TBEventReg_ACM2018WhereInput>
    OR?: Enumerable<TBEventReg_ACM2018WhereInput>
    NOT?: Enumerable<TBEventReg_ACM2018WhereInput>
    ID?: IntFilter<"TBEventReg_ACM2018"> | number
    EventTitle?: StringNullableFilter<"TBEventReg_ACM2018"> | string | null
    RegName?: StringNullableFilter<"TBEventReg_ACM2018"> | string | null
    RegEmail?: StringNullableFilter<"TBEventReg_ACM2018"> | string | null
    RegTel?: StringNullableFilter<"TBEventReg_ACM2018"> | string | null
    RegAddress?: StringNullableFilter<"TBEventReg_ACM2018"> | string | null
    RegAffiliate?: StringNullableFilter<"TBEventReg_ACM2018"> | string | null
    RegPreamble?: StringFilter<"TBEventReg_ACM2018"> | string
    RegQuestion?: StringFilter<"TBEventReg_ACM2018"> | string
    RegDate?: DateTimeNullableFilter<"TBEventReg_ACM2018"> | Date | string | null
    RegIP?: StringFilter<"TBEventReg_ACM2018"> | string
  }

  export type TBEventReg_ACM2018OrderByWithRelationInput = {
    ID?: SortOrder
    EventTitle?: SortOrderInput | SortOrder
    RegName?: SortOrderInput | SortOrder
    RegEmail?: SortOrderInput | SortOrder
    RegTel?: SortOrderInput | SortOrder
    RegAddress?: SortOrderInput | SortOrder
    RegAffiliate?: SortOrderInput | SortOrder
    RegPreamble?: SortOrder
    RegQuestion?: SortOrder
    RegDate?: SortOrderInput | SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ACM2018WhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: Enumerable<TBEventReg_ACM2018WhereInput>
    OR?: Enumerable<TBEventReg_ACM2018WhereInput>
    NOT?: Enumerable<TBEventReg_ACM2018WhereInput>
    EventTitle?: StringNullableFilter<"TBEventReg_ACM2018"> | string | null
    RegName?: StringNullableFilter<"TBEventReg_ACM2018"> | string | null
    RegEmail?: StringNullableFilter<"TBEventReg_ACM2018"> | string | null
    RegTel?: StringNullableFilter<"TBEventReg_ACM2018"> | string | null
    RegAddress?: StringNullableFilter<"TBEventReg_ACM2018"> | string | null
    RegAffiliate?: StringNullableFilter<"TBEventReg_ACM2018"> | string | null
    RegPreamble?: StringFilter<"TBEventReg_ACM2018"> | string
    RegQuestion?: StringFilter<"TBEventReg_ACM2018"> | string
    RegDate?: DateTimeNullableFilter<"TBEventReg_ACM2018"> | Date | string | null
    RegIP?: StringFilter<"TBEventReg_ACM2018"> | string
  }, "ID">

  export type TBEventReg_ACM2018OrderByWithAggregationInput = {
    ID?: SortOrder
    EventTitle?: SortOrderInput | SortOrder
    RegName?: SortOrderInput | SortOrder
    RegEmail?: SortOrderInput | SortOrder
    RegTel?: SortOrderInput | SortOrder
    RegAddress?: SortOrderInput | SortOrder
    RegAffiliate?: SortOrderInput | SortOrder
    RegPreamble?: SortOrder
    RegQuestion?: SortOrder
    RegDate?: SortOrderInput | SortOrder
    RegIP?: SortOrder
    _count?: TBEventReg_ACM2018CountOrderByAggregateInput
    _avg?: TBEventReg_ACM2018AvgOrderByAggregateInput
    _max?: TBEventReg_ACM2018MaxOrderByAggregateInput
    _min?: TBEventReg_ACM2018MinOrderByAggregateInput
    _sum?: TBEventReg_ACM2018SumOrderByAggregateInput
  }

  export type TBEventReg_ACM2018ScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TBEventReg_ACM2018ScalarWhereWithAggregatesInput>
    OR?: Enumerable<TBEventReg_ACM2018ScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TBEventReg_ACM2018ScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter<"TBEventReg_ACM2018"> | number
    EventTitle?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2018"> | string | null
    RegName?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2018"> | string | null
    RegEmail?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2018"> | string | null
    RegTel?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2018"> | string | null
    RegAddress?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2018"> | string | null
    RegAffiliate?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2018"> | string | null
    RegPreamble?: StringWithAggregatesFilter<"TBEventReg_ACM2018"> | string
    RegQuestion?: StringWithAggregatesFilter<"TBEventReg_ACM2018"> | string
    RegDate?: DateTimeNullableWithAggregatesFilter<"TBEventReg_ACM2018"> | Date | string | null
    RegIP?: StringWithAggregatesFilter<"TBEventReg_ACM2018"> | string
  }

  export type TBEventReg_ACM2022WhereInput = {
    AND?: Enumerable<TBEventReg_ACM2022WhereInput>
    OR?: Enumerable<TBEventReg_ACM2022WhereInput>
    NOT?: Enumerable<TBEventReg_ACM2022WhereInput>
    ID?: IntFilter<"TBEventReg_ACM2022"> | number
    EventTitle?: StringNullableFilter<"TBEventReg_ACM2022"> | string | null
    RegName?: StringNullableFilter<"TBEventReg_ACM2022"> | string | null
    RegEmail?: StringNullableFilter<"TBEventReg_ACM2022"> | string | null
    RegTel?: StringNullableFilter<"TBEventReg_ACM2022"> | string | null
    RegAddress?: StringNullableFilter<"TBEventReg_ACM2022"> | string | null
    RegAffiliate?: StringNullableFilter<"TBEventReg_ACM2022"> | string | null
    RegPreamble?: StringFilter<"TBEventReg_ACM2022"> | string
    RegQuestion?: StringFilter<"TBEventReg_ACM2022"> | string
    RegDate?: DateTimeNullableFilter<"TBEventReg_ACM2022"> | Date | string | null
    RegIP?: StringFilter<"TBEventReg_ACM2022"> | string
  }

  export type TBEventReg_ACM2022OrderByWithRelationInput = {
    ID?: SortOrder
    EventTitle?: SortOrderInput | SortOrder
    RegName?: SortOrderInput | SortOrder
    RegEmail?: SortOrderInput | SortOrder
    RegTel?: SortOrderInput | SortOrder
    RegAddress?: SortOrderInput | SortOrder
    RegAffiliate?: SortOrderInput | SortOrder
    RegPreamble?: SortOrder
    RegQuestion?: SortOrder
    RegDate?: SortOrderInput | SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ACM2022WhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: Enumerable<TBEventReg_ACM2022WhereInput>
    OR?: Enumerable<TBEventReg_ACM2022WhereInput>
    NOT?: Enumerable<TBEventReg_ACM2022WhereInput>
    EventTitle?: StringNullableFilter<"TBEventReg_ACM2022"> | string | null
    RegName?: StringNullableFilter<"TBEventReg_ACM2022"> | string | null
    RegEmail?: StringNullableFilter<"TBEventReg_ACM2022"> | string | null
    RegTel?: StringNullableFilter<"TBEventReg_ACM2022"> | string | null
    RegAddress?: StringNullableFilter<"TBEventReg_ACM2022"> | string | null
    RegAffiliate?: StringNullableFilter<"TBEventReg_ACM2022"> | string | null
    RegPreamble?: StringFilter<"TBEventReg_ACM2022"> | string
    RegQuestion?: StringFilter<"TBEventReg_ACM2022"> | string
    RegDate?: DateTimeNullableFilter<"TBEventReg_ACM2022"> | Date | string | null
    RegIP?: StringFilter<"TBEventReg_ACM2022"> | string
  }, "ID">

  export type TBEventReg_ACM2022OrderByWithAggregationInput = {
    ID?: SortOrder
    EventTitle?: SortOrderInput | SortOrder
    RegName?: SortOrderInput | SortOrder
    RegEmail?: SortOrderInput | SortOrder
    RegTel?: SortOrderInput | SortOrder
    RegAddress?: SortOrderInput | SortOrder
    RegAffiliate?: SortOrderInput | SortOrder
    RegPreamble?: SortOrder
    RegQuestion?: SortOrder
    RegDate?: SortOrderInput | SortOrder
    RegIP?: SortOrder
    _count?: TBEventReg_ACM2022CountOrderByAggregateInput
    _avg?: TBEventReg_ACM2022AvgOrderByAggregateInput
    _max?: TBEventReg_ACM2022MaxOrderByAggregateInput
    _min?: TBEventReg_ACM2022MinOrderByAggregateInput
    _sum?: TBEventReg_ACM2022SumOrderByAggregateInput
  }

  export type TBEventReg_ACM2022ScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TBEventReg_ACM2022ScalarWhereWithAggregatesInput>
    OR?: Enumerable<TBEventReg_ACM2022ScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TBEventReg_ACM2022ScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter<"TBEventReg_ACM2022"> | number
    EventTitle?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2022"> | string | null
    RegName?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2022"> | string | null
    RegEmail?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2022"> | string | null
    RegTel?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2022"> | string | null
    RegAddress?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2022"> | string | null
    RegAffiliate?: StringNullableWithAggregatesFilter<"TBEventReg_ACM2022"> | string | null
    RegPreamble?: StringWithAggregatesFilter<"TBEventReg_ACM2022"> | string
    RegQuestion?: StringWithAggregatesFilter<"TBEventReg_ACM2022"> | string
    RegDate?: DateTimeNullableWithAggregatesFilter<"TBEventReg_ACM2022"> | Date | string | null
    RegIP?: StringWithAggregatesFilter<"TBEventReg_ACM2022"> | string
  }

  export type TBEventReg_ChessChampionship2019WhereInput = {
    AND?: Enumerable<TBEventReg_ChessChampionship2019WhereInput>
    OR?: Enumerable<TBEventReg_ChessChampionship2019WhereInput>
    NOT?: Enumerable<TBEventReg_ChessChampionship2019WhereInput>
    ID?: IntFilter<"TBEventReg_ChessChampionship2019"> | number
    EventTitle?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    RegNameFirst?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    RegNameLast?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    RegDOB?: DateTimeFilter<"TBEventReg_ChessChampionship2019"> | Date | string
    RegEmail?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    RegTel?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    ParentNameFirst?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    ParentNameLast?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    ParentTel?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    ParentEmail?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    RegDate?: DateTimeFilter<"TBEventReg_ChessChampionship2019"> | Date | string
    RegIP?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
  }

  export type TBEventReg_ChessChampionship2019OrderByWithRelationInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegNameFirst?: SortOrder
    RegNameLast?: SortOrder
    RegDOB?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    ParentNameFirst?: SortOrder
    ParentNameLast?: SortOrder
    ParentTel?: SortOrder
    ParentEmail?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ChessChampionship2019WhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: Enumerable<TBEventReg_ChessChampionship2019WhereInput>
    OR?: Enumerable<TBEventReg_ChessChampionship2019WhereInput>
    NOT?: Enumerable<TBEventReg_ChessChampionship2019WhereInput>
    EventTitle?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    RegNameFirst?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    RegNameLast?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    RegDOB?: DateTimeFilter<"TBEventReg_ChessChampionship2019"> | Date | string
    RegEmail?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    RegTel?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    ParentNameFirst?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    ParentNameLast?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    ParentTel?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    ParentEmail?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
    RegDate?: DateTimeFilter<"TBEventReg_ChessChampionship2019"> | Date | string
    RegIP?: StringFilter<"TBEventReg_ChessChampionship2019"> | string
  }, "ID">

  export type TBEventReg_ChessChampionship2019OrderByWithAggregationInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegNameFirst?: SortOrder
    RegNameLast?: SortOrder
    RegDOB?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    ParentNameFirst?: SortOrder
    ParentNameLast?: SortOrder
    ParentTel?: SortOrder
    ParentEmail?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
    _count?: TBEventReg_ChessChampionship2019CountOrderByAggregateInput
    _avg?: TBEventReg_ChessChampionship2019AvgOrderByAggregateInput
    _max?: TBEventReg_ChessChampionship2019MaxOrderByAggregateInput
    _min?: TBEventReg_ChessChampionship2019MinOrderByAggregateInput
    _sum?: TBEventReg_ChessChampionship2019SumOrderByAggregateInput
  }

  export type TBEventReg_ChessChampionship2019ScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TBEventReg_ChessChampionship2019ScalarWhereWithAggregatesInput>
    OR?: Enumerable<TBEventReg_ChessChampionship2019ScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TBEventReg_ChessChampionship2019ScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter<"TBEventReg_ChessChampionship2019"> | number
    EventTitle?: StringWithAggregatesFilter<"TBEventReg_ChessChampionship2019"> | string
    RegNameFirst?: StringWithAggregatesFilter<"TBEventReg_ChessChampionship2019"> | string
    RegNameLast?: StringWithAggregatesFilter<"TBEventReg_ChessChampionship2019"> | string
    RegDOB?: DateTimeWithAggregatesFilter<"TBEventReg_ChessChampionship2019"> | Date | string
    RegEmail?: StringWithAggregatesFilter<"TBEventReg_ChessChampionship2019"> | string
    RegTel?: StringWithAggregatesFilter<"TBEventReg_ChessChampionship2019"> | string
    ParentNameFirst?: StringWithAggregatesFilter<"TBEventReg_ChessChampionship2019"> | string
    ParentNameLast?: StringWithAggregatesFilter<"TBEventReg_ChessChampionship2019"> | string
    ParentTel?: StringWithAggregatesFilter<"TBEventReg_ChessChampionship2019"> | string
    ParentEmail?: StringWithAggregatesFilter<"TBEventReg_ChessChampionship2019"> | string
    RegDate?: DateTimeWithAggregatesFilter<"TBEventReg_ChessChampionship2019"> | Date | string
    RegIP?: StringWithAggregatesFilter<"TBEventReg_ChessChampionship2019"> | string
  }

  export type TBEventReg_SEEE_2017WhereInput = {
    AND?: Enumerable<TBEventReg_SEEE_2017WhereInput>
    OR?: Enumerable<TBEventReg_SEEE_2017WhereInput>
    NOT?: Enumerable<TBEventReg_SEEE_2017WhereInput>
    ID?: IntFilter<"TBEventReg_SEEE_2017"> | number
    EventTitle?: StringFilter<"TBEventReg_SEEE_2017"> | string
    RegName?: StringFilter<"TBEventReg_SEEE_2017"> | string
    RegEmail?: StringFilter<"TBEventReg_SEEE_2017"> | string
    RegTel?: StringFilter<"TBEventReg_SEEE_2017"> | string
    RegAddress?: StringFilter<"TBEventReg_SEEE_2017"> | string
    RegDate?: DateTimeFilter<"TBEventReg_SEEE_2017"> | Date | string
    RegIP?: StringFilter<"TBEventReg_SEEE_2017"> | string
    RegLunch?: StringNullableFilter<"TBEventReg_SEEE_2017"> | string | null
  }

  export type TBEventReg_SEEE_2017OrderByWithRelationInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
    RegLunch?: SortOrderInput | SortOrder
  }

  export type TBEventReg_SEEE_2017WhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: Enumerable<TBEventReg_SEEE_2017WhereInput>
    OR?: Enumerable<TBEventReg_SEEE_2017WhereInput>
    NOT?: Enumerable<TBEventReg_SEEE_2017WhereInput>
    EventTitle?: StringFilter<"TBEventReg_SEEE_2017"> | string
    RegName?: StringFilter<"TBEventReg_SEEE_2017"> | string
    RegEmail?: StringFilter<"TBEventReg_SEEE_2017"> | string
    RegTel?: StringFilter<"TBEventReg_SEEE_2017"> | string
    RegAddress?: StringFilter<"TBEventReg_SEEE_2017"> | string
    RegDate?: DateTimeFilter<"TBEventReg_SEEE_2017"> | Date | string
    RegIP?: StringFilter<"TBEventReg_SEEE_2017"> | string
    RegLunch?: StringNullableFilter<"TBEventReg_SEEE_2017"> | string | null
  }, "ID">

  export type TBEventReg_SEEE_2017OrderByWithAggregationInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
    RegLunch?: SortOrderInput | SortOrder
    _count?: TBEventReg_SEEE_2017CountOrderByAggregateInput
    _avg?: TBEventReg_SEEE_2017AvgOrderByAggregateInput
    _max?: TBEventReg_SEEE_2017MaxOrderByAggregateInput
    _min?: TBEventReg_SEEE_2017MinOrderByAggregateInput
    _sum?: TBEventReg_SEEE_2017SumOrderByAggregateInput
  }

  export type TBEventReg_SEEE_2017ScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TBEventReg_SEEE_2017ScalarWhereWithAggregatesInput>
    OR?: Enumerable<TBEventReg_SEEE_2017ScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TBEventReg_SEEE_2017ScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter<"TBEventReg_SEEE_2017"> | number
    EventTitle?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017"> | string
    RegName?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017"> | string
    RegEmail?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017"> | string
    RegTel?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017"> | string
    RegAddress?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017"> | string
    RegDate?: DateTimeWithAggregatesFilter<"TBEventReg_SEEE_2017"> | Date | string
    RegIP?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017"> | string
    RegLunch?: StringNullableWithAggregatesFilter<"TBEventReg_SEEE_2017"> | string | null
  }

  export type TBEventReg_SEEE_2017_VenderInfoWhereInput = {
    AND?: Enumerable<TBEventReg_SEEE_2017_VenderInfoWhereInput>
    OR?: Enumerable<TBEventReg_SEEE_2017_VenderInfoWhereInput>
    NOT?: Enumerable<TBEventReg_SEEE_2017_VenderInfoWhereInput>
    ID?: IntFilter<"TBEventReg_SEEE_2017_VenderInfo"> | number
    VenderCompTitle?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    VenderResource?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    VenderEmail?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    VenderDescrip?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    VenderBooth?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    VenderTel?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AMorPM?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM1?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM2?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM3?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM4?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM5?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM6?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM1?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM2?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM3?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM4?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM5?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM6?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
  }

  export type TBEventReg_SEEE_2017_VenderInfoOrderByWithRelationInput = {
    ID?: SortOrder
    VenderCompTitle?: SortOrder
    VenderResource?: SortOrder
    VenderEmail?: SortOrder
    VenderDescrip?: SortOrder
    VenderBooth?: SortOrder
    VenderTel?: SortOrder
    AMorPM?: SortOrder
    AM1?: SortOrder
    AM2?: SortOrder
    AM3?: SortOrder
    AM4?: SortOrder
    AM5?: SortOrder
    AM6?: SortOrder
    PM1?: SortOrder
    PM2?: SortOrder
    PM3?: SortOrder
    PM4?: SortOrder
    PM5?: SortOrder
    PM6?: SortOrder
  }

  export type TBEventReg_SEEE_2017_VenderInfoWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: Enumerable<TBEventReg_SEEE_2017_VenderInfoWhereInput>
    OR?: Enumerable<TBEventReg_SEEE_2017_VenderInfoWhereInput>
    NOT?: Enumerable<TBEventReg_SEEE_2017_VenderInfoWhereInput>
    VenderCompTitle?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    VenderResource?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    VenderEmail?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    VenderDescrip?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    VenderBooth?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    VenderTel?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AMorPM?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM1?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM2?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM3?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM4?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM5?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM6?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM1?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM2?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM3?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM4?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM5?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM6?: StringFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
  }, "ID">

  export type TBEventReg_SEEE_2017_VenderInfoOrderByWithAggregationInput = {
    ID?: SortOrder
    VenderCompTitle?: SortOrder
    VenderResource?: SortOrder
    VenderEmail?: SortOrder
    VenderDescrip?: SortOrder
    VenderBooth?: SortOrder
    VenderTel?: SortOrder
    AMorPM?: SortOrder
    AM1?: SortOrder
    AM2?: SortOrder
    AM3?: SortOrder
    AM4?: SortOrder
    AM5?: SortOrder
    AM6?: SortOrder
    PM1?: SortOrder
    PM2?: SortOrder
    PM3?: SortOrder
    PM4?: SortOrder
    PM5?: SortOrder
    PM6?: SortOrder
    _count?: TBEventReg_SEEE_2017_VenderInfoCountOrderByAggregateInput
    _avg?: TBEventReg_SEEE_2017_VenderInfoAvgOrderByAggregateInput
    _max?: TBEventReg_SEEE_2017_VenderInfoMaxOrderByAggregateInput
    _min?: TBEventReg_SEEE_2017_VenderInfoMinOrderByAggregateInput
    _sum?: TBEventReg_SEEE_2017_VenderInfoSumOrderByAggregateInput
  }

  export type TBEventReg_SEEE_2017_VenderInfoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TBEventReg_SEEE_2017_VenderInfoScalarWhereWithAggregatesInput>
    OR?: Enumerable<TBEventReg_SEEE_2017_VenderInfoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TBEventReg_SEEE_2017_VenderInfoScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | number
    VenderCompTitle?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    VenderResource?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    VenderEmail?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    VenderDescrip?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    VenderBooth?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    VenderTel?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AMorPM?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM1?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM2?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM3?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM4?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM5?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    AM6?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM1?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM2?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM3?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM4?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM5?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
    PM6?: StringWithAggregatesFilter<"TBEventReg_SEEE_2017_VenderInfo"> | string
  }

  export type TBEventReg_SEEE_2018WhereInput = {
    AND?: Enumerable<TBEventReg_SEEE_2018WhereInput>
    OR?: Enumerable<TBEventReg_SEEE_2018WhereInput>
    NOT?: Enumerable<TBEventReg_SEEE_2018WhereInput>
    ID?: IntFilter<"TBEventReg_SEEE_2018"> | number
    EventTitle?: StringFilter<"TBEventReg_SEEE_2018"> | string
    RegName?: StringFilter<"TBEventReg_SEEE_2018"> | string
    RegEmail?: StringFilter<"TBEventReg_SEEE_2018"> | string
    RegTel?: StringFilter<"TBEventReg_SEEE_2018"> | string
    RegAddress?: StringFilter<"TBEventReg_SEEE_2018"> | string
    RegDate?: DateTimeFilter<"TBEventReg_SEEE_2018"> | Date | string
    RegIP?: StringFilter<"TBEventReg_SEEE_2018"> | string
    RegLunch?: StringNullableFilter<"TBEventReg_SEEE_2018"> | string | null
  }

  export type TBEventReg_SEEE_2018OrderByWithRelationInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
    RegLunch?: SortOrderInput | SortOrder
  }

  export type TBEventReg_SEEE_2018WhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: Enumerable<TBEventReg_SEEE_2018WhereInput>
    OR?: Enumerable<TBEventReg_SEEE_2018WhereInput>
    NOT?: Enumerable<TBEventReg_SEEE_2018WhereInput>
    EventTitle?: StringFilter<"TBEventReg_SEEE_2018"> | string
    RegName?: StringFilter<"TBEventReg_SEEE_2018"> | string
    RegEmail?: StringFilter<"TBEventReg_SEEE_2018"> | string
    RegTel?: StringFilter<"TBEventReg_SEEE_2018"> | string
    RegAddress?: StringFilter<"TBEventReg_SEEE_2018"> | string
    RegDate?: DateTimeFilter<"TBEventReg_SEEE_2018"> | Date | string
    RegIP?: StringFilter<"TBEventReg_SEEE_2018"> | string
    RegLunch?: StringNullableFilter<"TBEventReg_SEEE_2018"> | string | null
  }, "ID">

  export type TBEventReg_SEEE_2018OrderByWithAggregationInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
    RegLunch?: SortOrderInput | SortOrder
    _count?: TBEventReg_SEEE_2018CountOrderByAggregateInput
    _avg?: TBEventReg_SEEE_2018AvgOrderByAggregateInput
    _max?: TBEventReg_SEEE_2018MaxOrderByAggregateInput
    _min?: TBEventReg_SEEE_2018MinOrderByAggregateInput
    _sum?: TBEventReg_SEEE_2018SumOrderByAggregateInput
  }

  export type TBEventReg_SEEE_2018ScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TBEventReg_SEEE_2018ScalarWhereWithAggregatesInput>
    OR?: Enumerable<TBEventReg_SEEE_2018ScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TBEventReg_SEEE_2018ScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter<"TBEventReg_SEEE_2018"> | number
    EventTitle?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018"> | string
    RegName?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018"> | string
    RegEmail?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018"> | string
    RegTel?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018"> | string
    RegAddress?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018"> | string
    RegDate?: DateTimeWithAggregatesFilter<"TBEventReg_SEEE_2018"> | Date | string
    RegIP?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018"> | string
    RegLunch?: StringNullableWithAggregatesFilter<"TBEventReg_SEEE_2018"> | string | null
  }

  export type TBEventReg_SEEE_2018_VenderInfoWhereInput = {
    AND?: Enumerable<TBEventReg_SEEE_2018_VenderInfoWhereInput>
    OR?: Enumerable<TBEventReg_SEEE_2018_VenderInfoWhereInput>
    NOT?: Enumerable<TBEventReg_SEEE_2018_VenderInfoWhereInput>
    ID?: IntFilter<"TBEventReg_SEEE_2018_VenderInfo"> | number
    VenderCompTitle?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderContactPerson?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderResource?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderEmail?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderDescrip?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderBooth?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderTel?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot1?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot2?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot3?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot4?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot5?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot6?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot7?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot8?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot9?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot10?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
  }

  export type TBEventReg_SEEE_2018_VenderInfoOrderByWithRelationInput = {
    ID?: SortOrder
    VenderCompTitle?: SortOrder
    VenderContactPerson?: SortOrder
    VenderResource?: SortOrder
    VenderEmail?: SortOrder
    VenderDescrip?: SortOrder
    VenderBooth?: SortOrder
    VenderTel?: SortOrder
    TimeSlot1?: SortOrder
    TimeSlot2?: SortOrder
    TimeSlot3?: SortOrder
    TimeSlot4?: SortOrder
    TimeSlot5?: SortOrder
    TimeSlot6?: SortOrder
    TimeSlot7?: SortOrder
    TimeSlot8?: SortOrder
    TimeSlot9?: SortOrder
    TimeSlot10?: SortOrder
  }

  export type TBEventReg_SEEE_2018_VenderInfoWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: Enumerable<TBEventReg_SEEE_2018_VenderInfoWhereInput>
    OR?: Enumerable<TBEventReg_SEEE_2018_VenderInfoWhereInput>
    NOT?: Enumerable<TBEventReg_SEEE_2018_VenderInfoWhereInput>
    VenderCompTitle?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderContactPerson?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderResource?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderEmail?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderDescrip?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderBooth?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderTel?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot1?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot2?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot3?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot4?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot5?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot6?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot7?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot8?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot9?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot10?: StringFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
  }, "ID">

  export type TBEventReg_SEEE_2018_VenderInfoOrderByWithAggregationInput = {
    ID?: SortOrder
    VenderCompTitle?: SortOrder
    VenderContactPerson?: SortOrder
    VenderResource?: SortOrder
    VenderEmail?: SortOrder
    VenderDescrip?: SortOrder
    VenderBooth?: SortOrder
    VenderTel?: SortOrder
    TimeSlot1?: SortOrder
    TimeSlot2?: SortOrder
    TimeSlot3?: SortOrder
    TimeSlot4?: SortOrder
    TimeSlot5?: SortOrder
    TimeSlot6?: SortOrder
    TimeSlot7?: SortOrder
    TimeSlot8?: SortOrder
    TimeSlot9?: SortOrder
    TimeSlot10?: SortOrder
    _count?: TBEventReg_SEEE_2018_VenderInfoCountOrderByAggregateInput
    _avg?: TBEventReg_SEEE_2018_VenderInfoAvgOrderByAggregateInput
    _max?: TBEventReg_SEEE_2018_VenderInfoMaxOrderByAggregateInput
    _min?: TBEventReg_SEEE_2018_VenderInfoMinOrderByAggregateInput
    _sum?: TBEventReg_SEEE_2018_VenderInfoSumOrderByAggregateInput
  }

  export type TBEventReg_SEEE_2018_VenderInfoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TBEventReg_SEEE_2018_VenderInfoScalarWhereWithAggregatesInput>
    OR?: Enumerable<TBEventReg_SEEE_2018_VenderInfoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TBEventReg_SEEE_2018_VenderInfoScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | number
    VenderCompTitle?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderContactPerson?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderResource?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderEmail?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderDescrip?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderBooth?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    VenderTel?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot1?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot2?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot3?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot4?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot5?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot6?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot7?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot8?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot9?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
    TimeSlot10?: StringWithAggregatesFilter<"TBEventReg_SEEE_2018_VenderInfo"> | string
  }

  export type TBEventReg_SpringIntoActionWhereInput = {
    AND?: Enumerable<TBEventReg_SpringIntoActionWhereInput>
    OR?: Enumerable<TBEventReg_SpringIntoActionWhereInput>
    NOT?: Enumerable<TBEventReg_SpringIntoActionWhereInput>
    ID?: IntFilter<"TBEventReg_SpringIntoAction"> | number
    EventTitle?: StringNullableFilter<"TBEventReg_SpringIntoAction"> | string | null
    RegName?: StringNullableFilter<"TBEventReg_SpringIntoAction"> | string | null
    RegEmail?: StringNullableFilter<"TBEventReg_SpringIntoAction"> | string | null
    RegTel?: StringNullableFilter<"TBEventReg_SpringIntoAction"> | string | null
    RegAddress?: StringNullableFilter<"TBEventReg_SpringIntoAction"> | string | null
    RegDate?: DateTimeNullableFilter<"TBEventReg_SpringIntoAction"> | Date | string | null
    RegIP?: StringFilter<"TBEventReg_SpringIntoAction"> | string
  }

  export type TBEventReg_SpringIntoActionOrderByWithRelationInput = {
    ID?: SortOrder
    EventTitle?: SortOrderInput | SortOrder
    RegName?: SortOrderInput | SortOrder
    RegEmail?: SortOrderInput | SortOrder
    RegTel?: SortOrderInput | SortOrder
    RegAddress?: SortOrderInput | SortOrder
    RegDate?: SortOrderInput | SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_SpringIntoActionWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: Enumerable<TBEventReg_SpringIntoActionWhereInput>
    OR?: Enumerable<TBEventReg_SpringIntoActionWhereInput>
    NOT?: Enumerable<TBEventReg_SpringIntoActionWhereInput>
    EventTitle?: StringNullableFilter<"TBEventReg_SpringIntoAction"> | string | null
    RegName?: StringNullableFilter<"TBEventReg_SpringIntoAction"> | string | null
    RegEmail?: StringNullableFilter<"TBEventReg_SpringIntoAction"> | string | null
    RegTel?: StringNullableFilter<"TBEventReg_SpringIntoAction"> | string | null
    RegAddress?: StringNullableFilter<"TBEventReg_SpringIntoAction"> | string | null
    RegDate?: DateTimeNullableFilter<"TBEventReg_SpringIntoAction"> | Date | string | null
    RegIP?: StringFilter<"TBEventReg_SpringIntoAction"> | string
  }, "ID">

  export type TBEventReg_SpringIntoActionOrderByWithAggregationInput = {
    ID?: SortOrder
    EventTitle?: SortOrderInput | SortOrder
    RegName?: SortOrderInput | SortOrder
    RegEmail?: SortOrderInput | SortOrder
    RegTel?: SortOrderInput | SortOrder
    RegAddress?: SortOrderInput | SortOrder
    RegDate?: SortOrderInput | SortOrder
    RegIP?: SortOrder
    _count?: TBEventReg_SpringIntoActionCountOrderByAggregateInput
    _avg?: TBEventReg_SpringIntoActionAvgOrderByAggregateInput
    _max?: TBEventReg_SpringIntoActionMaxOrderByAggregateInput
    _min?: TBEventReg_SpringIntoActionMinOrderByAggregateInput
    _sum?: TBEventReg_SpringIntoActionSumOrderByAggregateInput
  }

  export type TBEventReg_SpringIntoActionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TBEventReg_SpringIntoActionScalarWhereWithAggregatesInput>
    OR?: Enumerable<TBEventReg_SpringIntoActionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TBEventReg_SpringIntoActionScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter<"TBEventReg_SpringIntoAction"> | number
    EventTitle?: StringNullableWithAggregatesFilter<"TBEventReg_SpringIntoAction"> | string | null
    RegName?: StringNullableWithAggregatesFilter<"TBEventReg_SpringIntoAction"> | string | null
    RegEmail?: StringNullableWithAggregatesFilter<"TBEventReg_SpringIntoAction"> | string | null
    RegTel?: StringNullableWithAggregatesFilter<"TBEventReg_SpringIntoAction"> | string | null
    RegAddress?: StringNullableWithAggregatesFilter<"TBEventReg_SpringIntoAction"> | string | null
    RegDate?: DateTimeNullableWithAggregatesFilter<"TBEventReg_SpringIntoAction"> | Date | string | null
    RegIP?: StringWithAggregatesFilter<"TBEventReg_SpringIntoAction"> | string
  }

  export type TBInvisibleIllness2019WhereInput = {
    AND?: Enumerable<TBInvisibleIllness2019WhereInput>
    OR?: Enumerable<TBInvisibleIllness2019WhereInput>
    NOT?: Enumerable<TBInvisibleIllness2019WhereInput>
    IndexID?: IntFilter<"TBInvisibleIllness2019"> | number
    RegName?: StringFilter<"TBInvisibleIllness2019"> | string
    RegEmail?: StringFilter<"TBInvisibleIllness2019"> | string
    RegTel?: StringFilter<"TBInvisibleIllness2019"> | string
    IfRCDMember?: StringFilter<"TBInvisibleIllness2019"> | string
    RegDate?: DateTimeFilter<"TBInvisibleIllness2019"> | Date | string
    RegIP?: StringFilter<"TBInvisibleIllness2019"> | string
  }

  export type TBInvisibleIllness2019OrderByWithRelationInput = {
    IndexID?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    IfRCDMember?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBInvisibleIllness2019WhereUniqueInput = Prisma.AtLeast<{
    IndexID?: number
    AND?: Enumerable<TBInvisibleIllness2019WhereInput>
    OR?: Enumerable<TBInvisibleIllness2019WhereInput>
    NOT?: Enumerable<TBInvisibleIllness2019WhereInput>
    RegName?: StringFilter<"TBInvisibleIllness2019"> | string
    RegEmail?: StringFilter<"TBInvisibleIllness2019"> | string
    RegTel?: StringFilter<"TBInvisibleIllness2019"> | string
    IfRCDMember?: StringFilter<"TBInvisibleIllness2019"> | string
    RegDate?: DateTimeFilter<"TBInvisibleIllness2019"> | Date | string
    RegIP?: StringFilter<"TBInvisibleIllness2019"> | string
  }, "IndexID">

  export type TBInvisibleIllness2019OrderByWithAggregationInput = {
    IndexID?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    IfRCDMember?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
    _count?: TBInvisibleIllness2019CountOrderByAggregateInput
    _avg?: TBInvisibleIllness2019AvgOrderByAggregateInput
    _max?: TBInvisibleIllness2019MaxOrderByAggregateInput
    _min?: TBInvisibleIllness2019MinOrderByAggregateInput
    _sum?: TBInvisibleIllness2019SumOrderByAggregateInput
  }

  export type TBInvisibleIllness2019ScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TBInvisibleIllness2019ScalarWhereWithAggregatesInput>
    OR?: Enumerable<TBInvisibleIllness2019ScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TBInvisibleIllness2019ScalarWhereWithAggregatesInput>
    IndexID?: IntWithAggregatesFilter<"TBInvisibleIllness2019"> | number
    RegName?: StringWithAggregatesFilter<"TBInvisibleIllness2019"> | string
    RegEmail?: StringWithAggregatesFilter<"TBInvisibleIllness2019"> | string
    RegTel?: StringWithAggregatesFilter<"TBInvisibleIllness2019"> | string
    IfRCDMember?: StringWithAggregatesFilter<"TBInvisibleIllness2019"> | string
    RegDate?: DateTimeWithAggregatesFilter<"TBInvisibleIllness2019"> | Date | string
    RegIP?: StringWithAggregatesFilter<"TBInvisibleIllness2019"> | string
  }

  export type TB_2017Gala_KaraokaWhereInput = {
    AND?: Enumerable<TB_2017Gala_KaraokaWhereInput>
    OR?: Enumerable<TB_2017Gala_KaraokaWhereInput>
    NOT?: Enumerable<TB_2017Gala_KaraokaWhereInput>
    ID?: IntFilter<"TB_2017Gala_Karaoka"> | number
    NominatorName?: StringFilter<"TB_2017Gala_Karaoka"> | string
    NominatorTelEmail?: StringFilter<"TB_2017Gala_Karaoka"> | string
    NomineeName?: StringFilter<"TB_2017Gala_Karaoka"> | string
    NomineeTelEmail?: StringFilter<"TB_2017Gala_Karaoka"> | string
    KaraokeName?: StringFilter<"TB_2017Gala_Karaoka"> | string
    BringCD?: StringFilter<"TB_2017Gala_Karaoka"> | string
    RegDateTime?: DateTimeFilter<"TB_2017Gala_Karaoka"> | Date | string
  }

  export type TB_2017Gala_KaraokaOrderByWithRelationInput = {
    ID?: SortOrder
    NominatorName?: SortOrder
    NominatorTelEmail?: SortOrder
    NomineeName?: SortOrder
    NomineeTelEmail?: SortOrder
    KaraokeName?: SortOrder
    BringCD?: SortOrder
    RegDateTime?: SortOrder
  }

  export type TB_2017Gala_KaraokaWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: Enumerable<TB_2017Gala_KaraokaWhereInput>
    OR?: Enumerable<TB_2017Gala_KaraokaWhereInput>
    NOT?: Enumerable<TB_2017Gala_KaraokaWhereInput>
    NominatorName?: StringFilter<"TB_2017Gala_Karaoka"> | string
    NominatorTelEmail?: StringFilter<"TB_2017Gala_Karaoka"> | string
    NomineeName?: StringFilter<"TB_2017Gala_Karaoka"> | string
    NomineeTelEmail?: StringFilter<"TB_2017Gala_Karaoka"> | string
    KaraokeName?: StringFilter<"TB_2017Gala_Karaoka"> | string
    BringCD?: StringFilter<"TB_2017Gala_Karaoka"> | string
    RegDateTime?: DateTimeFilter<"TB_2017Gala_Karaoka"> | Date | string
  }, "ID">

  export type TB_2017Gala_KaraokaOrderByWithAggregationInput = {
    ID?: SortOrder
    NominatorName?: SortOrder
    NominatorTelEmail?: SortOrder
    NomineeName?: SortOrder
    NomineeTelEmail?: SortOrder
    KaraokeName?: SortOrder
    BringCD?: SortOrder
    RegDateTime?: SortOrder
    _count?: TB_2017Gala_KaraokaCountOrderByAggregateInput
    _avg?: TB_2017Gala_KaraokaAvgOrderByAggregateInput
    _max?: TB_2017Gala_KaraokaMaxOrderByAggregateInput
    _min?: TB_2017Gala_KaraokaMinOrderByAggregateInput
    _sum?: TB_2017Gala_KaraokaSumOrderByAggregateInput
  }

  export type TB_2017Gala_KaraokaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TB_2017Gala_KaraokaScalarWhereWithAggregatesInput>
    OR?: Enumerable<TB_2017Gala_KaraokaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TB_2017Gala_KaraokaScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter<"TB_2017Gala_Karaoka"> | number
    NominatorName?: StringWithAggregatesFilter<"TB_2017Gala_Karaoka"> | string
    NominatorTelEmail?: StringWithAggregatesFilter<"TB_2017Gala_Karaoka"> | string
    NomineeName?: StringWithAggregatesFilter<"TB_2017Gala_Karaoka"> | string
    NomineeTelEmail?: StringWithAggregatesFilter<"TB_2017Gala_Karaoka"> | string
    KaraokeName?: StringWithAggregatesFilter<"TB_2017Gala_Karaoka"> | string
    BringCD?: StringWithAggregatesFilter<"TB_2017Gala_Karaoka"> | string
    RegDateTime?: DateTimeWithAggregatesFilter<"TB_2017Gala_Karaoka"> | Date | string
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023WhereInput = {
    AND?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023WhereInput>
    OR?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023WhereInput>
    NOT?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023WhereInput>
    barrage_id?: IntFilter<"Tbl_barrage_ILAcrossCanadaDay2023"> | number
    barrage_content?: StringFilter<"Tbl_barrage_ILAcrossCanadaDay2023"> | string
    createdAt?: DateTimeFilter<"Tbl_barrage_ILAcrossCanadaDay2023"> | Date | string
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023OrderByWithRelationInput = {
    barrage_id?: SortOrder
    barrage_content?: SortOrder
    createdAt?: SortOrder
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023WhereUniqueInput = Prisma.AtLeast<{
    barrage_id?: number
    AND?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023WhereInput>
    OR?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023WhereInput>
    NOT?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023WhereInput>
    barrage_content?: StringFilter<"Tbl_barrage_ILAcrossCanadaDay2023"> | string
    createdAt?: DateTimeFilter<"Tbl_barrage_ILAcrossCanadaDay2023"> | Date | string
  }, "barrage_id">

  export type Tbl_barrage_ILAcrossCanadaDay2023OrderByWithAggregationInput = {
    barrage_id?: SortOrder
    barrage_content?: SortOrder
    createdAt?: SortOrder
    _count?: Tbl_barrage_ILAcrossCanadaDay2023CountOrderByAggregateInput
    _avg?: Tbl_barrage_ILAcrossCanadaDay2023AvgOrderByAggregateInput
    _max?: Tbl_barrage_ILAcrossCanadaDay2023MaxOrderByAggregateInput
    _min?: Tbl_barrage_ILAcrossCanadaDay2023MinOrderByAggregateInput
    _sum?: Tbl_barrage_ILAcrossCanadaDay2023SumOrderByAggregateInput
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023ScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023ScalarWhereWithAggregatesInput>
    OR?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023ScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Tbl_barrage_ILAcrossCanadaDay2023ScalarWhereWithAggregatesInput>
    barrage_id?: IntWithAggregatesFilter<"Tbl_barrage_ILAcrossCanadaDay2023"> | number
    barrage_content?: StringWithAggregatesFilter<"Tbl_barrage_ILAcrossCanadaDay2023"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tbl_barrage_ILAcrossCanadaDay2023"> | Date | string
  }

  export type auth_groupWhereInput = {
    AND?: Enumerable<auth_groupWhereInput>
    OR?: Enumerable<auth_groupWhereInput>
    NOT?: Enumerable<auth_groupWhereInput>
    id?: IntFilter<"auth_group"> | number
    name?: StringFilter<"auth_group"> | string
    auth_group_permissions?: Auth_group_permissionsListRelationFilter
    auth_user_groups?: Auth_user_groupsListRelationFilter
  }

  export type auth_groupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    auth_group_permissions?: auth_group_permissionsOrderByRelationAggregateInput
    auth_user_groups?: auth_user_groupsOrderByRelationAggregateInput
  }

  export type auth_groupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: Enumerable<auth_groupWhereInput>
    OR?: Enumerable<auth_groupWhereInput>
    NOT?: Enumerable<auth_groupWhereInput>
    auth_group_permissions?: Auth_group_permissionsListRelationFilter
    auth_user_groups?: Auth_user_groupsListRelationFilter
  }, "id" | "name">

  export type auth_groupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: auth_groupCountOrderByAggregateInput
    _avg?: auth_groupAvgOrderByAggregateInput
    _max?: auth_groupMaxOrderByAggregateInput
    _min?: auth_groupMinOrderByAggregateInput
    _sum?: auth_groupSumOrderByAggregateInput
  }

  export type auth_groupScalarWhereWithAggregatesInput = {
    AND?: Enumerable<auth_groupScalarWhereWithAggregatesInput>
    OR?: Enumerable<auth_groupScalarWhereWithAggregatesInput>
    NOT?: Enumerable<auth_groupScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter<"auth_group"> | number
    name?: StringWithAggregatesFilter<"auth_group"> | string
  }

  export type auth_group_permissionsWhereInput = {
    AND?: Enumerable<auth_group_permissionsWhereInput>
    OR?: Enumerable<auth_group_permissionsWhereInput>
    NOT?: Enumerable<auth_group_permissionsWhereInput>
    id?: BigIntFilter<"auth_group_permissions"> | bigint | number
    group_id?: IntFilter<"auth_group_permissions"> | number
    permission_id?: IntFilter<"auth_group_permissions"> | number
    auth_permission?: XOR<Auth_permissionRelationFilter, auth_permissionWhereInput>
    auth_group?: XOR<Auth_groupRelationFilter, auth_groupWhereInput>
  }

  export type auth_group_permissionsOrderByWithRelationInput = {
    id?: SortOrder
    group_id?: SortOrder
    permission_id?: SortOrder
    auth_permission?: auth_permissionOrderByWithRelationInput
    auth_group?: auth_groupOrderByWithRelationInput
  }

  export type auth_group_permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    group_id_permission_id?: auth_group_permissionsGroup_idPermission_idCompoundUniqueInput
    AND?: Enumerable<auth_group_permissionsWhereInput>
    OR?: Enumerable<auth_group_permissionsWhereInput>
    NOT?: Enumerable<auth_group_permissionsWhereInput>
    group_id?: IntFilter<"auth_group_permissions"> | number
    permission_id?: IntFilter<"auth_group_permissions"> | number
    auth_permission?: XOR<Auth_permissionRelationFilter, auth_permissionWhereInput>
    auth_group?: XOR<Auth_groupRelationFilter, auth_groupWhereInput>
  }, "id" | "group_id_permission_id">

  export type auth_group_permissionsOrderByWithAggregationInput = {
    id?: SortOrder
    group_id?: SortOrder
    permission_id?: SortOrder
    _count?: auth_group_permissionsCountOrderByAggregateInput
    _avg?: auth_group_permissionsAvgOrderByAggregateInput
    _max?: auth_group_permissionsMaxOrderByAggregateInput
    _min?: auth_group_permissionsMinOrderByAggregateInput
    _sum?: auth_group_permissionsSumOrderByAggregateInput
  }

  export type auth_group_permissionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<auth_group_permissionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<auth_group_permissionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<auth_group_permissionsScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter<"auth_group_permissions"> | bigint | number
    group_id?: IntWithAggregatesFilter<"auth_group_permissions"> | number
    permission_id?: IntWithAggregatesFilter<"auth_group_permissions"> | number
  }

  export type auth_permissionWhereInput = {
    AND?: Enumerable<auth_permissionWhereInput>
    OR?: Enumerable<auth_permissionWhereInput>
    NOT?: Enumerable<auth_permissionWhereInput>
    id?: IntFilter<"auth_permission"> | number
    name?: StringFilter<"auth_permission"> | string
    content_type_id?: IntFilter<"auth_permission"> | number
    codename?: StringFilter<"auth_permission"> | string
    auth_group_permissions?: Auth_group_permissionsListRelationFilter
    django_content_type?: XOR<Django_content_typeRelationFilter, django_content_typeWhereInput>
    auth_user_user_permissions?: Auth_user_user_permissionsListRelationFilter
  }

  export type auth_permissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    content_type_id?: SortOrder
    codename?: SortOrder
    auth_group_permissions?: auth_group_permissionsOrderByRelationAggregateInput
    django_content_type?: django_content_typeOrderByWithRelationInput
    auth_user_user_permissions?: auth_user_user_permissionsOrderByRelationAggregateInput
  }

  export type auth_permissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    content_type_id_codename?: auth_permissionContent_type_idCodenameCompoundUniqueInput
    AND?: Enumerable<auth_permissionWhereInput>
    OR?: Enumerable<auth_permissionWhereInput>
    NOT?: Enumerable<auth_permissionWhereInput>
    name?: StringFilter<"auth_permission"> | string
    content_type_id?: IntFilter<"auth_permission"> | number
    codename?: StringFilter<"auth_permission"> | string
    auth_group_permissions?: Auth_group_permissionsListRelationFilter
    django_content_type?: XOR<Django_content_typeRelationFilter, django_content_typeWhereInput>
    auth_user_user_permissions?: Auth_user_user_permissionsListRelationFilter
  }, "id" | "content_type_id_codename">

  export type auth_permissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    content_type_id?: SortOrder
    codename?: SortOrder
    _count?: auth_permissionCountOrderByAggregateInput
    _avg?: auth_permissionAvgOrderByAggregateInput
    _max?: auth_permissionMaxOrderByAggregateInput
    _min?: auth_permissionMinOrderByAggregateInput
    _sum?: auth_permissionSumOrderByAggregateInput
  }

  export type auth_permissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<auth_permissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<auth_permissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<auth_permissionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter<"auth_permission"> | number
    name?: StringWithAggregatesFilter<"auth_permission"> | string
    content_type_id?: IntWithAggregatesFilter<"auth_permission"> | number
    codename?: StringWithAggregatesFilter<"auth_permission"> | string
  }

  export type auth_userWhereInput = {
    AND?: Enumerable<auth_userWhereInput>
    OR?: Enumerable<auth_userWhereInput>
    NOT?: Enumerable<auth_userWhereInput>
    id?: IntFilter<"auth_user"> | number
    password?: StringFilter<"auth_user"> | string
    last_login?: DateTimeNullableFilter<"auth_user"> | Date | string | null
    is_superuser?: BoolFilter<"auth_user"> | boolean
    username?: StringFilter<"auth_user"> | string
    first_name?: StringFilter<"auth_user"> | string
    last_name?: StringFilter<"auth_user"> | string
    email?: StringFilter<"auth_user"> | string
    is_staff?: BoolFilter<"auth_user"> | boolean
    is_active?: BoolFilter<"auth_user"> | boolean
    date_joined?: DateTimeFilter<"auth_user"> | Date | string
    auth_user_groups?: Auth_user_groupsListRelationFilter
    auth_user_user_permissions?: Auth_user_user_permissionsListRelationFilter
    django_admin_log?: Django_admin_logListRelationFilter
  }

  export type auth_userOrderByWithRelationInput = {
    id?: SortOrder
    password?: SortOrder
    last_login?: SortOrderInput | SortOrder
    is_superuser?: SortOrder
    username?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    is_staff?: SortOrder
    is_active?: SortOrder
    date_joined?: SortOrder
    auth_user_groups?: auth_user_groupsOrderByRelationAggregateInput
    auth_user_user_permissions?: auth_user_user_permissionsOrderByRelationAggregateInput
    django_admin_log?: django_admin_logOrderByRelationAggregateInput
  }

  export type auth_userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: Enumerable<auth_userWhereInput>
    OR?: Enumerable<auth_userWhereInput>
    NOT?: Enumerable<auth_userWhereInput>
    password?: StringFilter<"auth_user"> | string
    last_login?: DateTimeNullableFilter<"auth_user"> | Date | string | null
    is_superuser?: BoolFilter<"auth_user"> | boolean
    first_name?: StringFilter<"auth_user"> | string
    last_name?: StringFilter<"auth_user"> | string
    email?: StringFilter<"auth_user"> | string
    is_staff?: BoolFilter<"auth_user"> | boolean
    is_active?: BoolFilter<"auth_user"> | boolean
    date_joined?: DateTimeFilter<"auth_user"> | Date | string
    auth_user_groups?: Auth_user_groupsListRelationFilter
    auth_user_user_permissions?: Auth_user_user_permissionsListRelationFilter
    django_admin_log?: Django_admin_logListRelationFilter
  }, "id" | "username">

  export type auth_userOrderByWithAggregationInput = {
    id?: SortOrder
    password?: SortOrder
    last_login?: SortOrderInput | SortOrder
    is_superuser?: SortOrder
    username?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    is_staff?: SortOrder
    is_active?: SortOrder
    date_joined?: SortOrder
    _count?: auth_userCountOrderByAggregateInput
    _avg?: auth_userAvgOrderByAggregateInput
    _max?: auth_userMaxOrderByAggregateInput
    _min?: auth_userMinOrderByAggregateInput
    _sum?: auth_userSumOrderByAggregateInput
  }

  export type auth_userScalarWhereWithAggregatesInput = {
    AND?: Enumerable<auth_userScalarWhereWithAggregatesInput>
    OR?: Enumerable<auth_userScalarWhereWithAggregatesInput>
    NOT?: Enumerable<auth_userScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter<"auth_user"> | number
    password?: StringWithAggregatesFilter<"auth_user"> | string
    last_login?: DateTimeNullableWithAggregatesFilter<"auth_user"> | Date | string | null
    is_superuser?: BoolWithAggregatesFilter<"auth_user"> | boolean
    username?: StringWithAggregatesFilter<"auth_user"> | string
    first_name?: StringWithAggregatesFilter<"auth_user"> | string
    last_name?: StringWithAggregatesFilter<"auth_user"> | string
    email?: StringWithAggregatesFilter<"auth_user"> | string
    is_staff?: BoolWithAggregatesFilter<"auth_user"> | boolean
    is_active?: BoolWithAggregatesFilter<"auth_user"> | boolean
    date_joined?: DateTimeWithAggregatesFilter<"auth_user"> | Date | string
  }

  export type auth_user_groupsWhereInput = {
    AND?: Enumerable<auth_user_groupsWhereInput>
    OR?: Enumerable<auth_user_groupsWhereInput>
    NOT?: Enumerable<auth_user_groupsWhereInput>
    id?: BigIntFilter<"auth_user_groups"> | bigint | number
    user_id?: IntFilter<"auth_user_groups"> | number
    group_id?: IntFilter<"auth_user_groups"> | number
    auth_group?: XOR<Auth_groupRelationFilter, auth_groupWhereInput>
    auth_user?: XOR<Auth_userRelationFilter, auth_userWhereInput>
  }

  export type auth_user_groupsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    group_id?: SortOrder
    auth_group?: auth_groupOrderByWithRelationInput
    auth_user?: auth_userOrderByWithRelationInput
  }

  export type auth_user_groupsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    user_id_group_id?: auth_user_groupsUser_idGroup_idCompoundUniqueInput
    AND?: Enumerable<auth_user_groupsWhereInput>
    OR?: Enumerable<auth_user_groupsWhereInput>
    NOT?: Enumerable<auth_user_groupsWhereInput>
    user_id?: IntFilter<"auth_user_groups"> | number
    group_id?: IntFilter<"auth_user_groups"> | number
    auth_group?: XOR<Auth_groupRelationFilter, auth_groupWhereInput>
    auth_user?: XOR<Auth_userRelationFilter, auth_userWhereInput>
  }, "id" | "user_id_group_id">

  export type auth_user_groupsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    group_id?: SortOrder
    _count?: auth_user_groupsCountOrderByAggregateInput
    _avg?: auth_user_groupsAvgOrderByAggregateInput
    _max?: auth_user_groupsMaxOrderByAggregateInput
    _min?: auth_user_groupsMinOrderByAggregateInput
    _sum?: auth_user_groupsSumOrderByAggregateInput
  }

  export type auth_user_groupsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<auth_user_groupsScalarWhereWithAggregatesInput>
    OR?: Enumerable<auth_user_groupsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<auth_user_groupsScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter<"auth_user_groups"> | bigint | number
    user_id?: IntWithAggregatesFilter<"auth_user_groups"> | number
    group_id?: IntWithAggregatesFilter<"auth_user_groups"> | number
  }

  export type auth_user_user_permissionsWhereInput = {
    AND?: Enumerable<auth_user_user_permissionsWhereInput>
    OR?: Enumerable<auth_user_user_permissionsWhereInput>
    NOT?: Enumerable<auth_user_user_permissionsWhereInput>
    id?: BigIntFilter<"auth_user_user_permissions"> | bigint | number
    user_id?: IntFilter<"auth_user_user_permissions"> | number
    permission_id?: IntFilter<"auth_user_user_permissions"> | number
    auth_permission?: XOR<Auth_permissionRelationFilter, auth_permissionWhereInput>
    auth_user?: XOR<Auth_userRelationFilter, auth_userWhereInput>
  }

  export type auth_user_user_permissionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    permission_id?: SortOrder
    auth_permission?: auth_permissionOrderByWithRelationInput
    auth_user?: auth_userOrderByWithRelationInput
  }

  export type auth_user_user_permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    user_id_permission_id?: auth_user_user_permissionsUser_idPermission_idCompoundUniqueInput
    AND?: Enumerable<auth_user_user_permissionsWhereInput>
    OR?: Enumerable<auth_user_user_permissionsWhereInput>
    NOT?: Enumerable<auth_user_user_permissionsWhereInput>
    user_id?: IntFilter<"auth_user_user_permissions"> | number
    permission_id?: IntFilter<"auth_user_user_permissions"> | number
    auth_permission?: XOR<Auth_permissionRelationFilter, auth_permissionWhereInput>
    auth_user?: XOR<Auth_userRelationFilter, auth_userWhereInput>
  }, "id" | "user_id_permission_id">

  export type auth_user_user_permissionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    permission_id?: SortOrder
    _count?: auth_user_user_permissionsCountOrderByAggregateInput
    _avg?: auth_user_user_permissionsAvgOrderByAggregateInput
    _max?: auth_user_user_permissionsMaxOrderByAggregateInput
    _min?: auth_user_user_permissionsMinOrderByAggregateInput
    _sum?: auth_user_user_permissionsSumOrderByAggregateInput
  }

  export type auth_user_user_permissionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<auth_user_user_permissionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<auth_user_user_permissionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<auth_user_user_permissionsScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter<"auth_user_user_permissions"> | bigint | number
    user_id?: IntWithAggregatesFilter<"auth_user_user_permissions"> | number
    permission_id?: IntWithAggregatesFilter<"auth_user_user_permissions"> | number
  }

  export type categoryListWhereInput = {
    AND?: Enumerable<categoryListWhereInput>
    OR?: Enumerable<categoryListWhereInput>
    NOT?: Enumerable<categoryListWhereInput>
    categorytype?: StringNullableFilter<"categoryList"> | string | null
    hide?: IntNullableFilter<"categoryList"> | number | null
    categoryID?: IntFilter<"categoryList"> | number
  }

  export type categoryListOrderByWithRelationInput = {
    categorytype?: SortOrderInput | SortOrder
    hide?: SortOrderInput | SortOrder
    categoryID?: SortOrder
  }

  export type categoryListWhereUniqueInput = Prisma.AtLeast<{
    categoryID?: number
    AND?: Enumerable<categoryListWhereInput>
    OR?: Enumerable<categoryListWhereInput>
    NOT?: Enumerable<categoryListWhereInput>
    categorytype?: StringNullableFilter<"categoryList"> | string | null
    hide?: IntNullableFilter<"categoryList"> | number | null
  }, "categoryID">

  export type categoryListOrderByWithAggregationInput = {
    categorytype?: SortOrderInput | SortOrder
    hide?: SortOrderInput | SortOrder
    categoryID?: SortOrder
    _count?: categoryListCountOrderByAggregateInput
    _avg?: categoryListAvgOrderByAggregateInput
    _max?: categoryListMaxOrderByAggregateInput
    _min?: categoryListMinOrderByAggregateInput
    _sum?: categoryListSumOrderByAggregateInput
  }

  export type categoryListScalarWhereWithAggregatesInput = {
    AND?: Enumerable<categoryListScalarWhereWithAggregatesInput>
    OR?: Enumerable<categoryListScalarWhereWithAggregatesInput>
    NOT?: Enumerable<categoryListScalarWhereWithAggregatesInput>
    categorytype?: StringNullableWithAggregatesFilter<"categoryList"> | string | null
    hide?: IntNullableWithAggregatesFilter<"categoryList"> | number | null
    categoryID?: IntWithAggregatesFilter<"categoryList"> | number
  }

  export type django_admin_logWhereInput = {
    AND?: Enumerable<django_admin_logWhereInput>
    OR?: Enumerable<django_admin_logWhereInput>
    NOT?: Enumerable<django_admin_logWhereInput>
    id?: IntFilter<"django_admin_log"> | number
    action_time?: DateTimeFilter<"django_admin_log"> | Date | string
    object_id?: StringNullableFilter<"django_admin_log"> | string | null
    object_repr?: StringFilter<"django_admin_log"> | string
    action_flag?: IntFilter<"django_admin_log"> | number
    change_message?: StringFilter<"django_admin_log"> | string
    content_type_id?: IntNullableFilter<"django_admin_log"> | number | null
    user_id?: IntFilter<"django_admin_log"> | number
    django_content_type?: XOR<Django_content_typeNullableRelationFilter, django_content_typeWhereInput> | null
    auth_user?: XOR<Auth_userRelationFilter, auth_userWhereInput>
  }

  export type django_admin_logOrderByWithRelationInput = {
    id?: SortOrder
    action_time?: SortOrder
    object_id?: SortOrderInput | SortOrder
    object_repr?: SortOrder
    action_flag?: SortOrder
    change_message?: SortOrder
    content_type_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    django_content_type?: django_content_typeOrderByWithRelationInput
    auth_user?: auth_userOrderByWithRelationInput
  }

  export type django_admin_logWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Enumerable<django_admin_logWhereInput>
    OR?: Enumerable<django_admin_logWhereInput>
    NOT?: Enumerable<django_admin_logWhereInput>
    action_time?: DateTimeFilter<"django_admin_log"> | Date | string
    object_id?: StringNullableFilter<"django_admin_log"> | string | null
    object_repr?: StringFilter<"django_admin_log"> | string
    action_flag?: IntFilter<"django_admin_log"> | number
    change_message?: StringFilter<"django_admin_log"> | string
    content_type_id?: IntNullableFilter<"django_admin_log"> | number | null
    user_id?: IntFilter<"django_admin_log"> | number
    django_content_type?: XOR<Django_content_typeNullableRelationFilter, django_content_typeWhereInput> | null
    auth_user?: XOR<Auth_userRelationFilter, auth_userWhereInput>
  }, "id">

  export type django_admin_logOrderByWithAggregationInput = {
    id?: SortOrder
    action_time?: SortOrder
    object_id?: SortOrderInput | SortOrder
    object_repr?: SortOrder
    action_flag?: SortOrder
    change_message?: SortOrder
    content_type_id?: SortOrderInput | SortOrder
    user_id?: SortOrder
    _count?: django_admin_logCountOrderByAggregateInput
    _avg?: django_admin_logAvgOrderByAggregateInput
    _max?: django_admin_logMaxOrderByAggregateInput
    _min?: django_admin_logMinOrderByAggregateInput
    _sum?: django_admin_logSumOrderByAggregateInput
  }

  export type django_admin_logScalarWhereWithAggregatesInput = {
    AND?: Enumerable<django_admin_logScalarWhereWithAggregatesInput>
    OR?: Enumerable<django_admin_logScalarWhereWithAggregatesInput>
    NOT?: Enumerable<django_admin_logScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter<"django_admin_log"> | number
    action_time?: DateTimeWithAggregatesFilter<"django_admin_log"> | Date | string
    object_id?: StringNullableWithAggregatesFilter<"django_admin_log"> | string | null
    object_repr?: StringWithAggregatesFilter<"django_admin_log"> | string
    action_flag?: IntWithAggregatesFilter<"django_admin_log"> | number
    change_message?: StringWithAggregatesFilter<"django_admin_log"> | string
    content_type_id?: IntNullableWithAggregatesFilter<"django_admin_log"> | number | null
    user_id?: IntWithAggregatesFilter<"django_admin_log"> | number
  }

  export type django_content_typeWhereInput = {
    AND?: Enumerable<django_content_typeWhereInput>
    OR?: Enumerable<django_content_typeWhereInput>
    NOT?: Enumerable<django_content_typeWhereInput>
    id?: IntFilter<"django_content_type"> | number
    app_label?: StringFilter<"django_content_type"> | string
    model?: StringFilter<"django_content_type"> | string
    auth_permission?: Auth_permissionListRelationFilter
    django_admin_log?: Django_admin_logListRelationFilter
  }

  export type django_content_typeOrderByWithRelationInput = {
    id?: SortOrder
    app_label?: SortOrder
    model?: SortOrder
    auth_permission?: auth_permissionOrderByRelationAggregateInput
    django_admin_log?: django_admin_logOrderByRelationAggregateInput
  }

  export type django_content_typeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    app_label_model?: django_content_typeApp_labelModelCompoundUniqueInput
    AND?: Enumerable<django_content_typeWhereInput>
    OR?: Enumerable<django_content_typeWhereInput>
    NOT?: Enumerable<django_content_typeWhereInput>
    app_label?: StringFilter<"django_content_type"> | string
    model?: StringFilter<"django_content_type"> | string
    auth_permission?: Auth_permissionListRelationFilter
    django_admin_log?: Django_admin_logListRelationFilter
  }, "id" | "app_label_model">

  export type django_content_typeOrderByWithAggregationInput = {
    id?: SortOrder
    app_label?: SortOrder
    model?: SortOrder
    _count?: django_content_typeCountOrderByAggregateInput
    _avg?: django_content_typeAvgOrderByAggregateInput
    _max?: django_content_typeMaxOrderByAggregateInput
    _min?: django_content_typeMinOrderByAggregateInput
    _sum?: django_content_typeSumOrderByAggregateInput
  }

  export type django_content_typeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<django_content_typeScalarWhereWithAggregatesInput>
    OR?: Enumerable<django_content_typeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<django_content_typeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter<"django_content_type"> | number
    app_label?: StringWithAggregatesFilter<"django_content_type"> | string
    model?: StringWithAggregatesFilter<"django_content_type"> | string
  }

  export type django_migrationsWhereInput = {
    AND?: Enumerable<django_migrationsWhereInput>
    OR?: Enumerable<django_migrationsWhereInput>
    NOT?: Enumerable<django_migrationsWhereInput>
    id?: BigIntFilter<"django_migrations"> | bigint | number
    app?: StringFilter<"django_migrations"> | string
    name?: StringFilter<"django_migrations"> | string
    applied?: DateTimeFilter<"django_migrations"> | Date | string
  }

  export type django_migrationsOrderByWithRelationInput = {
    id?: SortOrder
    app?: SortOrder
    name?: SortOrder
    applied?: SortOrder
  }

  export type django_migrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: Enumerable<django_migrationsWhereInput>
    OR?: Enumerable<django_migrationsWhereInput>
    NOT?: Enumerable<django_migrationsWhereInput>
    app?: StringFilter<"django_migrations"> | string
    name?: StringFilter<"django_migrations"> | string
    applied?: DateTimeFilter<"django_migrations"> | Date | string
  }, "id">

  export type django_migrationsOrderByWithAggregationInput = {
    id?: SortOrder
    app?: SortOrder
    name?: SortOrder
    applied?: SortOrder
    _count?: django_migrationsCountOrderByAggregateInput
    _avg?: django_migrationsAvgOrderByAggregateInput
    _max?: django_migrationsMaxOrderByAggregateInput
    _min?: django_migrationsMinOrderByAggregateInput
    _sum?: django_migrationsSumOrderByAggregateInput
  }

  export type django_migrationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<django_migrationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<django_migrationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<django_migrationsScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter<"django_migrations"> | bigint | number
    app?: StringWithAggregatesFilter<"django_migrations"> | string
    name?: StringWithAggregatesFilter<"django_migrations"> | string
    applied?: DateTimeWithAggregatesFilter<"django_migrations"> | Date | string
  }

  export type django_sessionWhereInput = {
    AND?: Enumerable<django_sessionWhereInput>
    OR?: Enumerable<django_sessionWhereInput>
    NOT?: Enumerable<django_sessionWhereInput>
    session_key?: StringFilter<"django_session"> | string
    session_data?: StringFilter<"django_session"> | string
    expire_date?: DateTimeFilter<"django_session"> | Date | string
  }

  export type django_sessionOrderByWithRelationInput = {
    session_key?: SortOrder
    session_data?: SortOrder
    expire_date?: SortOrder
  }

  export type django_sessionWhereUniqueInput = Prisma.AtLeast<{
    session_key?: string
    AND?: Enumerable<django_sessionWhereInput>
    OR?: Enumerable<django_sessionWhereInput>
    NOT?: Enumerable<django_sessionWhereInput>
    session_data?: StringFilter<"django_session"> | string
    expire_date?: DateTimeFilter<"django_session"> | Date | string
  }, "session_key">

  export type django_sessionOrderByWithAggregationInput = {
    session_key?: SortOrder
    session_data?: SortOrder
    expire_date?: SortOrder
    _count?: django_sessionCountOrderByAggregateInput
    _max?: django_sessionMaxOrderByAggregateInput
    _min?: django_sessionMinOrderByAggregateInput
  }

  export type django_sessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<django_sessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<django_sessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<django_sessionScalarWhereWithAggregatesInput>
    session_key?: StringWithAggregatesFilter<"django_session"> | string
    session_data?: StringWithAggregatesFilter<"django_session"> | string
    expire_date?: DateTimeWithAggregatesFilter<"django_session"> | Date | string
  }

  export type eventsWhereInput = {
    AND?: Enumerable<eventsWhereInput>
    OR?: Enumerable<eventsWhereInput>
    NOT?: Enumerable<eventsWhereInput>
    id?: IntFilter<"events"> | number
    title?: StringFilter<"events"> | string
    color?: StringNullableFilter<"events"> | string | null
    start?: DateTimeFilter<"events"> | Date | string
    end?: DateTimeNullableFilter<"events"> | Date | string | null
  }

  export type eventsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    color?: SortOrderInput | SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
  }

  export type eventsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Enumerable<eventsWhereInput>
    OR?: Enumerable<eventsWhereInput>
    NOT?: Enumerable<eventsWhereInput>
    title?: StringFilter<"events"> | string
    color?: StringNullableFilter<"events"> | string | null
    start?: DateTimeFilter<"events"> | Date | string
    end?: DateTimeNullableFilter<"events"> | Date | string | null
  }, "id">

  export type eventsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    color?: SortOrderInput | SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
    _count?: eventsCountOrderByAggregateInput
    _avg?: eventsAvgOrderByAggregateInput
    _max?: eventsMaxOrderByAggregateInput
    _min?: eventsMinOrderByAggregateInput
    _sum?: eventsSumOrderByAggregateInput
  }

  export type eventsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<eventsScalarWhereWithAggregatesInput>
    OR?: Enumerable<eventsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<eventsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter<"events"> | number
    title?: StringWithAggregatesFilter<"events"> | string
    color?: StringNullableWithAggregatesFilter<"events"> | string | null
    start?: DateTimeWithAggregatesFilter<"events"> | Date | string
    end?: DateTimeNullableWithAggregatesFilter<"events"> | Date | string | null
  }

  export type recordInfoWhereInput = {
    AND?: Enumerable<recordInfoWhereInput>
    OR?: Enumerable<recordInfoWhereInput>
    NOT?: Enumerable<recordInfoWhereInput>
    recordInfo_ID?: IntFilter<"recordInfo"> | number
    categoryID?: IntNullableFilter<"recordInfo"> | number | null
    Name?: StringNullableFilter<"recordInfo"> | string | null
    StreetAddress?: StringNullableFilter<"recordInfo"> | string | null
    City?: StringNullableFilter<"recordInfo"> | string | null
    PostalCode?: StringNullableFilter<"recordInfo"> | string | null
    Province?: StringNullableFilter<"recordInfo"> | string | null
    Telephone?: StringNullableFilter<"recordInfo"> | string | null
    Fax?: StringNullableFilter<"recordInfo"> | string | null
    Website?: StringNullableFilter<"recordInfo"> | string | null
  }

  export type recordInfoOrderByWithRelationInput = {
    recordInfo_ID?: SortOrder
    categoryID?: SortOrderInput | SortOrder
    Name?: SortOrderInput | SortOrder
    StreetAddress?: SortOrderInput | SortOrder
    City?: SortOrderInput | SortOrder
    PostalCode?: SortOrderInput | SortOrder
    Province?: SortOrderInput | SortOrder
    Telephone?: SortOrderInput | SortOrder
    Fax?: SortOrderInput | SortOrder
    Website?: SortOrderInput | SortOrder
  }

  export type recordInfoWhereUniqueInput = Prisma.AtLeast<{
    recordInfo_ID?: number
    AND?: Enumerable<recordInfoWhereInput>
    OR?: Enumerable<recordInfoWhereInput>
    NOT?: Enumerable<recordInfoWhereInput>
    categoryID?: IntNullableFilter<"recordInfo"> | number | null
    Name?: StringNullableFilter<"recordInfo"> | string | null
    StreetAddress?: StringNullableFilter<"recordInfo"> | string | null
    City?: StringNullableFilter<"recordInfo"> | string | null
    PostalCode?: StringNullableFilter<"recordInfo"> | string | null
    Province?: StringNullableFilter<"recordInfo"> | string | null
    Telephone?: StringNullableFilter<"recordInfo"> | string | null
    Fax?: StringNullableFilter<"recordInfo"> | string | null
    Website?: StringNullableFilter<"recordInfo"> | string | null
  }, "recordInfo_ID">

  export type recordInfoOrderByWithAggregationInput = {
    recordInfo_ID?: SortOrder
    categoryID?: SortOrderInput | SortOrder
    Name?: SortOrderInput | SortOrder
    StreetAddress?: SortOrderInput | SortOrder
    City?: SortOrderInput | SortOrder
    PostalCode?: SortOrderInput | SortOrder
    Province?: SortOrderInput | SortOrder
    Telephone?: SortOrderInput | SortOrder
    Fax?: SortOrderInput | SortOrder
    Website?: SortOrderInput | SortOrder
    _count?: recordInfoCountOrderByAggregateInput
    _avg?: recordInfoAvgOrderByAggregateInput
    _max?: recordInfoMaxOrderByAggregateInput
    _min?: recordInfoMinOrderByAggregateInput
    _sum?: recordInfoSumOrderByAggregateInput
  }

  export type recordInfoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<recordInfoScalarWhereWithAggregatesInput>
    OR?: Enumerable<recordInfoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<recordInfoScalarWhereWithAggregatesInput>
    recordInfo_ID?: IntWithAggregatesFilter<"recordInfo"> | number
    categoryID?: IntNullableWithAggregatesFilter<"recordInfo"> | number | null
    Name?: StringNullableWithAggregatesFilter<"recordInfo"> | string | null
    StreetAddress?: StringNullableWithAggregatesFilter<"recordInfo"> | string | null
    City?: StringNullableWithAggregatesFilter<"recordInfo"> | string | null
    PostalCode?: StringNullableWithAggregatesFilter<"recordInfo"> | string | null
    Province?: StringNullableWithAggregatesFilter<"recordInfo"> | string | null
    Telephone?: StringNullableWithAggregatesFilter<"recordInfo"> | string | null
    Fax?: StringNullableWithAggregatesFilter<"recordInfo"> | string | null
    Website?: StringNullableWithAggregatesFilter<"recordInfo"> | string | null
  }

  export type tbl_BMORun2024_BarrageWhereInput = {
    AND?: Enumerable<tbl_BMORun2024_BarrageWhereInput>
    OR?: Enumerable<tbl_BMORun2024_BarrageWhereInput>
    NOT?: Enumerable<tbl_BMORun2024_BarrageWhereInput>
    ID?: IntFilter<"tbl_BMORun2024_Barrage"> | number
    donor_Fname?: StringNullableFilter<"tbl_BMORun2024_Barrage"> | string | null
    donor_Lname?: StringNullableFilter<"tbl_BMORun2024_Barrage"> | string | null
    donor_Org?: StringNullableFilter<"tbl_BMORun2024_Barrage"> | string | null
    donor_Amount?: DecimalNullableFilter<"tbl_BMORun2024_Barrage"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: StringFilter<"tbl_BMORun2024_Barrage"> | string
  }

  export type tbl_BMORun2024_BarrageOrderByWithRelationInput = {
    ID?: SortOrder
    donor_Fname?: SortOrderInput | SortOrder
    donor_Lname?: SortOrderInput | SortOrder
    donor_Org?: SortOrderInput | SortOrder
    donor_Amount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type tbl_BMORun2024_BarrageWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: Enumerable<tbl_BMORun2024_BarrageWhereInput>
    OR?: Enumerable<tbl_BMORun2024_BarrageWhereInput>
    NOT?: Enumerable<tbl_BMORun2024_BarrageWhereInput>
    donor_Fname?: StringNullableFilter<"tbl_BMORun2024_Barrage"> | string | null
    donor_Lname?: StringNullableFilter<"tbl_BMORun2024_Barrage"> | string | null
    donor_Org?: StringNullableFilter<"tbl_BMORun2024_Barrage"> | string | null
    donor_Amount?: DecimalNullableFilter<"tbl_BMORun2024_Barrage"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: StringFilter<"tbl_BMORun2024_Barrage"> | string
  }, "ID">

  export type tbl_BMORun2024_BarrageOrderByWithAggregationInput = {
    ID?: SortOrder
    donor_Fname?: SortOrderInput | SortOrder
    donor_Lname?: SortOrderInput | SortOrder
    donor_Org?: SortOrderInput | SortOrder
    donor_Amount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: tbl_BMORun2024_BarrageCountOrderByAggregateInput
    _avg?: tbl_BMORun2024_BarrageAvgOrderByAggregateInput
    _max?: tbl_BMORun2024_BarrageMaxOrderByAggregateInput
    _min?: tbl_BMORun2024_BarrageMinOrderByAggregateInput
    _sum?: tbl_BMORun2024_BarrageSumOrderByAggregateInput
  }

  export type tbl_BMORun2024_BarrageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tbl_BMORun2024_BarrageScalarWhereWithAggregatesInput>
    OR?: Enumerable<tbl_BMORun2024_BarrageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tbl_BMORun2024_BarrageScalarWhereWithAggregatesInput>
    ID?: IntWithAggregatesFilter<"tbl_BMORun2024_Barrage"> | number
    donor_Fname?: StringNullableWithAggregatesFilter<"tbl_BMORun2024_Barrage"> | string | null
    donor_Lname?: StringNullableWithAggregatesFilter<"tbl_BMORun2024_Barrage"> | string | null
    donor_Org?: StringNullableWithAggregatesFilter<"tbl_BMORun2024_Barrage"> | string | null
    donor_Amount?: DecimalNullableWithAggregatesFilter<"tbl_BMORun2024_Barrage"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: StringWithAggregatesFilter<"tbl_BMORun2024_Barrage"> | string
  }

  export type tbl_ETransferInfoWhereInput = {
    AND?: Enumerable<tbl_ETransferInfoWhereInput>
    OR?: Enumerable<tbl_ETransferInfoWhereInput>
    NOT?: Enumerable<tbl_ETransferInfoWhereInput>
    id?: IntFilter<"tbl_ETransferInfo"> | number
    fname?: StringFilter<"tbl_ETransferInfo"> | string
    lname?: StringFilter<"tbl_ETransferInfo"> | string
    userAddress?: StringFilter<"tbl_ETransferInfo"> | string
    userTel?: StringFilter<"tbl_ETransferInfo"> | string
    useremail?: StringFilter<"tbl_ETransferInfo"> | string
    todaydate?: DateTimeFilter<"tbl_ETransferInfo"> | Date | string
    RegDate?: DateTimeFilter<"tbl_ETransferInfo"> | Date | string
    RegTime?: DateTimeFilter<"tbl_ETransferInfo"> | Date | string
    userIP?: StringFilter<"tbl_ETransferInfo"> | string
  }

  export type tbl_ETransferInfoOrderByWithRelationInput = {
    id?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    userAddress?: SortOrder
    userTel?: SortOrder
    useremail?: SortOrder
    todaydate?: SortOrder
    RegDate?: SortOrder
    RegTime?: SortOrder
    userIP?: SortOrder
  }

  export type tbl_ETransferInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Enumerable<tbl_ETransferInfoWhereInput>
    OR?: Enumerable<tbl_ETransferInfoWhereInput>
    NOT?: Enumerable<tbl_ETransferInfoWhereInput>
    fname?: StringFilter<"tbl_ETransferInfo"> | string
    lname?: StringFilter<"tbl_ETransferInfo"> | string
    userAddress?: StringFilter<"tbl_ETransferInfo"> | string
    userTel?: StringFilter<"tbl_ETransferInfo"> | string
    useremail?: StringFilter<"tbl_ETransferInfo"> | string
    todaydate?: DateTimeFilter<"tbl_ETransferInfo"> | Date | string
    RegDate?: DateTimeFilter<"tbl_ETransferInfo"> | Date | string
    RegTime?: DateTimeFilter<"tbl_ETransferInfo"> | Date | string
    userIP?: StringFilter<"tbl_ETransferInfo"> | string
  }, "id">

  export type tbl_ETransferInfoOrderByWithAggregationInput = {
    id?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    userAddress?: SortOrder
    userTel?: SortOrder
    useremail?: SortOrder
    todaydate?: SortOrder
    RegDate?: SortOrder
    RegTime?: SortOrder
    userIP?: SortOrder
    _count?: tbl_ETransferInfoCountOrderByAggregateInput
    _avg?: tbl_ETransferInfoAvgOrderByAggregateInput
    _max?: tbl_ETransferInfoMaxOrderByAggregateInput
    _min?: tbl_ETransferInfoMinOrderByAggregateInput
    _sum?: tbl_ETransferInfoSumOrderByAggregateInput
  }

  export type tbl_ETransferInfoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tbl_ETransferInfoScalarWhereWithAggregatesInput>
    OR?: Enumerable<tbl_ETransferInfoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tbl_ETransferInfoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter<"tbl_ETransferInfo"> | number
    fname?: StringWithAggregatesFilter<"tbl_ETransferInfo"> | string
    lname?: StringWithAggregatesFilter<"tbl_ETransferInfo"> | string
    userAddress?: StringWithAggregatesFilter<"tbl_ETransferInfo"> | string
    userTel?: StringWithAggregatesFilter<"tbl_ETransferInfo"> | string
    useremail?: StringWithAggregatesFilter<"tbl_ETransferInfo"> | string
    todaydate?: DateTimeWithAggregatesFilter<"tbl_ETransferInfo"> | Date | string
    RegDate?: DateTimeWithAggregatesFilter<"tbl_ETransferInfo"> | Date | string
    RegTime?: DateTimeWithAggregatesFilter<"tbl_ETransferInfo"> | Date | string
    userIP?: StringWithAggregatesFilter<"tbl_ETransferInfo"> | string
  }

  export type tbl_TshirtContestWhereInput = {
    AND?: Enumerable<tbl_TshirtContestWhereInput>
    OR?: Enumerable<tbl_TshirtContestWhereInput>
    NOT?: Enumerable<tbl_TshirtContestWhereInput>
    id?: IntFilter<"tbl_TshirtContest"> | number
    fname?: StringFilter<"tbl_TshirtContest"> | string
    lname?: StringFilter<"tbl_TshirtContest"> | string
    tel?: StringFilter<"tbl_TshirtContest"> | string
    email?: StringFilter<"tbl_TshirtContest"> | string
    notes?: StringFilter<"tbl_TshirtContest"> | string
    artwork?: StringFilter<"tbl_TshirtContest"> | string
    imgPreview?: StringFilter<"tbl_TshirtContest"> | string
    ip?: StringFilter<"tbl_TshirtContest"> | string
    submitTime?: DateTimeFilter<"tbl_TshirtContest"> | Date | string
  }

  export type tbl_TshirtContestOrderByWithRelationInput = {
    id?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    tel?: SortOrder
    email?: SortOrder
    notes?: SortOrder
    artwork?: SortOrder
    imgPreview?: SortOrder
    ip?: SortOrder
    submitTime?: SortOrder
  }

  export type tbl_TshirtContestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Enumerable<tbl_TshirtContestWhereInput>
    OR?: Enumerable<tbl_TshirtContestWhereInput>
    NOT?: Enumerable<tbl_TshirtContestWhereInput>
    fname?: StringFilter<"tbl_TshirtContest"> | string
    lname?: StringFilter<"tbl_TshirtContest"> | string
    tel?: StringFilter<"tbl_TshirtContest"> | string
    email?: StringFilter<"tbl_TshirtContest"> | string
    notes?: StringFilter<"tbl_TshirtContest"> | string
    artwork?: StringFilter<"tbl_TshirtContest"> | string
    imgPreview?: StringFilter<"tbl_TshirtContest"> | string
    ip?: StringFilter<"tbl_TshirtContest"> | string
    submitTime?: DateTimeFilter<"tbl_TshirtContest"> | Date | string
  }, "id">

  export type tbl_TshirtContestOrderByWithAggregationInput = {
    id?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    tel?: SortOrder
    email?: SortOrder
    notes?: SortOrder
    artwork?: SortOrder
    imgPreview?: SortOrder
    ip?: SortOrder
    submitTime?: SortOrder
    _count?: tbl_TshirtContestCountOrderByAggregateInput
    _avg?: tbl_TshirtContestAvgOrderByAggregateInput
    _max?: tbl_TshirtContestMaxOrderByAggregateInput
    _min?: tbl_TshirtContestMinOrderByAggregateInput
    _sum?: tbl_TshirtContestSumOrderByAggregateInput
  }

  export type tbl_TshirtContestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tbl_TshirtContestScalarWhereWithAggregatesInput>
    OR?: Enumerable<tbl_TshirtContestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tbl_TshirtContestScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter<"tbl_TshirtContest"> | number
    fname?: StringWithAggregatesFilter<"tbl_TshirtContest"> | string
    lname?: StringWithAggregatesFilter<"tbl_TshirtContest"> | string
    tel?: StringWithAggregatesFilter<"tbl_TshirtContest"> | string
    email?: StringWithAggregatesFilter<"tbl_TshirtContest"> | string
    notes?: StringWithAggregatesFilter<"tbl_TshirtContest"> | string
    artwork?: StringWithAggregatesFilter<"tbl_TshirtContest"> | string
    imgPreview?: StringWithAggregatesFilter<"tbl_TshirtContest"> | string
    ip?: StringWithAggregatesFilter<"tbl_TshirtContest"> | string
    submitTime?: DateTimeWithAggregatesFilter<"tbl_TshirtContest"> | Date | string
  }

  export type tbl_barrage_at_us_2023WhereInput = {
    AND?: Enumerable<tbl_barrage_at_us_2023WhereInput>
    OR?: Enumerable<tbl_barrage_at_us_2023WhereInput>
    NOT?: Enumerable<tbl_barrage_at_us_2023WhereInput>
    id?: IntFilter<"tbl_barrage_at_us_2023"> | number
    barrageContent?: StringFilter<"tbl_barrage_at_us_2023"> | string
  }

  export type tbl_barrage_at_us_2023OrderByWithRelationInput = {
    id?: SortOrder
    barrageContent?: SortOrder
  }

  export type tbl_barrage_at_us_2023WhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Enumerable<tbl_barrage_at_us_2023WhereInput>
    OR?: Enumerable<tbl_barrage_at_us_2023WhereInput>
    NOT?: Enumerable<tbl_barrage_at_us_2023WhereInput>
    barrageContent?: StringFilter<"tbl_barrage_at_us_2023"> | string
  }, "id">

  export type tbl_barrage_at_us_2023OrderByWithAggregationInput = {
    id?: SortOrder
    barrageContent?: SortOrder
    _count?: tbl_barrage_at_us_2023CountOrderByAggregateInput
    _avg?: tbl_barrage_at_us_2023AvgOrderByAggregateInput
    _max?: tbl_barrage_at_us_2023MaxOrderByAggregateInput
    _min?: tbl_barrage_at_us_2023MinOrderByAggregateInput
    _sum?: tbl_barrage_at_us_2023SumOrderByAggregateInput
  }

  export type tbl_barrage_at_us_2023ScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tbl_barrage_at_us_2023ScalarWhereWithAggregatesInput>
    OR?: Enumerable<tbl_barrage_at_us_2023ScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tbl_barrage_at_us_2023ScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter<"tbl_barrage_at_us_2023"> | number
    barrageContent?: StringWithAggregatesFilter<"tbl_barrage_at_us_2023"> | string
  }

  export type tbl_next_authWhereInput = {
    AND?: Enumerable<tbl_next_authWhereInput>
    OR?: Enumerable<tbl_next_authWhereInput>
    NOT?: Enumerable<tbl_next_authWhereInput>
    id?: IntFilter<"tbl_next_auth"> | number
    username?: StringFilter<"tbl_next_auth"> | string
    password?: StringFilter<"tbl_next_auth"> | string
    email?: StringFilter<"tbl_next_auth"> | string
    isVerified?: BoolFilter<"tbl_next_auth"> | boolean
    isAdmin?: BoolFilter<"tbl_next_auth"> | boolean
  }

  export type tbl_next_authOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    isVerified?: SortOrder
    isAdmin?: SortOrder
  }

  export type tbl_next_authWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Enumerable<tbl_next_authWhereInput>
    OR?: Enumerable<tbl_next_authWhereInput>
    NOT?: Enumerable<tbl_next_authWhereInput>
    username?: StringFilter<"tbl_next_auth"> | string
    password?: StringFilter<"tbl_next_auth"> | string
    email?: StringFilter<"tbl_next_auth"> | string
    isVerified?: BoolFilter<"tbl_next_auth"> | boolean
    isAdmin?: BoolFilter<"tbl_next_auth"> | boolean
  }, "id">

  export type tbl_next_authOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    isVerified?: SortOrder
    isAdmin?: SortOrder
    _count?: tbl_next_authCountOrderByAggregateInput
    _avg?: tbl_next_authAvgOrderByAggregateInput
    _max?: tbl_next_authMaxOrderByAggregateInput
    _min?: tbl_next_authMinOrderByAggregateInput
    _sum?: tbl_next_authSumOrderByAggregateInput
  }

  export type tbl_next_authScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tbl_next_authScalarWhereWithAggregatesInput>
    OR?: Enumerable<tbl_next_authScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tbl_next_authScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter<"tbl_next_auth"> | number
    username?: StringWithAggregatesFilter<"tbl_next_auth"> | string
    password?: StringWithAggregatesFilter<"tbl_next_auth"> | string
    email?: StringWithAggregatesFilter<"tbl_next_auth"> | string
    isVerified?: BoolWithAggregatesFilter<"tbl_next_auth"> | boolean
    isAdmin?: BoolWithAggregatesFilter<"tbl_next_auth"> | boolean
  }

  export type tbl_onlineconcert2022_donorsWhereInput = {
    AND?: Enumerable<tbl_onlineconcert2022_donorsWhereInput>
    OR?: Enumerable<tbl_onlineconcert2022_donorsWhereInput>
    NOT?: Enumerable<tbl_onlineconcert2022_donorsWhereInput>
    donor_id?: IntFilter<"tbl_onlineconcert2022_donors"> | number
    donor_fname?: StringFilter<"tbl_onlineconcert2022_donors"> | string
    donor_lname?: StringFilter<"tbl_onlineconcert2022_donors"> | string
    donor_amount?: IntFilter<"tbl_onlineconcert2022_donors"> | number
  }

  export type tbl_onlineconcert2022_donorsOrderByWithRelationInput = {
    donor_id?: SortOrder
    donor_fname?: SortOrder
    donor_lname?: SortOrder
    donor_amount?: SortOrder
  }

  export type tbl_onlineconcert2022_donorsWhereUniqueInput = Prisma.AtLeast<{
    donor_id?: number
    AND?: Enumerable<tbl_onlineconcert2022_donorsWhereInput>
    OR?: Enumerable<tbl_onlineconcert2022_donorsWhereInput>
    NOT?: Enumerable<tbl_onlineconcert2022_donorsWhereInput>
    donor_fname?: StringFilter<"tbl_onlineconcert2022_donors"> | string
    donor_lname?: StringFilter<"tbl_onlineconcert2022_donors"> | string
    donor_amount?: IntFilter<"tbl_onlineconcert2022_donors"> | number
  }, "donor_id">

  export type tbl_onlineconcert2022_donorsOrderByWithAggregationInput = {
    donor_id?: SortOrder
    donor_fname?: SortOrder
    donor_lname?: SortOrder
    donor_amount?: SortOrder
    _count?: tbl_onlineconcert2022_donorsCountOrderByAggregateInput
    _avg?: tbl_onlineconcert2022_donorsAvgOrderByAggregateInput
    _max?: tbl_onlineconcert2022_donorsMaxOrderByAggregateInput
    _min?: tbl_onlineconcert2022_donorsMinOrderByAggregateInput
    _sum?: tbl_onlineconcert2022_donorsSumOrderByAggregateInput
  }

  export type tbl_onlineconcert2022_donorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tbl_onlineconcert2022_donorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<tbl_onlineconcert2022_donorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tbl_onlineconcert2022_donorsScalarWhereWithAggregatesInput>
    donor_id?: IntWithAggregatesFilter<"tbl_onlineconcert2022_donors"> | number
    donor_fname?: StringWithAggregatesFilter<"tbl_onlineconcert2022_donors"> | string
    donor_lname?: StringWithAggregatesFilter<"tbl_onlineconcert2022_donors"> | string
    donor_amount?: IntWithAggregatesFilter<"tbl_onlineconcert2022_donors"> | number
  }

  export type usersWhereInput = {
    AND?: Enumerable<usersWhereInput>
    OR?: Enumerable<usersWhereInput>
    NOT?: Enumerable<usersWhereInput>
    Username?: StringFilter<"users"> | string
    Password?: StringFilter<"users"> | string
    id?: IntFilter<"users"> | number
  }

  export type usersOrderByWithRelationInput = {
    Username?: SortOrder
    Password?: SortOrder
    id?: SortOrder
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Enumerable<usersWhereInput>
    OR?: Enumerable<usersWhereInput>
    NOT?: Enumerable<usersWhereInput>
    Username?: StringFilter<"users"> | string
    Password?: StringFilter<"users"> | string
  }, "id">

  export type usersOrderByWithAggregationInput = {
    Username?: SortOrder
    Password?: SortOrder
    id?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usersScalarWhereWithAggregatesInput>
    OR?: Enumerable<usersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usersScalarWhereWithAggregatesInput>
    Username?: StringWithAggregatesFilter<"users"> | string
    Password?: StringWithAggregatesFilter<"users"> | string
    id?: IntWithAggregatesFilter<"users"> | number
  }

  export type TBEventReg_ACM2017CreateInput = {
    ID: number
    EventTitle?: string | null
    RegName?: string | null
    RegEmail?: string | null
    RegTel?: string | null
    RegAddress?: string | null
    RegAffiliate?: string | null
    RegPreamble: string
    RegQuestion: string
    RegDate?: Date | string | null
    RegIP: string
  }

  export type TBEventReg_ACM2017UncheckedCreateInput = {
    ID: number
    EventTitle?: string | null
    RegName?: string | null
    RegEmail?: string | null
    RegTel?: string | null
    RegAddress?: string | null
    RegAffiliate?: string | null
    RegPreamble: string
    RegQuestion: string
    RegDate?: Date | string | null
    RegIP: string
  }

  export type TBEventReg_ACM2017UpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegAffiliate?: NullableStringFieldUpdateOperationsInput | string | null
    RegPreamble?: StringFieldUpdateOperationsInput | string
    RegQuestion?: StringFieldUpdateOperationsInput | string
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_ACM2017UncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegAffiliate?: NullableStringFieldUpdateOperationsInput | string | null
    RegPreamble?: StringFieldUpdateOperationsInput | string
    RegQuestion?: StringFieldUpdateOperationsInput | string
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_ACM2017CreateManyInput = {
    ID: number
    EventTitle?: string | null
    RegName?: string | null
    RegEmail?: string | null
    RegTel?: string | null
    RegAddress?: string | null
    RegAffiliate?: string | null
    RegPreamble: string
    RegQuestion: string
    RegDate?: Date | string | null
    RegIP: string
  }

  export type TBEventReg_ACM2017UpdateManyMutationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegAffiliate?: NullableStringFieldUpdateOperationsInput | string | null
    RegPreamble?: StringFieldUpdateOperationsInput | string
    RegQuestion?: StringFieldUpdateOperationsInput | string
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_ACM2017UncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegAffiliate?: NullableStringFieldUpdateOperationsInput | string | null
    RegPreamble?: StringFieldUpdateOperationsInput | string
    RegQuestion?: StringFieldUpdateOperationsInput | string
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_ACM2018CreateInput = {
    EventTitle?: string | null
    RegName?: string | null
    RegEmail?: string | null
    RegTel?: string | null
    RegAddress?: string | null
    RegAffiliate?: string | null
    RegPreamble: string
    RegQuestion: string
    RegDate?: Date | string | null
    RegIP: string
  }

  export type TBEventReg_ACM2018UncheckedCreateInput = {
    ID?: number
    EventTitle?: string | null
    RegName?: string | null
    RegEmail?: string | null
    RegTel?: string | null
    RegAddress?: string | null
    RegAffiliate?: string | null
    RegPreamble: string
    RegQuestion: string
    RegDate?: Date | string | null
    RegIP: string
  }

  export type TBEventReg_ACM2018UpdateInput = {
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegAffiliate?: NullableStringFieldUpdateOperationsInput | string | null
    RegPreamble?: StringFieldUpdateOperationsInput | string
    RegQuestion?: StringFieldUpdateOperationsInput | string
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_ACM2018UncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegAffiliate?: NullableStringFieldUpdateOperationsInput | string | null
    RegPreamble?: StringFieldUpdateOperationsInput | string
    RegQuestion?: StringFieldUpdateOperationsInput | string
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_ACM2018CreateManyInput = {
    ID?: number
    EventTitle?: string | null
    RegName?: string | null
    RegEmail?: string | null
    RegTel?: string | null
    RegAddress?: string | null
    RegAffiliate?: string | null
    RegPreamble: string
    RegQuestion: string
    RegDate?: Date | string | null
    RegIP: string
  }

  export type TBEventReg_ACM2018UpdateManyMutationInput = {
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegAffiliate?: NullableStringFieldUpdateOperationsInput | string | null
    RegPreamble?: StringFieldUpdateOperationsInput | string
    RegQuestion?: StringFieldUpdateOperationsInput | string
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_ACM2018UncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegAffiliate?: NullableStringFieldUpdateOperationsInput | string | null
    RegPreamble?: StringFieldUpdateOperationsInput | string
    RegQuestion?: StringFieldUpdateOperationsInput | string
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_ACM2022CreateInput = {
    EventTitle?: string | null
    RegName?: string | null
    RegEmail?: string | null
    RegTel?: string | null
    RegAddress?: string | null
    RegAffiliate?: string | null
    RegPreamble: string
    RegQuestion: string
    RegDate?: Date | string | null
    RegIP: string
  }

  export type TBEventReg_ACM2022UncheckedCreateInput = {
    ID?: number
    EventTitle?: string | null
    RegName?: string | null
    RegEmail?: string | null
    RegTel?: string | null
    RegAddress?: string | null
    RegAffiliate?: string | null
    RegPreamble: string
    RegQuestion: string
    RegDate?: Date | string | null
    RegIP: string
  }

  export type TBEventReg_ACM2022UpdateInput = {
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegAffiliate?: NullableStringFieldUpdateOperationsInput | string | null
    RegPreamble?: StringFieldUpdateOperationsInput | string
    RegQuestion?: StringFieldUpdateOperationsInput | string
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_ACM2022UncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegAffiliate?: NullableStringFieldUpdateOperationsInput | string | null
    RegPreamble?: StringFieldUpdateOperationsInput | string
    RegQuestion?: StringFieldUpdateOperationsInput | string
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_ACM2022CreateManyInput = {
    ID?: number
    EventTitle?: string | null
    RegName?: string | null
    RegEmail?: string | null
    RegTel?: string | null
    RegAddress?: string | null
    RegAffiliate?: string | null
    RegPreamble: string
    RegQuestion: string
    RegDate?: Date | string | null
    RegIP: string
  }

  export type TBEventReg_ACM2022UpdateManyMutationInput = {
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegAffiliate?: NullableStringFieldUpdateOperationsInput | string | null
    RegPreamble?: StringFieldUpdateOperationsInput | string
    RegQuestion?: StringFieldUpdateOperationsInput | string
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_ACM2022UncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegAffiliate?: NullableStringFieldUpdateOperationsInput | string | null
    RegPreamble?: StringFieldUpdateOperationsInput | string
    RegQuestion?: StringFieldUpdateOperationsInput | string
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_ChessChampionship2019CreateInput = {
    EventTitle: string
    RegNameFirst: string
    RegNameLast: string
    RegDOB: Date | string
    RegEmail: string
    RegTel: string
    ParentNameFirst: string
    ParentNameLast: string
    ParentTel: string
    ParentEmail: string
    RegDate: Date | string
    RegIP: string
  }

  export type TBEventReg_ChessChampionship2019UncheckedCreateInput = {
    ID?: number
    EventTitle: string
    RegNameFirst: string
    RegNameLast: string
    RegDOB: Date | string
    RegEmail: string
    RegTel: string
    ParentNameFirst: string
    ParentNameLast: string
    ParentTel: string
    ParentEmail: string
    RegDate: Date | string
    RegIP: string
  }

  export type TBEventReg_ChessChampionship2019UpdateInput = {
    EventTitle?: StringFieldUpdateOperationsInput | string
    RegNameFirst?: StringFieldUpdateOperationsInput | string
    RegNameLast?: StringFieldUpdateOperationsInput | string
    RegDOB?: DateTimeFieldUpdateOperationsInput | Date | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    ParentNameFirst?: StringFieldUpdateOperationsInput | string
    ParentNameLast?: StringFieldUpdateOperationsInput | string
    ParentTel?: StringFieldUpdateOperationsInput | string
    ParentEmail?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_ChessChampionship2019UncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: StringFieldUpdateOperationsInput | string
    RegNameFirst?: StringFieldUpdateOperationsInput | string
    RegNameLast?: StringFieldUpdateOperationsInput | string
    RegDOB?: DateTimeFieldUpdateOperationsInput | Date | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    ParentNameFirst?: StringFieldUpdateOperationsInput | string
    ParentNameLast?: StringFieldUpdateOperationsInput | string
    ParentTel?: StringFieldUpdateOperationsInput | string
    ParentEmail?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_ChessChampionship2019CreateManyInput = {
    ID?: number
    EventTitle: string
    RegNameFirst: string
    RegNameLast: string
    RegDOB: Date | string
    RegEmail: string
    RegTel: string
    ParentNameFirst: string
    ParentNameLast: string
    ParentTel: string
    ParentEmail: string
    RegDate: Date | string
    RegIP: string
  }

  export type TBEventReg_ChessChampionship2019UpdateManyMutationInput = {
    EventTitle?: StringFieldUpdateOperationsInput | string
    RegNameFirst?: StringFieldUpdateOperationsInput | string
    RegNameLast?: StringFieldUpdateOperationsInput | string
    RegDOB?: DateTimeFieldUpdateOperationsInput | Date | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    ParentNameFirst?: StringFieldUpdateOperationsInput | string
    ParentNameLast?: StringFieldUpdateOperationsInput | string
    ParentTel?: StringFieldUpdateOperationsInput | string
    ParentEmail?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_ChessChampionship2019UncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: StringFieldUpdateOperationsInput | string
    RegNameFirst?: StringFieldUpdateOperationsInput | string
    RegNameLast?: StringFieldUpdateOperationsInput | string
    RegDOB?: DateTimeFieldUpdateOperationsInput | Date | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    ParentNameFirst?: StringFieldUpdateOperationsInput | string
    ParentNameLast?: StringFieldUpdateOperationsInput | string
    ParentTel?: StringFieldUpdateOperationsInput | string
    ParentEmail?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_SEEE_2017CreateInput = {
    ID: number
    EventTitle: string
    RegName: string
    RegEmail: string
    RegTel: string
    RegAddress: string
    RegDate: Date | string
    RegIP: string
    RegLunch?: string | null
  }

  export type TBEventReg_SEEE_2017UncheckedCreateInput = {
    ID: number
    EventTitle: string
    RegName: string
    RegEmail: string
    RegTel: string
    RegAddress: string
    RegDate: Date | string
    RegIP: string
    RegLunch?: string | null
  }

  export type TBEventReg_SEEE_2017UpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: StringFieldUpdateOperationsInput | string
    RegName?: StringFieldUpdateOperationsInput | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    RegAddress?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
    RegLunch?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TBEventReg_SEEE_2017UncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: StringFieldUpdateOperationsInput | string
    RegName?: StringFieldUpdateOperationsInput | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    RegAddress?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
    RegLunch?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TBEventReg_SEEE_2017CreateManyInput = {
    ID: number
    EventTitle: string
    RegName: string
    RegEmail: string
    RegTel: string
    RegAddress: string
    RegDate: Date | string
    RegIP: string
    RegLunch?: string | null
  }

  export type TBEventReg_SEEE_2017UpdateManyMutationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: StringFieldUpdateOperationsInput | string
    RegName?: StringFieldUpdateOperationsInput | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    RegAddress?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
    RegLunch?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TBEventReg_SEEE_2017UncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: StringFieldUpdateOperationsInput | string
    RegName?: StringFieldUpdateOperationsInput | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    RegAddress?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
    RegLunch?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TBEventReg_SEEE_2017_VenderInfoCreateInput = {
    ID: number
    VenderCompTitle: string
    VenderResource: string
    VenderEmail: string
    VenderDescrip: string
    VenderBooth: string
    VenderTel: string
    AMorPM: string
    AM1: string
    AM2: string
    AM3: string
    AM4: string
    AM5: string
    AM6: string
    PM1: string
    PM2: string
    PM3: string
    PM4: string
    PM5: string
    PM6: string
  }

  export type TBEventReg_SEEE_2017_VenderInfoUncheckedCreateInput = {
    ID: number
    VenderCompTitle: string
    VenderResource: string
    VenderEmail: string
    VenderDescrip: string
    VenderBooth: string
    VenderTel: string
    AMorPM: string
    AM1: string
    AM2: string
    AM3: string
    AM4: string
    AM5: string
    AM6: string
    PM1: string
    PM2: string
    PM3: string
    PM4: string
    PM5: string
    PM6: string
  }

  export type TBEventReg_SEEE_2017_VenderInfoUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    VenderCompTitle?: StringFieldUpdateOperationsInput | string
    VenderResource?: StringFieldUpdateOperationsInput | string
    VenderEmail?: StringFieldUpdateOperationsInput | string
    VenderDescrip?: StringFieldUpdateOperationsInput | string
    VenderBooth?: StringFieldUpdateOperationsInput | string
    VenderTel?: StringFieldUpdateOperationsInput | string
    AMorPM?: StringFieldUpdateOperationsInput | string
    AM1?: StringFieldUpdateOperationsInput | string
    AM2?: StringFieldUpdateOperationsInput | string
    AM3?: StringFieldUpdateOperationsInput | string
    AM4?: StringFieldUpdateOperationsInput | string
    AM5?: StringFieldUpdateOperationsInput | string
    AM6?: StringFieldUpdateOperationsInput | string
    PM1?: StringFieldUpdateOperationsInput | string
    PM2?: StringFieldUpdateOperationsInput | string
    PM3?: StringFieldUpdateOperationsInput | string
    PM4?: StringFieldUpdateOperationsInput | string
    PM5?: StringFieldUpdateOperationsInput | string
    PM6?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_SEEE_2017_VenderInfoUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    VenderCompTitle?: StringFieldUpdateOperationsInput | string
    VenderResource?: StringFieldUpdateOperationsInput | string
    VenderEmail?: StringFieldUpdateOperationsInput | string
    VenderDescrip?: StringFieldUpdateOperationsInput | string
    VenderBooth?: StringFieldUpdateOperationsInput | string
    VenderTel?: StringFieldUpdateOperationsInput | string
    AMorPM?: StringFieldUpdateOperationsInput | string
    AM1?: StringFieldUpdateOperationsInput | string
    AM2?: StringFieldUpdateOperationsInput | string
    AM3?: StringFieldUpdateOperationsInput | string
    AM4?: StringFieldUpdateOperationsInput | string
    AM5?: StringFieldUpdateOperationsInput | string
    AM6?: StringFieldUpdateOperationsInput | string
    PM1?: StringFieldUpdateOperationsInput | string
    PM2?: StringFieldUpdateOperationsInput | string
    PM3?: StringFieldUpdateOperationsInput | string
    PM4?: StringFieldUpdateOperationsInput | string
    PM5?: StringFieldUpdateOperationsInput | string
    PM6?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_SEEE_2017_VenderInfoCreateManyInput = {
    ID: number
    VenderCompTitle: string
    VenderResource: string
    VenderEmail: string
    VenderDescrip: string
    VenderBooth: string
    VenderTel: string
    AMorPM: string
    AM1: string
    AM2: string
    AM3: string
    AM4: string
    AM5: string
    AM6: string
    PM1: string
    PM2: string
    PM3: string
    PM4: string
    PM5: string
    PM6: string
  }

  export type TBEventReg_SEEE_2017_VenderInfoUpdateManyMutationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    VenderCompTitle?: StringFieldUpdateOperationsInput | string
    VenderResource?: StringFieldUpdateOperationsInput | string
    VenderEmail?: StringFieldUpdateOperationsInput | string
    VenderDescrip?: StringFieldUpdateOperationsInput | string
    VenderBooth?: StringFieldUpdateOperationsInput | string
    VenderTel?: StringFieldUpdateOperationsInput | string
    AMorPM?: StringFieldUpdateOperationsInput | string
    AM1?: StringFieldUpdateOperationsInput | string
    AM2?: StringFieldUpdateOperationsInput | string
    AM3?: StringFieldUpdateOperationsInput | string
    AM4?: StringFieldUpdateOperationsInput | string
    AM5?: StringFieldUpdateOperationsInput | string
    AM6?: StringFieldUpdateOperationsInput | string
    PM1?: StringFieldUpdateOperationsInput | string
    PM2?: StringFieldUpdateOperationsInput | string
    PM3?: StringFieldUpdateOperationsInput | string
    PM4?: StringFieldUpdateOperationsInput | string
    PM5?: StringFieldUpdateOperationsInput | string
    PM6?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_SEEE_2017_VenderInfoUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    VenderCompTitle?: StringFieldUpdateOperationsInput | string
    VenderResource?: StringFieldUpdateOperationsInput | string
    VenderEmail?: StringFieldUpdateOperationsInput | string
    VenderDescrip?: StringFieldUpdateOperationsInput | string
    VenderBooth?: StringFieldUpdateOperationsInput | string
    VenderTel?: StringFieldUpdateOperationsInput | string
    AMorPM?: StringFieldUpdateOperationsInput | string
    AM1?: StringFieldUpdateOperationsInput | string
    AM2?: StringFieldUpdateOperationsInput | string
    AM3?: StringFieldUpdateOperationsInput | string
    AM4?: StringFieldUpdateOperationsInput | string
    AM5?: StringFieldUpdateOperationsInput | string
    AM6?: StringFieldUpdateOperationsInput | string
    PM1?: StringFieldUpdateOperationsInput | string
    PM2?: StringFieldUpdateOperationsInput | string
    PM3?: StringFieldUpdateOperationsInput | string
    PM4?: StringFieldUpdateOperationsInput | string
    PM5?: StringFieldUpdateOperationsInput | string
    PM6?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_SEEE_2018CreateInput = {
    EventTitle: string
    RegName: string
    RegEmail: string
    RegTel: string
    RegAddress: string
    RegDate: Date | string
    RegIP: string
    RegLunch?: string | null
  }

  export type TBEventReg_SEEE_2018UncheckedCreateInput = {
    ID?: number
    EventTitle: string
    RegName: string
    RegEmail: string
    RegTel: string
    RegAddress: string
    RegDate: Date | string
    RegIP: string
    RegLunch?: string | null
  }

  export type TBEventReg_SEEE_2018UpdateInput = {
    EventTitle?: StringFieldUpdateOperationsInput | string
    RegName?: StringFieldUpdateOperationsInput | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    RegAddress?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
    RegLunch?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TBEventReg_SEEE_2018UncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: StringFieldUpdateOperationsInput | string
    RegName?: StringFieldUpdateOperationsInput | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    RegAddress?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
    RegLunch?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TBEventReg_SEEE_2018CreateManyInput = {
    ID?: number
    EventTitle: string
    RegName: string
    RegEmail: string
    RegTel: string
    RegAddress: string
    RegDate: Date | string
    RegIP: string
    RegLunch?: string | null
  }

  export type TBEventReg_SEEE_2018UpdateManyMutationInput = {
    EventTitle?: StringFieldUpdateOperationsInput | string
    RegName?: StringFieldUpdateOperationsInput | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    RegAddress?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
    RegLunch?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TBEventReg_SEEE_2018UncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: StringFieldUpdateOperationsInput | string
    RegName?: StringFieldUpdateOperationsInput | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    RegAddress?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
    RegLunch?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TBEventReg_SEEE_2018_VenderInfoCreateInput = {
    VenderCompTitle: string
    VenderContactPerson: string
    VenderResource: string
    VenderEmail: string
    VenderDescrip: string
    VenderBooth: string
    VenderTel: string
    TimeSlot1: string
    TimeSlot2: string
    TimeSlot3: string
    TimeSlot4: string
    TimeSlot5: string
    TimeSlot6: string
    TimeSlot7: string
    TimeSlot8: string
    TimeSlot9: string
    TimeSlot10: string
  }

  export type TBEventReg_SEEE_2018_VenderInfoUncheckedCreateInput = {
    ID?: number
    VenderCompTitle: string
    VenderContactPerson: string
    VenderResource: string
    VenderEmail: string
    VenderDescrip: string
    VenderBooth: string
    VenderTel: string
    TimeSlot1: string
    TimeSlot2: string
    TimeSlot3: string
    TimeSlot4: string
    TimeSlot5: string
    TimeSlot6: string
    TimeSlot7: string
    TimeSlot8: string
    TimeSlot9: string
    TimeSlot10: string
  }

  export type TBEventReg_SEEE_2018_VenderInfoUpdateInput = {
    VenderCompTitle?: StringFieldUpdateOperationsInput | string
    VenderContactPerson?: StringFieldUpdateOperationsInput | string
    VenderResource?: StringFieldUpdateOperationsInput | string
    VenderEmail?: StringFieldUpdateOperationsInput | string
    VenderDescrip?: StringFieldUpdateOperationsInput | string
    VenderBooth?: StringFieldUpdateOperationsInput | string
    VenderTel?: StringFieldUpdateOperationsInput | string
    TimeSlot1?: StringFieldUpdateOperationsInput | string
    TimeSlot2?: StringFieldUpdateOperationsInput | string
    TimeSlot3?: StringFieldUpdateOperationsInput | string
    TimeSlot4?: StringFieldUpdateOperationsInput | string
    TimeSlot5?: StringFieldUpdateOperationsInput | string
    TimeSlot6?: StringFieldUpdateOperationsInput | string
    TimeSlot7?: StringFieldUpdateOperationsInput | string
    TimeSlot8?: StringFieldUpdateOperationsInput | string
    TimeSlot9?: StringFieldUpdateOperationsInput | string
    TimeSlot10?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_SEEE_2018_VenderInfoUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    VenderCompTitle?: StringFieldUpdateOperationsInput | string
    VenderContactPerson?: StringFieldUpdateOperationsInput | string
    VenderResource?: StringFieldUpdateOperationsInput | string
    VenderEmail?: StringFieldUpdateOperationsInput | string
    VenderDescrip?: StringFieldUpdateOperationsInput | string
    VenderBooth?: StringFieldUpdateOperationsInput | string
    VenderTel?: StringFieldUpdateOperationsInput | string
    TimeSlot1?: StringFieldUpdateOperationsInput | string
    TimeSlot2?: StringFieldUpdateOperationsInput | string
    TimeSlot3?: StringFieldUpdateOperationsInput | string
    TimeSlot4?: StringFieldUpdateOperationsInput | string
    TimeSlot5?: StringFieldUpdateOperationsInput | string
    TimeSlot6?: StringFieldUpdateOperationsInput | string
    TimeSlot7?: StringFieldUpdateOperationsInput | string
    TimeSlot8?: StringFieldUpdateOperationsInput | string
    TimeSlot9?: StringFieldUpdateOperationsInput | string
    TimeSlot10?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_SEEE_2018_VenderInfoCreateManyInput = {
    ID?: number
    VenderCompTitle: string
    VenderContactPerson: string
    VenderResource: string
    VenderEmail: string
    VenderDescrip: string
    VenderBooth: string
    VenderTel: string
    TimeSlot1: string
    TimeSlot2: string
    TimeSlot3: string
    TimeSlot4: string
    TimeSlot5: string
    TimeSlot6: string
    TimeSlot7: string
    TimeSlot8: string
    TimeSlot9: string
    TimeSlot10: string
  }

  export type TBEventReg_SEEE_2018_VenderInfoUpdateManyMutationInput = {
    VenderCompTitle?: StringFieldUpdateOperationsInput | string
    VenderContactPerson?: StringFieldUpdateOperationsInput | string
    VenderResource?: StringFieldUpdateOperationsInput | string
    VenderEmail?: StringFieldUpdateOperationsInput | string
    VenderDescrip?: StringFieldUpdateOperationsInput | string
    VenderBooth?: StringFieldUpdateOperationsInput | string
    VenderTel?: StringFieldUpdateOperationsInput | string
    TimeSlot1?: StringFieldUpdateOperationsInput | string
    TimeSlot2?: StringFieldUpdateOperationsInput | string
    TimeSlot3?: StringFieldUpdateOperationsInput | string
    TimeSlot4?: StringFieldUpdateOperationsInput | string
    TimeSlot5?: StringFieldUpdateOperationsInput | string
    TimeSlot6?: StringFieldUpdateOperationsInput | string
    TimeSlot7?: StringFieldUpdateOperationsInput | string
    TimeSlot8?: StringFieldUpdateOperationsInput | string
    TimeSlot9?: StringFieldUpdateOperationsInput | string
    TimeSlot10?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_SEEE_2018_VenderInfoUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    VenderCompTitle?: StringFieldUpdateOperationsInput | string
    VenderContactPerson?: StringFieldUpdateOperationsInput | string
    VenderResource?: StringFieldUpdateOperationsInput | string
    VenderEmail?: StringFieldUpdateOperationsInput | string
    VenderDescrip?: StringFieldUpdateOperationsInput | string
    VenderBooth?: StringFieldUpdateOperationsInput | string
    VenderTel?: StringFieldUpdateOperationsInput | string
    TimeSlot1?: StringFieldUpdateOperationsInput | string
    TimeSlot2?: StringFieldUpdateOperationsInput | string
    TimeSlot3?: StringFieldUpdateOperationsInput | string
    TimeSlot4?: StringFieldUpdateOperationsInput | string
    TimeSlot5?: StringFieldUpdateOperationsInput | string
    TimeSlot6?: StringFieldUpdateOperationsInput | string
    TimeSlot7?: StringFieldUpdateOperationsInput | string
    TimeSlot8?: StringFieldUpdateOperationsInput | string
    TimeSlot9?: StringFieldUpdateOperationsInput | string
    TimeSlot10?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_SpringIntoActionCreateInput = {
    ID: number
    EventTitle?: string | null
    RegName?: string | null
    RegEmail?: string | null
    RegTel?: string | null
    RegAddress?: string | null
    RegDate?: Date | string | null
    RegIP: string
  }

  export type TBEventReg_SpringIntoActionUncheckedCreateInput = {
    ID: number
    EventTitle?: string | null
    RegName?: string | null
    RegEmail?: string | null
    RegTel?: string | null
    RegAddress?: string | null
    RegDate?: Date | string | null
    RegIP: string
  }

  export type TBEventReg_SpringIntoActionUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_SpringIntoActionUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_SpringIntoActionCreateManyInput = {
    ID: number
    EventTitle?: string | null
    RegName?: string | null
    RegEmail?: string | null
    RegTel?: string | null
    RegAddress?: string | null
    RegDate?: Date | string | null
    RegIP: string
  }

  export type TBEventReg_SpringIntoActionUpdateManyMutationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBEventReg_SpringIntoActionUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    RegName?: NullableStringFieldUpdateOperationsInput | string | null
    RegEmail?: NullableStringFieldUpdateOperationsInput | string | null
    RegTel?: NullableStringFieldUpdateOperationsInput | string | null
    RegAddress?: NullableStringFieldUpdateOperationsInput | string | null
    RegDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBInvisibleIllness2019CreateInput = {
    RegName: string
    RegEmail: string
    RegTel: string
    IfRCDMember: string
    RegDate: Date | string
    RegIP: string
  }

  export type TBInvisibleIllness2019UncheckedCreateInput = {
    IndexID?: number
    RegName: string
    RegEmail: string
    RegTel: string
    IfRCDMember: string
    RegDate: Date | string
    RegIP: string
  }

  export type TBInvisibleIllness2019UpdateInput = {
    RegName?: StringFieldUpdateOperationsInput | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    IfRCDMember?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBInvisibleIllness2019UncheckedUpdateInput = {
    IndexID?: IntFieldUpdateOperationsInput | number
    RegName?: StringFieldUpdateOperationsInput | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    IfRCDMember?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBInvisibleIllness2019CreateManyInput = {
    IndexID?: number
    RegName: string
    RegEmail: string
    RegTel: string
    IfRCDMember: string
    RegDate: Date | string
    RegIP: string
  }

  export type TBInvisibleIllness2019UpdateManyMutationInput = {
    RegName?: StringFieldUpdateOperationsInput | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    IfRCDMember?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TBInvisibleIllness2019UncheckedUpdateManyInput = {
    IndexID?: IntFieldUpdateOperationsInput | number
    RegName?: StringFieldUpdateOperationsInput | string
    RegEmail?: StringFieldUpdateOperationsInput | string
    RegTel?: StringFieldUpdateOperationsInput | string
    IfRCDMember?: StringFieldUpdateOperationsInput | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegIP?: StringFieldUpdateOperationsInput | string
  }

  export type TB_2017Gala_KaraokaCreateInput = {
    ID: number
    NominatorName: string
    NominatorTelEmail: string
    NomineeName: string
    NomineeTelEmail: string
    KaraokeName: string
    BringCD: string
    RegDateTime: Date | string
  }

  export type TB_2017Gala_KaraokaUncheckedCreateInput = {
    ID: number
    NominatorName: string
    NominatorTelEmail: string
    NomineeName: string
    NomineeTelEmail: string
    KaraokeName: string
    BringCD: string
    RegDateTime: Date | string
  }

  export type TB_2017Gala_KaraokaUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    NominatorName?: StringFieldUpdateOperationsInput | string
    NominatorTelEmail?: StringFieldUpdateOperationsInput | string
    NomineeName?: StringFieldUpdateOperationsInput | string
    NomineeTelEmail?: StringFieldUpdateOperationsInput | string
    KaraokeName?: StringFieldUpdateOperationsInput | string
    BringCD?: StringFieldUpdateOperationsInput | string
    RegDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TB_2017Gala_KaraokaUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    NominatorName?: StringFieldUpdateOperationsInput | string
    NominatorTelEmail?: StringFieldUpdateOperationsInput | string
    NomineeName?: StringFieldUpdateOperationsInput | string
    NomineeTelEmail?: StringFieldUpdateOperationsInput | string
    KaraokeName?: StringFieldUpdateOperationsInput | string
    BringCD?: StringFieldUpdateOperationsInput | string
    RegDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TB_2017Gala_KaraokaCreateManyInput = {
    ID: number
    NominatorName: string
    NominatorTelEmail: string
    NomineeName: string
    NomineeTelEmail: string
    KaraokeName: string
    BringCD: string
    RegDateTime: Date | string
  }

  export type TB_2017Gala_KaraokaUpdateManyMutationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    NominatorName?: StringFieldUpdateOperationsInput | string
    NominatorTelEmail?: StringFieldUpdateOperationsInput | string
    NomineeName?: StringFieldUpdateOperationsInput | string
    NomineeTelEmail?: StringFieldUpdateOperationsInput | string
    KaraokeName?: StringFieldUpdateOperationsInput | string
    BringCD?: StringFieldUpdateOperationsInput | string
    RegDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TB_2017Gala_KaraokaUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    NominatorName?: StringFieldUpdateOperationsInput | string
    NominatorTelEmail?: StringFieldUpdateOperationsInput | string
    NomineeName?: StringFieldUpdateOperationsInput | string
    NomineeTelEmail?: StringFieldUpdateOperationsInput | string
    KaraokeName?: StringFieldUpdateOperationsInput | string
    BringCD?: StringFieldUpdateOperationsInput | string
    RegDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023CreateInput = {
    barrage_content: string
    createdAt?: Date | string
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023UncheckedCreateInput = {
    barrage_id?: number
    barrage_content: string
    createdAt?: Date | string
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023UpdateInput = {
    barrage_content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023UncheckedUpdateInput = {
    barrage_id?: IntFieldUpdateOperationsInput | number
    barrage_content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023CreateManyInput = {
    barrage_id?: number
    barrage_content: string
    createdAt?: Date | string
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023UpdateManyMutationInput = {
    barrage_content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023UncheckedUpdateManyInput = {
    barrage_id?: IntFieldUpdateOperationsInput | number
    barrage_content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auth_groupCreateInput = {
    name: string
    auth_group_permissions?: auth_group_permissionsCreateNestedManyWithoutAuth_groupInput
    auth_user_groups?: auth_user_groupsCreateNestedManyWithoutAuth_groupInput
  }

  export type auth_groupUncheckedCreateInput = {
    id?: number
    name: string
    auth_group_permissions?: auth_group_permissionsUncheckedCreateNestedManyWithoutAuth_groupInput
    auth_user_groups?: auth_user_groupsUncheckedCreateNestedManyWithoutAuth_groupInput
  }

  export type auth_groupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    auth_group_permissions?: auth_group_permissionsUpdateManyWithoutAuth_groupNestedInput
    auth_user_groups?: auth_user_groupsUpdateManyWithoutAuth_groupNestedInput
  }

  export type auth_groupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    auth_group_permissions?: auth_group_permissionsUncheckedUpdateManyWithoutAuth_groupNestedInput
    auth_user_groups?: auth_user_groupsUncheckedUpdateManyWithoutAuth_groupNestedInput
  }

  export type auth_groupCreateManyInput = {
    id?: number
    name: string
  }

  export type auth_groupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type auth_groupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type auth_group_permissionsCreateInput = {
    id?: bigint | number
    auth_permission: auth_permissionCreateNestedOneWithoutAuth_group_permissionsInput
    auth_group: auth_groupCreateNestedOneWithoutAuth_group_permissionsInput
  }

  export type auth_group_permissionsUncheckedCreateInput = {
    id?: bigint | number
    group_id: number
    permission_id: number
  }

  export type auth_group_permissionsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    auth_permission?: auth_permissionUpdateOneRequiredWithoutAuth_group_permissionsNestedInput
    auth_group?: auth_groupUpdateOneRequiredWithoutAuth_group_permissionsNestedInput
  }

  export type auth_group_permissionsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_group_permissionsCreateManyInput = {
    id?: bigint | number
    group_id: number
    permission_id: number
  }

  export type auth_group_permissionsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type auth_group_permissionsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_permissionCreateInput = {
    name: string
    codename: string
    auth_group_permissions?: auth_group_permissionsCreateNestedManyWithoutAuth_permissionInput
    django_content_type: django_content_typeCreateNestedOneWithoutAuth_permissionInput
    auth_user_user_permissions?: auth_user_user_permissionsCreateNestedManyWithoutAuth_permissionInput
  }

  export type auth_permissionUncheckedCreateInput = {
    id?: number
    name: string
    content_type_id: number
    codename: string
    auth_group_permissions?: auth_group_permissionsUncheckedCreateNestedManyWithoutAuth_permissionInput
    auth_user_user_permissions?: auth_user_user_permissionsUncheckedCreateNestedManyWithoutAuth_permissionInput
  }

  export type auth_permissionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    codename?: StringFieldUpdateOperationsInput | string
    auth_group_permissions?: auth_group_permissionsUpdateManyWithoutAuth_permissionNestedInput
    django_content_type?: django_content_typeUpdateOneRequiredWithoutAuth_permissionNestedInput
    auth_user_user_permissions?: auth_user_user_permissionsUpdateManyWithoutAuth_permissionNestedInput
  }

  export type auth_permissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content_type_id?: IntFieldUpdateOperationsInput | number
    codename?: StringFieldUpdateOperationsInput | string
    auth_group_permissions?: auth_group_permissionsUncheckedUpdateManyWithoutAuth_permissionNestedInput
    auth_user_user_permissions?: auth_user_user_permissionsUncheckedUpdateManyWithoutAuth_permissionNestedInput
  }

  export type auth_permissionCreateManyInput = {
    id?: number
    name: string
    content_type_id: number
    codename: string
  }

  export type auth_permissionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    codename?: StringFieldUpdateOperationsInput | string
  }

  export type auth_permissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content_type_id?: IntFieldUpdateOperationsInput | number
    codename?: StringFieldUpdateOperationsInput | string
  }

  export type auth_userCreateInput = {
    password: string
    last_login?: Date | string | null
    is_superuser: boolean
    username: string
    first_name: string
    last_name: string
    email: string
    is_staff: boolean
    is_active: boolean
    date_joined: Date | string
    auth_user_groups?: auth_user_groupsCreateNestedManyWithoutAuth_userInput
    auth_user_user_permissions?: auth_user_user_permissionsCreateNestedManyWithoutAuth_userInput
    django_admin_log?: django_admin_logCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateInput = {
    id?: number
    password: string
    last_login?: Date | string | null
    is_superuser: boolean
    username: string
    first_name: string
    last_name: string
    email: string
    is_staff: boolean
    is_active: boolean
    date_joined: Date | string
    auth_user_groups?: auth_user_groupsUncheckedCreateNestedManyWithoutAuth_userInput
    auth_user_user_permissions?: auth_user_user_permissionsUncheckedCreateNestedManyWithoutAuth_userInput
    django_admin_log?: django_admin_logUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUpdateInput = {
    password?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_superuser?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_staff?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    auth_user_groups?: auth_user_groupsUpdateManyWithoutAuth_userNestedInput
    auth_user_user_permissions?: auth_user_user_permissionsUpdateManyWithoutAuth_userNestedInput
    django_admin_log?: django_admin_logUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_superuser?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_staff?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    auth_user_groups?: auth_user_groupsUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_user_user_permissions?: auth_user_user_permissionsUncheckedUpdateManyWithoutAuth_userNestedInput
    django_admin_log?: django_admin_logUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userCreateManyInput = {
    id?: number
    password: string
    last_login?: Date | string | null
    is_superuser: boolean
    username: string
    first_name: string
    last_name: string
    email: string
    is_staff: boolean
    is_active: boolean
    date_joined: Date | string
  }

  export type auth_userUpdateManyMutationInput = {
    password?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_superuser?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_staff?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auth_userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_superuser?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_staff?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auth_user_groupsCreateInput = {
    id?: bigint | number
    auth_group: auth_groupCreateNestedOneWithoutAuth_user_groupsInput
    auth_user: auth_userCreateNestedOneWithoutAuth_user_groupsInput
  }

  export type auth_user_groupsUncheckedCreateInput = {
    id?: bigint | number
    user_id: number
    group_id: number
  }

  export type auth_user_groupsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    auth_group?: auth_groupUpdateOneRequiredWithoutAuth_user_groupsNestedInput
    auth_user?: auth_userUpdateOneRequiredWithoutAuth_user_groupsNestedInput
  }

  export type auth_user_groupsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_user_groupsCreateManyInput = {
    id?: bigint | number
    user_id: number
    group_id: number
  }

  export type auth_user_groupsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type auth_user_groupsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_user_user_permissionsCreateInput = {
    id?: bigint | number
    auth_permission: auth_permissionCreateNestedOneWithoutAuth_user_user_permissionsInput
    auth_user: auth_userCreateNestedOneWithoutAuth_user_user_permissionsInput
  }

  export type auth_user_user_permissionsUncheckedCreateInput = {
    id?: bigint | number
    user_id: number
    permission_id: number
  }

  export type auth_user_user_permissionsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    auth_permission?: auth_permissionUpdateOneRequiredWithoutAuth_user_user_permissionsNestedInput
    auth_user?: auth_userUpdateOneRequiredWithoutAuth_user_user_permissionsNestedInput
  }

  export type auth_user_user_permissionsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_user_user_permissionsCreateManyInput = {
    id?: bigint | number
    user_id: number
    permission_id: number
  }

  export type auth_user_user_permissionsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type auth_user_user_permissionsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type categoryListCreateInput = {
    categorytype?: string | null
    hide?: number | null
  }

  export type categoryListUncheckedCreateInput = {
    categorytype?: string | null
    hide?: number | null
    categoryID?: number
  }

  export type categoryListUpdateInput = {
    categorytype?: NullableStringFieldUpdateOperationsInput | string | null
    hide?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type categoryListUncheckedUpdateInput = {
    categorytype?: NullableStringFieldUpdateOperationsInput | string | null
    hide?: NullableIntFieldUpdateOperationsInput | number | null
    categoryID?: IntFieldUpdateOperationsInput | number
  }

  export type categoryListCreateManyInput = {
    categorytype?: string | null
    hide?: number | null
    categoryID?: number
  }

  export type categoryListUpdateManyMutationInput = {
    categorytype?: NullableStringFieldUpdateOperationsInput | string | null
    hide?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type categoryListUncheckedUpdateManyInput = {
    categorytype?: NullableStringFieldUpdateOperationsInput | string | null
    hide?: NullableIntFieldUpdateOperationsInput | number | null
    categoryID?: IntFieldUpdateOperationsInput | number
  }

  export type django_admin_logCreateInput = {
    action_time: Date | string
    object_id?: string | null
    object_repr: string
    action_flag: number
    change_message: string
    django_content_type?: django_content_typeCreateNestedOneWithoutDjango_admin_logInput
    auth_user: auth_userCreateNestedOneWithoutDjango_admin_logInput
  }

  export type django_admin_logUncheckedCreateInput = {
    id?: number
    action_time: Date | string
    object_id?: string | null
    object_repr: string
    action_flag: number
    change_message: string
    content_type_id?: number | null
    user_id: number
  }

  export type django_admin_logUpdateInput = {
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: NullableStringFieldUpdateOperationsInput | string | null
    object_repr?: StringFieldUpdateOperationsInput | string
    action_flag?: IntFieldUpdateOperationsInput | number
    change_message?: StringFieldUpdateOperationsInput | string
    django_content_type?: django_content_typeUpdateOneWithoutDjango_admin_logNestedInput
    auth_user?: auth_userUpdateOneRequiredWithoutDjango_admin_logNestedInput
  }

  export type django_admin_logUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: NullableStringFieldUpdateOperationsInput | string | null
    object_repr?: StringFieldUpdateOperationsInput | string
    action_flag?: IntFieldUpdateOperationsInput | number
    change_message?: StringFieldUpdateOperationsInput | string
    content_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type django_admin_logCreateManyInput = {
    id?: number
    action_time: Date | string
    object_id?: string | null
    object_repr: string
    action_flag: number
    change_message: string
    content_type_id?: number | null
    user_id: number
  }

  export type django_admin_logUpdateManyMutationInput = {
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: NullableStringFieldUpdateOperationsInput | string | null
    object_repr?: StringFieldUpdateOperationsInput | string
    action_flag?: IntFieldUpdateOperationsInput | number
    change_message?: StringFieldUpdateOperationsInput | string
  }

  export type django_admin_logUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: NullableStringFieldUpdateOperationsInput | string | null
    object_repr?: StringFieldUpdateOperationsInput | string
    action_flag?: IntFieldUpdateOperationsInput | number
    change_message?: StringFieldUpdateOperationsInput | string
    content_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type django_content_typeCreateInput = {
    app_label: string
    model: string
    auth_permission?: auth_permissionCreateNestedManyWithoutDjango_content_typeInput
    django_admin_log?: django_admin_logCreateNestedManyWithoutDjango_content_typeInput
  }

  export type django_content_typeUncheckedCreateInput = {
    id?: number
    app_label: string
    model: string
    auth_permission?: auth_permissionUncheckedCreateNestedManyWithoutDjango_content_typeInput
    django_admin_log?: django_admin_logUncheckedCreateNestedManyWithoutDjango_content_typeInput
  }

  export type django_content_typeUpdateInput = {
    app_label?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    auth_permission?: auth_permissionUpdateManyWithoutDjango_content_typeNestedInput
    django_admin_log?: django_admin_logUpdateManyWithoutDjango_content_typeNestedInput
  }

  export type django_content_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    app_label?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    auth_permission?: auth_permissionUncheckedUpdateManyWithoutDjango_content_typeNestedInput
    django_admin_log?: django_admin_logUncheckedUpdateManyWithoutDjango_content_typeNestedInput
  }

  export type django_content_typeCreateManyInput = {
    id?: number
    app_label: string
    model: string
  }

  export type django_content_typeUpdateManyMutationInput = {
    app_label?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
  }

  export type django_content_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    app_label?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
  }

  export type django_migrationsCreateInput = {
    id?: bigint | number
    app: string
    name: string
    applied: Date | string
  }

  export type django_migrationsUncheckedCreateInput = {
    id?: bigint | number
    app: string
    name: string
    applied: Date | string
  }

  export type django_migrationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    applied?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type django_migrationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    applied?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type django_migrationsCreateManyInput = {
    id?: bigint | number
    app: string
    name: string
    applied: Date | string
  }

  export type django_migrationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    applied?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type django_migrationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    app?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    applied?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type django_sessionCreateInput = {
    session_key: string
    session_data: string
    expire_date: Date | string
  }

  export type django_sessionUncheckedCreateInput = {
    session_key: string
    session_data: string
    expire_date: Date | string
  }

  export type django_sessionUpdateInput = {
    session_key?: StringFieldUpdateOperationsInput | string
    session_data?: StringFieldUpdateOperationsInput | string
    expire_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type django_sessionUncheckedUpdateInput = {
    session_key?: StringFieldUpdateOperationsInput | string
    session_data?: StringFieldUpdateOperationsInput | string
    expire_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type django_sessionCreateManyInput = {
    session_key: string
    session_data: string
    expire_date: Date | string
  }

  export type django_sessionUpdateManyMutationInput = {
    session_key?: StringFieldUpdateOperationsInput | string
    session_data?: StringFieldUpdateOperationsInput | string
    expire_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type django_sessionUncheckedUpdateManyInput = {
    session_key?: StringFieldUpdateOperationsInput | string
    session_data?: StringFieldUpdateOperationsInput | string
    expire_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventsCreateInput = {
    title: string
    color?: string | null
    start: Date | string
    end?: Date | string | null
  }

  export type eventsUncheckedCreateInput = {
    id?: number
    title: string
    color?: string | null
    start: Date | string
    end?: Date | string | null
  }

  export type eventsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type eventsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type eventsCreateManyInput = {
    id?: number
    title: string
    color?: string | null
    start: Date | string
    end?: Date | string | null
  }

  export type eventsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type eventsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type recordInfoCreateInput = {
    categoryID?: number | null
    Name?: string | null
    StreetAddress?: string | null
    City?: string | null
    PostalCode?: string | null
    Province?: string | null
    Telephone?: string | null
    Fax?: string | null
    Website?: string | null
  }

  export type recordInfoUncheckedCreateInput = {
    recordInfo_ID?: number
    categoryID?: number | null
    Name?: string | null
    StreetAddress?: string | null
    City?: string | null
    PostalCode?: string | null
    Province?: string | null
    Telephone?: string | null
    Fax?: string | null
    Website?: string | null
  }

  export type recordInfoUpdateInput = {
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    StreetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    Telephone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recordInfoUncheckedUpdateInput = {
    recordInfo_ID?: IntFieldUpdateOperationsInput | number
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    StreetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    Telephone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recordInfoCreateManyInput = {
    recordInfo_ID?: number
    categoryID?: number | null
    Name?: string | null
    StreetAddress?: string | null
    City?: string | null
    PostalCode?: string | null
    Province?: string | null
    Telephone?: string | null
    Fax?: string | null
    Website?: string | null
  }

  export type recordInfoUpdateManyMutationInput = {
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    StreetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    Telephone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recordInfoUncheckedUpdateManyInput = {
    recordInfo_ID?: IntFieldUpdateOperationsInput | number
    categoryID?: NullableIntFieldUpdateOperationsInput | number | null
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    StreetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    Province?: NullableStringFieldUpdateOperationsInput | string | null
    Telephone?: NullableStringFieldUpdateOperationsInput | string | null
    Fax?: NullableStringFieldUpdateOperationsInput | string | null
    Website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tbl_BMORun2024_BarrageCreateInput = {
    donor_Fname?: string | null
    donor_Lname?: string | null
    donor_Org?: string | null
    donor_Amount?: Decimal | DecimalJsLike | number | string | null
    createdAt: string
  }

  export type tbl_BMORun2024_BarrageUncheckedCreateInput = {
    ID?: number
    donor_Fname?: string | null
    donor_Lname?: string | null
    donor_Org?: string | null
    donor_Amount?: Decimal | DecimalJsLike | number | string | null
    createdAt: string
  }

  export type tbl_BMORun2024_BarrageUpdateInput = {
    donor_Fname?: NullableStringFieldUpdateOperationsInput | string | null
    donor_Lname?: NullableStringFieldUpdateOperationsInput | string | null
    donor_Org?: NullableStringFieldUpdateOperationsInput | string | null
    donor_Amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
  }

  export type tbl_BMORun2024_BarrageUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    donor_Fname?: NullableStringFieldUpdateOperationsInput | string | null
    donor_Lname?: NullableStringFieldUpdateOperationsInput | string | null
    donor_Org?: NullableStringFieldUpdateOperationsInput | string | null
    donor_Amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
  }

  export type tbl_BMORun2024_BarrageCreateManyInput = {
    ID?: number
    donor_Fname?: string | null
    donor_Lname?: string | null
    donor_Org?: string | null
    donor_Amount?: Decimal | DecimalJsLike | number | string | null
    createdAt: string
  }

  export type tbl_BMORun2024_BarrageUpdateManyMutationInput = {
    donor_Fname?: NullableStringFieldUpdateOperationsInput | string | null
    donor_Lname?: NullableStringFieldUpdateOperationsInput | string | null
    donor_Org?: NullableStringFieldUpdateOperationsInput | string | null
    donor_Amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
  }

  export type tbl_BMORun2024_BarrageUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    donor_Fname?: NullableStringFieldUpdateOperationsInput | string | null
    donor_Lname?: NullableStringFieldUpdateOperationsInput | string | null
    donor_Org?: NullableStringFieldUpdateOperationsInput | string | null
    donor_Amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: StringFieldUpdateOperationsInput | string
  }

  export type tbl_ETransferInfoCreateInput = {
    fname: string
    lname: string
    userAddress: string
    userTel: string
    useremail: string
    todaydate: Date | string
    RegDate: Date | string
    RegTime: Date | string
    userIP: string
  }

  export type tbl_ETransferInfoUncheckedCreateInput = {
    id?: number
    fname: string
    lname: string
    userAddress: string
    userTel: string
    useremail: string
    todaydate: Date | string
    RegDate: Date | string
    RegTime: Date | string
    userIP: string
  }

  export type tbl_ETransferInfoUpdateInput = {
    fname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    userTel?: StringFieldUpdateOperationsInput | string
    useremail?: StringFieldUpdateOperationsInput | string
    todaydate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegTime?: DateTimeFieldUpdateOperationsInput | Date | string
    userIP?: StringFieldUpdateOperationsInput | string
  }

  export type tbl_ETransferInfoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    userTel?: StringFieldUpdateOperationsInput | string
    useremail?: StringFieldUpdateOperationsInput | string
    todaydate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegTime?: DateTimeFieldUpdateOperationsInput | Date | string
    userIP?: StringFieldUpdateOperationsInput | string
  }

  export type tbl_ETransferInfoCreateManyInput = {
    id?: number
    fname: string
    lname: string
    userAddress: string
    userTel: string
    useremail: string
    todaydate: Date | string
    RegDate: Date | string
    RegTime: Date | string
    userIP: string
  }

  export type tbl_ETransferInfoUpdateManyMutationInput = {
    fname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    userTel?: StringFieldUpdateOperationsInput | string
    useremail?: StringFieldUpdateOperationsInput | string
    todaydate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegTime?: DateTimeFieldUpdateOperationsInput | Date | string
    userIP?: StringFieldUpdateOperationsInput | string
  }

  export type tbl_ETransferInfoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    userTel?: StringFieldUpdateOperationsInput | string
    useremail?: StringFieldUpdateOperationsInput | string
    todaydate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RegTime?: DateTimeFieldUpdateOperationsInput | Date | string
    userIP?: StringFieldUpdateOperationsInput | string
  }

  export type tbl_TshirtContestCreateInput = {
    id: number
    fname: string
    lname: string
    tel: string
    email: string
    notes: string
    artwork: string
    imgPreview: string
    ip: string
    submitTime: Date | string
  }

  export type tbl_TshirtContestUncheckedCreateInput = {
    id: number
    fname: string
    lname: string
    tel: string
    email: string
    notes: string
    artwork: string
    imgPreview: string
    ip: string
    submitTime: Date | string
  }

  export type tbl_TshirtContestUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    artwork?: StringFieldUpdateOperationsInput | string
    imgPreview?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    submitTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tbl_TshirtContestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    artwork?: StringFieldUpdateOperationsInput | string
    imgPreview?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    submitTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tbl_TshirtContestCreateManyInput = {
    id: number
    fname: string
    lname: string
    tel: string
    email: string
    notes: string
    artwork: string
    imgPreview: string
    ip: string
    submitTime: Date | string
  }

  export type tbl_TshirtContestUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    fname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    artwork?: StringFieldUpdateOperationsInput | string
    imgPreview?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    submitTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tbl_TshirtContestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fname?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    artwork?: StringFieldUpdateOperationsInput | string
    imgPreview?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    submitTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tbl_barrage_at_us_2023CreateInput = {
    barrageContent: string
  }

  export type tbl_barrage_at_us_2023UncheckedCreateInput = {
    id?: number
    barrageContent: string
  }

  export type tbl_barrage_at_us_2023UpdateInput = {
    barrageContent?: StringFieldUpdateOperationsInput | string
  }

  export type tbl_barrage_at_us_2023UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    barrageContent?: StringFieldUpdateOperationsInput | string
  }

  export type tbl_barrage_at_us_2023CreateManyInput = {
    id?: number
    barrageContent: string
  }

  export type tbl_barrage_at_us_2023UpdateManyMutationInput = {
    barrageContent?: StringFieldUpdateOperationsInput | string
  }

  export type tbl_barrage_at_us_2023UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    barrageContent?: StringFieldUpdateOperationsInput | string
  }

  export type tbl_next_authCreateInput = {
    username: string
    password: string
    email: string
    isVerified?: boolean
    isAdmin?: boolean
  }

  export type tbl_next_authUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    email: string
    isVerified?: boolean
    isAdmin?: boolean
  }

  export type tbl_next_authUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tbl_next_authUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tbl_next_authCreateManyInput = {
    id?: number
    username: string
    password: string
    email: string
    isVerified?: boolean
    isAdmin?: boolean
  }

  export type tbl_next_authUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tbl_next_authUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tbl_onlineconcert2022_donorsCreateInput = {
    donor_fname: string
    donor_lname: string
    donor_amount: number
  }

  export type tbl_onlineconcert2022_donorsUncheckedCreateInput = {
    donor_id?: number
    donor_fname: string
    donor_lname: string
    donor_amount: number
  }

  export type tbl_onlineconcert2022_donorsUpdateInput = {
    donor_fname?: StringFieldUpdateOperationsInput | string
    donor_lname?: StringFieldUpdateOperationsInput | string
    donor_amount?: IntFieldUpdateOperationsInput | number
  }

  export type tbl_onlineconcert2022_donorsUncheckedUpdateInput = {
    donor_id?: IntFieldUpdateOperationsInput | number
    donor_fname?: StringFieldUpdateOperationsInput | string
    donor_lname?: StringFieldUpdateOperationsInput | string
    donor_amount?: IntFieldUpdateOperationsInput | number
  }

  export type tbl_onlineconcert2022_donorsCreateManyInput = {
    donor_id?: number
    donor_fname: string
    donor_lname: string
    donor_amount: number
  }

  export type tbl_onlineconcert2022_donorsUpdateManyMutationInput = {
    donor_fname?: StringFieldUpdateOperationsInput | string
    donor_lname?: StringFieldUpdateOperationsInput | string
    donor_amount?: IntFieldUpdateOperationsInput | number
  }

  export type tbl_onlineconcert2022_donorsUncheckedUpdateManyInput = {
    donor_id?: IntFieldUpdateOperationsInput | number
    donor_fname?: StringFieldUpdateOperationsInput | string
    donor_lname?: StringFieldUpdateOperationsInput | string
    donor_amount?: IntFieldUpdateOperationsInput | number
  }

  export type usersCreateInput = {
    Username: string
    Password: string
  }

  export type usersUncheckedCreateInput = {
    Username: string
    Password: string
    id?: number
  }

  export type usersUpdateInput = {
    Username?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
  }

  export type usersUncheckedUpdateInput = {
    Username?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
  }

  export type usersCreateManyInput = {
    Username: string
    Password: string
    id?: number
  }

  export type usersUpdateManyMutationInput = {
    Username?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
  }

  export type usersUncheckedUpdateManyInput = {
    Username?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TBEventReg_ACM2017CountOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegAffiliate?: SortOrder
    RegPreamble?: SortOrder
    RegQuestion?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ACM2017AvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TBEventReg_ACM2017MaxOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegAffiliate?: SortOrder
    RegPreamble?: SortOrder
    RegQuestion?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ACM2017MinOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegAffiliate?: SortOrder
    RegPreamble?: SortOrder
    RegQuestion?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ACM2017SumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TBEventReg_ACM2018CountOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegAffiliate?: SortOrder
    RegPreamble?: SortOrder
    RegQuestion?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ACM2018AvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TBEventReg_ACM2018MaxOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegAffiliate?: SortOrder
    RegPreamble?: SortOrder
    RegQuestion?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ACM2018MinOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegAffiliate?: SortOrder
    RegPreamble?: SortOrder
    RegQuestion?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ACM2018SumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TBEventReg_ACM2022CountOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegAffiliate?: SortOrder
    RegPreamble?: SortOrder
    RegQuestion?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ACM2022AvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TBEventReg_ACM2022MaxOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegAffiliate?: SortOrder
    RegPreamble?: SortOrder
    RegQuestion?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ACM2022MinOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegAffiliate?: SortOrder
    RegPreamble?: SortOrder
    RegQuestion?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ACM2022SumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TBEventReg_ChessChampionship2019CountOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegNameFirst?: SortOrder
    RegNameLast?: SortOrder
    RegDOB?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    ParentNameFirst?: SortOrder
    ParentNameLast?: SortOrder
    ParentTel?: SortOrder
    ParentEmail?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ChessChampionship2019AvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TBEventReg_ChessChampionship2019MaxOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegNameFirst?: SortOrder
    RegNameLast?: SortOrder
    RegDOB?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    ParentNameFirst?: SortOrder
    ParentNameLast?: SortOrder
    ParentTel?: SortOrder
    ParentEmail?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ChessChampionship2019MinOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegNameFirst?: SortOrder
    RegNameLast?: SortOrder
    RegDOB?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    ParentNameFirst?: SortOrder
    ParentNameLast?: SortOrder
    ParentTel?: SortOrder
    ParentEmail?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_ChessChampionship2019SumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type TBEventReg_SEEE_2017CountOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
    RegLunch?: SortOrder
  }

  export type TBEventReg_SEEE_2017AvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TBEventReg_SEEE_2017MaxOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
    RegLunch?: SortOrder
  }

  export type TBEventReg_SEEE_2017MinOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
    RegLunch?: SortOrder
  }

  export type TBEventReg_SEEE_2017SumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TBEventReg_SEEE_2017_VenderInfoCountOrderByAggregateInput = {
    ID?: SortOrder
    VenderCompTitle?: SortOrder
    VenderResource?: SortOrder
    VenderEmail?: SortOrder
    VenderDescrip?: SortOrder
    VenderBooth?: SortOrder
    VenderTel?: SortOrder
    AMorPM?: SortOrder
    AM1?: SortOrder
    AM2?: SortOrder
    AM3?: SortOrder
    AM4?: SortOrder
    AM5?: SortOrder
    AM6?: SortOrder
    PM1?: SortOrder
    PM2?: SortOrder
    PM3?: SortOrder
    PM4?: SortOrder
    PM5?: SortOrder
    PM6?: SortOrder
  }

  export type TBEventReg_SEEE_2017_VenderInfoAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TBEventReg_SEEE_2017_VenderInfoMaxOrderByAggregateInput = {
    ID?: SortOrder
    VenderCompTitle?: SortOrder
    VenderResource?: SortOrder
    VenderEmail?: SortOrder
    VenderDescrip?: SortOrder
    VenderBooth?: SortOrder
    VenderTel?: SortOrder
    AMorPM?: SortOrder
    AM1?: SortOrder
    AM2?: SortOrder
    AM3?: SortOrder
    AM4?: SortOrder
    AM5?: SortOrder
    AM6?: SortOrder
    PM1?: SortOrder
    PM2?: SortOrder
    PM3?: SortOrder
    PM4?: SortOrder
    PM5?: SortOrder
    PM6?: SortOrder
  }

  export type TBEventReg_SEEE_2017_VenderInfoMinOrderByAggregateInput = {
    ID?: SortOrder
    VenderCompTitle?: SortOrder
    VenderResource?: SortOrder
    VenderEmail?: SortOrder
    VenderDescrip?: SortOrder
    VenderBooth?: SortOrder
    VenderTel?: SortOrder
    AMorPM?: SortOrder
    AM1?: SortOrder
    AM2?: SortOrder
    AM3?: SortOrder
    AM4?: SortOrder
    AM5?: SortOrder
    AM6?: SortOrder
    PM1?: SortOrder
    PM2?: SortOrder
    PM3?: SortOrder
    PM4?: SortOrder
    PM5?: SortOrder
    PM6?: SortOrder
  }

  export type TBEventReg_SEEE_2017_VenderInfoSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TBEventReg_SEEE_2018CountOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
    RegLunch?: SortOrder
  }

  export type TBEventReg_SEEE_2018AvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TBEventReg_SEEE_2018MaxOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
    RegLunch?: SortOrder
  }

  export type TBEventReg_SEEE_2018MinOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
    RegLunch?: SortOrder
  }

  export type TBEventReg_SEEE_2018SumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TBEventReg_SEEE_2018_VenderInfoCountOrderByAggregateInput = {
    ID?: SortOrder
    VenderCompTitle?: SortOrder
    VenderContactPerson?: SortOrder
    VenderResource?: SortOrder
    VenderEmail?: SortOrder
    VenderDescrip?: SortOrder
    VenderBooth?: SortOrder
    VenderTel?: SortOrder
    TimeSlot1?: SortOrder
    TimeSlot2?: SortOrder
    TimeSlot3?: SortOrder
    TimeSlot4?: SortOrder
    TimeSlot5?: SortOrder
    TimeSlot6?: SortOrder
    TimeSlot7?: SortOrder
    TimeSlot8?: SortOrder
    TimeSlot9?: SortOrder
    TimeSlot10?: SortOrder
  }

  export type TBEventReg_SEEE_2018_VenderInfoAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TBEventReg_SEEE_2018_VenderInfoMaxOrderByAggregateInput = {
    ID?: SortOrder
    VenderCompTitle?: SortOrder
    VenderContactPerson?: SortOrder
    VenderResource?: SortOrder
    VenderEmail?: SortOrder
    VenderDescrip?: SortOrder
    VenderBooth?: SortOrder
    VenderTel?: SortOrder
    TimeSlot1?: SortOrder
    TimeSlot2?: SortOrder
    TimeSlot3?: SortOrder
    TimeSlot4?: SortOrder
    TimeSlot5?: SortOrder
    TimeSlot6?: SortOrder
    TimeSlot7?: SortOrder
    TimeSlot8?: SortOrder
    TimeSlot9?: SortOrder
    TimeSlot10?: SortOrder
  }

  export type TBEventReg_SEEE_2018_VenderInfoMinOrderByAggregateInput = {
    ID?: SortOrder
    VenderCompTitle?: SortOrder
    VenderContactPerson?: SortOrder
    VenderResource?: SortOrder
    VenderEmail?: SortOrder
    VenderDescrip?: SortOrder
    VenderBooth?: SortOrder
    VenderTel?: SortOrder
    TimeSlot1?: SortOrder
    TimeSlot2?: SortOrder
    TimeSlot3?: SortOrder
    TimeSlot4?: SortOrder
    TimeSlot5?: SortOrder
    TimeSlot6?: SortOrder
    TimeSlot7?: SortOrder
    TimeSlot8?: SortOrder
    TimeSlot9?: SortOrder
    TimeSlot10?: SortOrder
  }

  export type TBEventReg_SEEE_2018_VenderInfoSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TBEventReg_SpringIntoActionCountOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_SpringIntoActionAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TBEventReg_SpringIntoActionMaxOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_SpringIntoActionMinOrderByAggregateInput = {
    ID?: SortOrder
    EventTitle?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    RegAddress?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBEventReg_SpringIntoActionSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TBInvisibleIllness2019CountOrderByAggregateInput = {
    IndexID?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    IfRCDMember?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBInvisibleIllness2019AvgOrderByAggregateInput = {
    IndexID?: SortOrder
  }

  export type TBInvisibleIllness2019MaxOrderByAggregateInput = {
    IndexID?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    IfRCDMember?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBInvisibleIllness2019MinOrderByAggregateInput = {
    IndexID?: SortOrder
    RegName?: SortOrder
    RegEmail?: SortOrder
    RegTel?: SortOrder
    IfRCDMember?: SortOrder
    RegDate?: SortOrder
    RegIP?: SortOrder
  }

  export type TBInvisibleIllness2019SumOrderByAggregateInput = {
    IndexID?: SortOrder
  }

  export type TB_2017Gala_KaraokaCountOrderByAggregateInput = {
    ID?: SortOrder
    NominatorName?: SortOrder
    NominatorTelEmail?: SortOrder
    NomineeName?: SortOrder
    NomineeTelEmail?: SortOrder
    KaraokeName?: SortOrder
    BringCD?: SortOrder
    RegDateTime?: SortOrder
  }

  export type TB_2017Gala_KaraokaAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TB_2017Gala_KaraokaMaxOrderByAggregateInput = {
    ID?: SortOrder
    NominatorName?: SortOrder
    NominatorTelEmail?: SortOrder
    NomineeName?: SortOrder
    NomineeTelEmail?: SortOrder
    KaraokeName?: SortOrder
    BringCD?: SortOrder
    RegDateTime?: SortOrder
  }

  export type TB_2017Gala_KaraokaMinOrderByAggregateInput = {
    ID?: SortOrder
    NominatorName?: SortOrder
    NominatorTelEmail?: SortOrder
    NomineeName?: SortOrder
    NomineeTelEmail?: SortOrder
    KaraokeName?: SortOrder
    BringCD?: SortOrder
    RegDateTime?: SortOrder
  }

  export type TB_2017Gala_KaraokaSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023CountOrderByAggregateInput = {
    barrage_id?: SortOrder
    barrage_content?: SortOrder
    createdAt?: SortOrder
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023AvgOrderByAggregateInput = {
    barrage_id?: SortOrder
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023MaxOrderByAggregateInput = {
    barrage_id?: SortOrder
    barrage_content?: SortOrder
    createdAt?: SortOrder
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023MinOrderByAggregateInput = {
    barrage_id?: SortOrder
    barrage_content?: SortOrder
    createdAt?: SortOrder
  }

  export type Tbl_barrage_ILAcrossCanadaDay2023SumOrderByAggregateInput = {
    barrage_id?: SortOrder
  }

  export type Auth_group_permissionsListRelationFilter = {
    every?: auth_group_permissionsWhereInput
    some?: auth_group_permissionsWhereInput
    none?: auth_group_permissionsWhereInput
  }

  export type Auth_user_groupsListRelationFilter = {
    every?: auth_user_groupsWhereInput
    some?: auth_user_groupsWhereInput
    none?: auth_user_groupsWhereInput
  }

  export type auth_group_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type auth_user_groupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type auth_groupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type auth_groupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type auth_groupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type auth_groupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type auth_groupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type Auth_permissionRelationFilter = {
    is?: auth_permissionWhereInput
    isNot?: auth_permissionWhereInput
  }

  export type Auth_groupRelationFilter = {
    is?: auth_groupWhereInput
    isNot?: auth_groupWhereInput
  }

  export type auth_group_permissionsGroup_idPermission_idCompoundUniqueInput = {
    group_id: number
    permission_id: number
  }

  export type auth_group_permissionsCountOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    permission_id?: SortOrder
  }

  export type auth_group_permissionsAvgOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    permission_id?: SortOrder
  }

  export type auth_group_permissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    permission_id?: SortOrder
  }

  export type auth_group_permissionsMinOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    permission_id?: SortOrder
  }

  export type auth_group_permissionsSumOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    permission_id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type Django_content_typeRelationFilter = {
    is?: django_content_typeWhereInput
    isNot?: django_content_typeWhereInput
  }

  export type Auth_user_user_permissionsListRelationFilter = {
    every?: auth_user_user_permissionsWhereInput
    some?: auth_user_user_permissionsWhereInput
    none?: auth_user_user_permissionsWhereInput
  }

  export type auth_user_user_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type auth_permissionContent_type_idCodenameCompoundUniqueInput = {
    content_type_id: number
    codename: string
  }

  export type auth_permissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content_type_id?: SortOrder
    codename?: SortOrder
  }

  export type auth_permissionAvgOrderByAggregateInput = {
    id?: SortOrder
    content_type_id?: SortOrder
  }

  export type auth_permissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content_type_id?: SortOrder
    codename?: SortOrder
  }

  export type auth_permissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content_type_id?: SortOrder
    codename?: SortOrder
  }

  export type auth_permissionSumOrderByAggregateInput = {
    id?: SortOrder
    content_type_id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Django_admin_logListRelationFilter = {
    every?: django_admin_logWhereInput
    some?: django_admin_logWhereInput
    none?: django_admin_logWhereInput
  }

  export type django_admin_logOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type auth_userCountOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    last_login?: SortOrder
    is_superuser?: SortOrder
    username?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    is_staff?: SortOrder
    is_active?: SortOrder
    date_joined?: SortOrder
  }

  export type auth_userAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type auth_userMaxOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    last_login?: SortOrder
    is_superuser?: SortOrder
    username?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    is_staff?: SortOrder
    is_active?: SortOrder
    date_joined?: SortOrder
  }

  export type auth_userMinOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    last_login?: SortOrder
    is_superuser?: SortOrder
    username?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    is_staff?: SortOrder
    is_active?: SortOrder
    date_joined?: SortOrder
  }

  export type auth_userSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type Auth_userRelationFilter = {
    is?: auth_userWhereInput
    isNot?: auth_userWhereInput
  }

  export type auth_user_groupsUser_idGroup_idCompoundUniqueInput = {
    user_id: number
    group_id: number
  }

  export type auth_user_groupsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    group_id?: SortOrder
  }

  export type auth_user_groupsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    group_id?: SortOrder
  }

  export type auth_user_groupsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    group_id?: SortOrder
  }

  export type auth_user_groupsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    group_id?: SortOrder
  }

  export type auth_user_groupsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    group_id?: SortOrder
  }

  export type auth_user_user_permissionsUser_idPermission_idCompoundUniqueInput = {
    user_id: number
    permission_id: number
  }

  export type auth_user_user_permissionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    permission_id?: SortOrder
  }

  export type auth_user_user_permissionsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    permission_id?: SortOrder
  }

  export type auth_user_user_permissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    permission_id?: SortOrder
  }

  export type auth_user_user_permissionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    permission_id?: SortOrder
  }

  export type auth_user_user_permissionsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    permission_id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type categoryListCountOrderByAggregateInput = {
    categorytype?: SortOrder
    hide?: SortOrder
    categoryID?: SortOrder
  }

  export type categoryListAvgOrderByAggregateInput = {
    hide?: SortOrder
    categoryID?: SortOrder
  }

  export type categoryListMaxOrderByAggregateInput = {
    categorytype?: SortOrder
    hide?: SortOrder
    categoryID?: SortOrder
  }

  export type categoryListMinOrderByAggregateInput = {
    categorytype?: SortOrder
    hide?: SortOrder
    categoryID?: SortOrder
  }

  export type categoryListSumOrderByAggregateInput = {
    hide?: SortOrder
    categoryID?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Django_content_typeNullableRelationFilter = {
    is?: django_content_typeWhereInput | null
    isNot?: django_content_typeWhereInput | null
  }

  export type django_admin_logCountOrderByAggregateInput = {
    id?: SortOrder
    action_time?: SortOrder
    object_id?: SortOrder
    object_repr?: SortOrder
    action_flag?: SortOrder
    change_message?: SortOrder
    content_type_id?: SortOrder
    user_id?: SortOrder
  }

  export type django_admin_logAvgOrderByAggregateInput = {
    id?: SortOrder
    action_flag?: SortOrder
    content_type_id?: SortOrder
    user_id?: SortOrder
  }

  export type django_admin_logMaxOrderByAggregateInput = {
    id?: SortOrder
    action_time?: SortOrder
    object_id?: SortOrder
    object_repr?: SortOrder
    action_flag?: SortOrder
    change_message?: SortOrder
    content_type_id?: SortOrder
    user_id?: SortOrder
  }

  export type django_admin_logMinOrderByAggregateInput = {
    id?: SortOrder
    action_time?: SortOrder
    object_id?: SortOrder
    object_repr?: SortOrder
    action_flag?: SortOrder
    change_message?: SortOrder
    content_type_id?: SortOrder
    user_id?: SortOrder
  }

  export type django_admin_logSumOrderByAggregateInput = {
    id?: SortOrder
    action_flag?: SortOrder
    content_type_id?: SortOrder
    user_id?: SortOrder
  }

  export type Auth_permissionListRelationFilter = {
    every?: auth_permissionWhereInput
    some?: auth_permissionWhereInput
    none?: auth_permissionWhereInput
  }

  export type auth_permissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type django_content_typeApp_labelModelCompoundUniqueInput = {
    app_label: string
    model: string
  }

  export type django_content_typeCountOrderByAggregateInput = {
    id?: SortOrder
    app_label?: SortOrder
    model?: SortOrder
  }

  export type django_content_typeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type django_content_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    app_label?: SortOrder
    model?: SortOrder
  }

  export type django_content_typeMinOrderByAggregateInput = {
    id?: SortOrder
    app_label?: SortOrder
    model?: SortOrder
  }

  export type django_content_typeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type django_migrationsCountOrderByAggregateInput = {
    id?: SortOrder
    app?: SortOrder
    name?: SortOrder
    applied?: SortOrder
  }

  export type django_migrationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type django_migrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    app?: SortOrder
    name?: SortOrder
    applied?: SortOrder
  }

  export type django_migrationsMinOrderByAggregateInput = {
    id?: SortOrder
    app?: SortOrder
    name?: SortOrder
    applied?: SortOrder
  }

  export type django_migrationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type django_sessionCountOrderByAggregateInput = {
    session_key?: SortOrder
    session_data?: SortOrder
    expire_date?: SortOrder
  }

  export type django_sessionMaxOrderByAggregateInput = {
    session_key?: SortOrder
    session_data?: SortOrder
    expire_date?: SortOrder
  }

  export type django_sessionMinOrderByAggregateInput = {
    session_key?: SortOrder
    session_data?: SortOrder
    expire_date?: SortOrder
  }

  export type eventsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    color?: SortOrder
    start?: SortOrder
    end?: SortOrder
  }

  export type eventsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    color?: SortOrder
    start?: SortOrder
    end?: SortOrder
  }

  export type eventsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    color?: SortOrder
    start?: SortOrder
    end?: SortOrder
  }

  export type eventsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type recordInfoCountOrderByAggregateInput = {
    recordInfo_ID?: SortOrder
    categoryID?: SortOrder
    Name?: SortOrder
    StreetAddress?: SortOrder
    City?: SortOrder
    PostalCode?: SortOrder
    Province?: SortOrder
    Telephone?: SortOrder
    Fax?: SortOrder
    Website?: SortOrder
  }

  export type recordInfoAvgOrderByAggregateInput = {
    recordInfo_ID?: SortOrder
    categoryID?: SortOrder
  }

  export type recordInfoMaxOrderByAggregateInput = {
    recordInfo_ID?: SortOrder
    categoryID?: SortOrder
    Name?: SortOrder
    StreetAddress?: SortOrder
    City?: SortOrder
    PostalCode?: SortOrder
    Province?: SortOrder
    Telephone?: SortOrder
    Fax?: SortOrder
    Website?: SortOrder
  }

  export type recordInfoMinOrderByAggregateInput = {
    recordInfo_ID?: SortOrder
    categoryID?: SortOrder
    Name?: SortOrder
    StreetAddress?: SortOrder
    City?: SortOrder
    PostalCode?: SortOrder
    Province?: SortOrder
    Telephone?: SortOrder
    Fax?: SortOrder
    Website?: SortOrder
  }

  export type recordInfoSumOrderByAggregateInput = {
    recordInfo_ID?: SortOrder
    categoryID?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type tbl_BMORun2024_BarrageCountOrderByAggregateInput = {
    ID?: SortOrder
    donor_Fname?: SortOrder
    donor_Lname?: SortOrder
    donor_Org?: SortOrder
    donor_Amount?: SortOrder
    createdAt?: SortOrder
  }

  export type tbl_BMORun2024_BarrageAvgOrderByAggregateInput = {
    ID?: SortOrder
    donor_Amount?: SortOrder
  }

  export type tbl_BMORun2024_BarrageMaxOrderByAggregateInput = {
    ID?: SortOrder
    donor_Fname?: SortOrder
    donor_Lname?: SortOrder
    donor_Org?: SortOrder
    donor_Amount?: SortOrder
    createdAt?: SortOrder
  }

  export type tbl_BMORun2024_BarrageMinOrderByAggregateInput = {
    ID?: SortOrder
    donor_Fname?: SortOrder
    donor_Lname?: SortOrder
    donor_Org?: SortOrder
    donor_Amount?: SortOrder
    createdAt?: SortOrder
  }

  export type tbl_BMORun2024_BarrageSumOrderByAggregateInput = {
    ID?: SortOrder
    donor_Amount?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type tbl_ETransferInfoCountOrderByAggregateInput = {
    id?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    userAddress?: SortOrder
    userTel?: SortOrder
    useremail?: SortOrder
    todaydate?: SortOrder
    RegDate?: SortOrder
    RegTime?: SortOrder
    userIP?: SortOrder
  }

  export type tbl_ETransferInfoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tbl_ETransferInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    userAddress?: SortOrder
    userTel?: SortOrder
    useremail?: SortOrder
    todaydate?: SortOrder
    RegDate?: SortOrder
    RegTime?: SortOrder
    userIP?: SortOrder
  }

  export type tbl_ETransferInfoMinOrderByAggregateInput = {
    id?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    userAddress?: SortOrder
    userTel?: SortOrder
    useremail?: SortOrder
    todaydate?: SortOrder
    RegDate?: SortOrder
    RegTime?: SortOrder
    userIP?: SortOrder
  }

  export type tbl_ETransferInfoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tbl_TshirtContestCountOrderByAggregateInput = {
    id?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    tel?: SortOrder
    email?: SortOrder
    notes?: SortOrder
    artwork?: SortOrder
    imgPreview?: SortOrder
    ip?: SortOrder
    submitTime?: SortOrder
  }

  export type tbl_TshirtContestAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tbl_TshirtContestMaxOrderByAggregateInput = {
    id?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    tel?: SortOrder
    email?: SortOrder
    notes?: SortOrder
    artwork?: SortOrder
    imgPreview?: SortOrder
    ip?: SortOrder
    submitTime?: SortOrder
  }

  export type tbl_TshirtContestMinOrderByAggregateInput = {
    id?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    tel?: SortOrder
    email?: SortOrder
    notes?: SortOrder
    artwork?: SortOrder
    imgPreview?: SortOrder
    ip?: SortOrder
    submitTime?: SortOrder
  }

  export type tbl_TshirtContestSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tbl_barrage_at_us_2023CountOrderByAggregateInput = {
    id?: SortOrder
    barrageContent?: SortOrder
  }

  export type tbl_barrage_at_us_2023AvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tbl_barrage_at_us_2023MaxOrderByAggregateInput = {
    id?: SortOrder
    barrageContent?: SortOrder
  }

  export type tbl_barrage_at_us_2023MinOrderByAggregateInput = {
    id?: SortOrder
    barrageContent?: SortOrder
  }

  export type tbl_barrage_at_us_2023SumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tbl_next_authCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    isVerified?: SortOrder
    isAdmin?: SortOrder
  }

  export type tbl_next_authAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tbl_next_authMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    isVerified?: SortOrder
    isAdmin?: SortOrder
  }

  export type tbl_next_authMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    isVerified?: SortOrder
    isAdmin?: SortOrder
  }

  export type tbl_next_authSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tbl_onlineconcert2022_donorsCountOrderByAggregateInput = {
    donor_id?: SortOrder
    donor_fname?: SortOrder
    donor_lname?: SortOrder
    donor_amount?: SortOrder
  }

  export type tbl_onlineconcert2022_donorsAvgOrderByAggregateInput = {
    donor_id?: SortOrder
    donor_amount?: SortOrder
  }

  export type tbl_onlineconcert2022_donorsMaxOrderByAggregateInput = {
    donor_id?: SortOrder
    donor_fname?: SortOrder
    donor_lname?: SortOrder
    donor_amount?: SortOrder
  }

  export type tbl_onlineconcert2022_donorsMinOrderByAggregateInput = {
    donor_id?: SortOrder
    donor_fname?: SortOrder
    donor_lname?: SortOrder
    donor_amount?: SortOrder
  }

  export type tbl_onlineconcert2022_donorsSumOrderByAggregateInput = {
    donor_id?: SortOrder
    donor_amount?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    Username?: SortOrder
    Password?: SortOrder
    id?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    Username?: SortOrder
    Password?: SortOrder
    id?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    Username?: SortOrder
    Password?: SortOrder
    id?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type auth_group_permissionsCreateNestedManyWithoutAuth_groupInput = {
    create?: XOR<Enumerable<auth_group_permissionsCreateWithoutAuth_groupInput>, Enumerable<auth_group_permissionsUncheckedCreateWithoutAuth_groupInput>>
    connectOrCreate?: Enumerable<auth_group_permissionsCreateOrConnectWithoutAuth_groupInput>
    createMany?: auth_group_permissionsCreateManyAuth_groupInputEnvelope
    connect?: Enumerable<auth_group_permissionsWhereUniqueInput>
  }

  export type auth_user_groupsCreateNestedManyWithoutAuth_groupInput = {
    create?: XOR<Enumerable<auth_user_groupsCreateWithoutAuth_groupInput>, Enumerable<auth_user_groupsUncheckedCreateWithoutAuth_groupInput>>
    connectOrCreate?: Enumerable<auth_user_groupsCreateOrConnectWithoutAuth_groupInput>
    createMany?: auth_user_groupsCreateManyAuth_groupInputEnvelope
    connect?: Enumerable<auth_user_groupsWhereUniqueInput>
  }

  export type auth_group_permissionsUncheckedCreateNestedManyWithoutAuth_groupInput = {
    create?: XOR<Enumerable<auth_group_permissionsCreateWithoutAuth_groupInput>, Enumerable<auth_group_permissionsUncheckedCreateWithoutAuth_groupInput>>
    connectOrCreate?: Enumerable<auth_group_permissionsCreateOrConnectWithoutAuth_groupInput>
    createMany?: auth_group_permissionsCreateManyAuth_groupInputEnvelope
    connect?: Enumerable<auth_group_permissionsWhereUniqueInput>
  }

  export type auth_user_groupsUncheckedCreateNestedManyWithoutAuth_groupInput = {
    create?: XOR<Enumerable<auth_user_groupsCreateWithoutAuth_groupInput>, Enumerable<auth_user_groupsUncheckedCreateWithoutAuth_groupInput>>
    connectOrCreate?: Enumerable<auth_user_groupsCreateOrConnectWithoutAuth_groupInput>
    createMany?: auth_user_groupsCreateManyAuth_groupInputEnvelope
    connect?: Enumerable<auth_user_groupsWhereUniqueInput>
  }

  export type auth_group_permissionsUpdateManyWithoutAuth_groupNestedInput = {
    create?: XOR<Enumerable<auth_group_permissionsCreateWithoutAuth_groupInput>, Enumerable<auth_group_permissionsUncheckedCreateWithoutAuth_groupInput>>
    connectOrCreate?: Enumerable<auth_group_permissionsCreateOrConnectWithoutAuth_groupInput>
    upsert?: Enumerable<auth_group_permissionsUpsertWithWhereUniqueWithoutAuth_groupInput>
    createMany?: auth_group_permissionsCreateManyAuth_groupInputEnvelope
    set?: Enumerable<auth_group_permissionsWhereUniqueInput>
    disconnect?: Enumerable<auth_group_permissionsWhereUniqueInput>
    delete?: Enumerable<auth_group_permissionsWhereUniqueInput>
    connect?: Enumerable<auth_group_permissionsWhereUniqueInput>
    update?: Enumerable<auth_group_permissionsUpdateWithWhereUniqueWithoutAuth_groupInput>
    updateMany?: Enumerable<auth_group_permissionsUpdateManyWithWhereWithoutAuth_groupInput>
    deleteMany?: Enumerable<auth_group_permissionsScalarWhereInput>
  }

  export type auth_user_groupsUpdateManyWithoutAuth_groupNestedInput = {
    create?: XOR<Enumerable<auth_user_groupsCreateWithoutAuth_groupInput>, Enumerable<auth_user_groupsUncheckedCreateWithoutAuth_groupInput>>
    connectOrCreate?: Enumerable<auth_user_groupsCreateOrConnectWithoutAuth_groupInput>
    upsert?: Enumerable<auth_user_groupsUpsertWithWhereUniqueWithoutAuth_groupInput>
    createMany?: auth_user_groupsCreateManyAuth_groupInputEnvelope
    set?: Enumerable<auth_user_groupsWhereUniqueInput>
    disconnect?: Enumerable<auth_user_groupsWhereUniqueInput>
    delete?: Enumerable<auth_user_groupsWhereUniqueInput>
    connect?: Enumerable<auth_user_groupsWhereUniqueInput>
    update?: Enumerable<auth_user_groupsUpdateWithWhereUniqueWithoutAuth_groupInput>
    updateMany?: Enumerable<auth_user_groupsUpdateManyWithWhereWithoutAuth_groupInput>
    deleteMany?: Enumerable<auth_user_groupsScalarWhereInput>
  }

  export type auth_group_permissionsUncheckedUpdateManyWithoutAuth_groupNestedInput = {
    create?: XOR<Enumerable<auth_group_permissionsCreateWithoutAuth_groupInput>, Enumerable<auth_group_permissionsUncheckedCreateWithoutAuth_groupInput>>
    connectOrCreate?: Enumerable<auth_group_permissionsCreateOrConnectWithoutAuth_groupInput>
    upsert?: Enumerable<auth_group_permissionsUpsertWithWhereUniqueWithoutAuth_groupInput>
    createMany?: auth_group_permissionsCreateManyAuth_groupInputEnvelope
    set?: Enumerable<auth_group_permissionsWhereUniqueInput>
    disconnect?: Enumerable<auth_group_permissionsWhereUniqueInput>
    delete?: Enumerable<auth_group_permissionsWhereUniqueInput>
    connect?: Enumerable<auth_group_permissionsWhereUniqueInput>
    update?: Enumerable<auth_group_permissionsUpdateWithWhereUniqueWithoutAuth_groupInput>
    updateMany?: Enumerable<auth_group_permissionsUpdateManyWithWhereWithoutAuth_groupInput>
    deleteMany?: Enumerable<auth_group_permissionsScalarWhereInput>
  }

  export type auth_user_groupsUncheckedUpdateManyWithoutAuth_groupNestedInput = {
    create?: XOR<Enumerable<auth_user_groupsCreateWithoutAuth_groupInput>, Enumerable<auth_user_groupsUncheckedCreateWithoutAuth_groupInput>>
    connectOrCreate?: Enumerable<auth_user_groupsCreateOrConnectWithoutAuth_groupInput>
    upsert?: Enumerable<auth_user_groupsUpsertWithWhereUniqueWithoutAuth_groupInput>
    createMany?: auth_user_groupsCreateManyAuth_groupInputEnvelope
    set?: Enumerable<auth_user_groupsWhereUniqueInput>
    disconnect?: Enumerable<auth_user_groupsWhereUniqueInput>
    delete?: Enumerable<auth_user_groupsWhereUniqueInput>
    connect?: Enumerable<auth_user_groupsWhereUniqueInput>
    update?: Enumerable<auth_user_groupsUpdateWithWhereUniqueWithoutAuth_groupInput>
    updateMany?: Enumerable<auth_user_groupsUpdateManyWithWhereWithoutAuth_groupInput>
    deleteMany?: Enumerable<auth_user_groupsScalarWhereInput>
  }

  export type auth_permissionCreateNestedOneWithoutAuth_group_permissionsInput = {
    create?: XOR<auth_permissionCreateWithoutAuth_group_permissionsInput, auth_permissionUncheckedCreateWithoutAuth_group_permissionsInput>
    connectOrCreate?: auth_permissionCreateOrConnectWithoutAuth_group_permissionsInput
    connect?: auth_permissionWhereUniqueInput
  }

  export type auth_groupCreateNestedOneWithoutAuth_group_permissionsInput = {
    create?: XOR<auth_groupCreateWithoutAuth_group_permissionsInput, auth_groupUncheckedCreateWithoutAuth_group_permissionsInput>
    connectOrCreate?: auth_groupCreateOrConnectWithoutAuth_group_permissionsInput
    connect?: auth_groupWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type auth_permissionUpdateOneRequiredWithoutAuth_group_permissionsNestedInput = {
    create?: XOR<auth_permissionCreateWithoutAuth_group_permissionsInput, auth_permissionUncheckedCreateWithoutAuth_group_permissionsInput>
    connectOrCreate?: auth_permissionCreateOrConnectWithoutAuth_group_permissionsInput
    upsert?: auth_permissionUpsertWithoutAuth_group_permissionsInput
    connect?: auth_permissionWhereUniqueInput
    update?: XOR<XOR<auth_permissionUpdateToOneWithWhereWithoutAuth_group_permissionsInput, auth_permissionUpdateWithoutAuth_group_permissionsInput>, auth_permissionUncheckedUpdateWithoutAuth_group_permissionsInput>
  }

  export type auth_groupUpdateOneRequiredWithoutAuth_group_permissionsNestedInput = {
    create?: XOR<auth_groupCreateWithoutAuth_group_permissionsInput, auth_groupUncheckedCreateWithoutAuth_group_permissionsInput>
    connectOrCreate?: auth_groupCreateOrConnectWithoutAuth_group_permissionsInput
    upsert?: auth_groupUpsertWithoutAuth_group_permissionsInput
    connect?: auth_groupWhereUniqueInput
    update?: XOR<XOR<auth_groupUpdateToOneWithWhereWithoutAuth_group_permissionsInput, auth_groupUpdateWithoutAuth_group_permissionsInput>, auth_groupUncheckedUpdateWithoutAuth_group_permissionsInput>
  }

  export type auth_group_permissionsCreateNestedManyWithoutAuth_permissionInput = {
    create?: XOR<Enumerable<auth_group_permissionsCreateWithoutAuth_permissionInput>, Enumerable<auth_group_permissionsUncheckedCreateWithoutAuth_permissionInput>>
    connectOrCreate?: Enumerable<auth_group_permissionsCreateOrConnectWithoutAuth_permissionInput>
    createMany?: auth_group_permissionsCreateManyAuth_permissionInputEnvelope
    connect?: Enumerable<auth_group_permissionsWhereUniqueInput>
  }

  export type django_content_typeCreateNestedOneWithoutAuth_permissionInput = {
    create?: XOR<django_content_typeCreateWithoutAuth_permissionInput, django_content_typeUncheckedCreateWithoutAuth_permissionInput>
    connectOrCreate?: django_content_typeCreateOrConnectWithoutAuth_permissionInput
    connect?: django_content_typeWhereUniqueInput
  }

  export type auth_user_user_permissionsCreateNestedManyWithoutAuth_permissionInput = {
    create?: XOR<Enumerable<auth_user_user_permissionsCreateWithoutAuth_permissionInput>, Enumerable<auth_user_user_permissionsUncheckedCreateWithoutAuth_permissionInput>>
    connectOrCreate?: Enumerable<auth_user_user_permissionsCreateOrConnectWithoutAuth_permissionInput>
    createMany?: auth_user_user_permissionsCreateManyAuth_permissionInputEnvelope
    connect?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
  }

  export type auth_group_permissionsUncheckedCreateNestedManyWithoutAuth_permissionInput = {
    create?: XOR<Enumerable<auth_group_permissionsCreateWithoutAuth_permissionInput>, Enumerable<auth_group_permissionsUncheckedCreateWithoutAuth_permissionInput>>
    connectOrCreate?: Enumerable<auth_group_permissionsCreateOrConnectWithoutAuth_permissionInput>
    createMany?: auth_group_permissionsCreateManyAuth_permissionInputEnvelope
    connect?: Enumerable<auth_group_permissionsWhereUniqueInput>
  }

  export type auth_user_user_permissionsUncheckedCreateNestedManyWithoutAuth_permissionInput = {
    create?: XOR<Enumerable<auth_user_user_permissionsCreateWithoutAuth_permissionInput>, Enumerable<auth_user_user_permissionsUncheckedCreateWithoutAuth_permissionInput>>
    connectOrCreate?: Enumerable<auth_user_user_permissionsCreateOrConnectWithoutAuth_permissionInput>
    createMany?: auth_user_user_permissionsCreateManyAuth_permissionInputEnvelope
    connect?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
  }

  export type auth_group_permissionsUpdateManyWithoutAuth_permissionNestedInput = {
    create?: XOR<Enumerable<auth_group_permissionsCreateWithoutAuth_permissionInput>, Enumerable<auth_group_permissionsUncheckedCreateWithoutAuth_permissionInput>>
    connectOrCreate?: Enumerable<auth_group_permissionsCreateOrConnectWithoutAuth_permissionInput>
    upsert?: Enumerable<auth_group_permissionsUpsertWithWhereUniqueWithoutAuth_permissionInput>
    createMany?: auth_group_permissionsCreateManyAuth_permissionInputEnvelope
    set?: Enumerable<auth_group_permissionsWhereUniqueInput>
    disconnect?: Enumerable<auth_group_permissionsWhereUniqueInput>
    delete?: Enumerable<auth_group_permissionsWhereUniqueInput>
    connect?: Enumerable<auth_group_permissionsWhereUniqueInput>
    update?: Enumerable<auth_group_permissionsUpdateWithWhereUniqueWithoutAuth_permissionInput>
    updateMany?: Enumerable<auth_group_permissionsUpdateManyWithWhereWithoutAuth_permissionInput>
    deleteMany?: Enumerable<auth_group_permissionsScalarWhereInput>
  }

  export type django_content_typeUpdateOneRequiredWithoutAuth_permissionNestedInput = {
    create?: XOR<django_content_typeCreateWithoutAuth_permissionInput, django_content_typeUncheckedCreateWithoutAuth_permissionInput>
    connectOrCreate?: django_content_typeCreateOrConnectWithoutAuth_permissionInput
    upsert?: django_content_typeUpsertWithoutAuth_permissionInput
    connect?: django_content_typeWhereUniqueInput
    update?: XOR<XOR<django_content_typeUpdateToOneWithWhereWithoutAuth_permissionInput, django_content_typeUpdateWithoutAuth_permissionInput>, django_content_typeUncheckedUpdateWithoutAuth_permissionInput>
  }

  export type auth_user_user_permissionsUpdateManyWithoutAuth_permissionNestedInput = {
    create?: XOR<Enumerable<auth_user_user_permissionsCreateWithoutAuth_permissionInput>, Enumerable<auth_user_user_permissionsUncheckedCreateWithoutAuth_permissionInput>>
    connectOrCreate?: Enumerable<auth_user_user_permissionsCreateOrConnectWithoutAuth_permissionInput>
    upsert?: Enumerable<auth_user_user_permissionsUpsertWithWhereUniqueWithoutAuth_permissionInput>
    createMany?: auth_user_user_permissionsCreateManyAuth_permissionInputEnvelope
    set?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    disconnect?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    delete?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    connect?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    update?: Enumerable<auth_user_user_permissionsUpdateWithWhereUniqueWithoutAuth_permissionInput>
    updateMany?: Enumerable<auth_user_user_permissionsUpdateManyWithWhereWithoutAuth_permissionInput>
    deleteMany?: Enumerable<auth_user_user_permissionsScalarWhereInput>
  }

  export type auth_group_permissionsUncheckedUpdateManyWithoutAuth_permissionNestedInput = {
    create?: XOR<Enumerable<auth_group_permissionsCreateWithoutAuth_permissionInput>, Enumerable<auth_group_permissionsUncheckedCreateWithoutAuth_permissionInput>>
    connectOrCreate?: Enumerable<auth_group_permissionsCreateOrConnectWithoutAuth_permissionInput>
    upsert?: Enumerable<auth_group_permissionsUpsertWithWhereUniqueWithoutAuth_permissionInput>
    createMany?: auth_group_permissionsCreateManyAuth_permissionInputEnvelope
    set?: Enumerable<auth_group_permissionsWhereUniqueInput>
    disconnect?: Enumerable<auth_group_permissionsWhereUniqueInput>
    delete?: Enumerable<auth_group_permissionsWhereUniqueInput>
    connect?: Enumerable<auth_group_permissionsWhereUniqueInput>
    update?: Enumerable<auth_group_permissionsUpdateWithWhereUniqueWithoutAuth_permissionInput>
    updateMany?: Enumerable<auth_group_permissionsUpdateManyWithWhereWithoutAuth_permissionInput>
    deleteMany?: Enumerable<auth_group_permissionsScalarWhereInput>
  }

  export type auth_user_user_permissionsUncheckedUpdateManyWithoutAuth_permissionNestedInput = {
    create?: XOR<Enumerable<auth_user_user_permissionsCreateWithoutAuth_permissionInput>, Enumerable<auth_user_user_permissionsUncheckedCreateWithoutAuth_permissionInput>>
    connectOrCreate?: Enumerable<auth_user_user_permissionsCreateOrConnectWithoutAuth_permissionInput>
    upsert?: Enumerable<auth_user_user_permissionsUpsertWithWhereUniqueWithoutAuth_permissionInput>
    createMany?: auth_user_user_permissionsCreateManyAuth_permissionInputEnvelope
    set?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    disconnect?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    delete?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    connect?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    update?: Enumerable<auth_user_user_permissionsUpdateWithWhereUniqueWithoutAuth_permissionInput>
    updateMany?: Enumerable<auth_user_user_permissionsUpdateManyWithWhereWithoutAuth_permissionInput>
    deleteMany?: Enumerable<auth_user_user_permissionsScalarWhereInput>
  }

  export type auth_user_groupsCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<Enumerable<auth_user_groupsCreateWithoutAuth_userInput>, Enumerable<auth_user_groupsUncheckedCreateWithoutAuth_userInput>>
    connectOrCreate?: Enumerable<auth_user_groupsCreateOrConnectWithoutAuth_userInput>
    createMany?: auth_user_groupsCreateManyAuth_userInputEnvelope
    connect?: Enumerable<auth_user_groupsWhereUniqueInput>
  }

  export type auth_user_user_permissionsCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<Enumerable<auth_user_user_permissionsCreateWithoutAuth_userInput>, Enumerable<auth_user_user_permissionsUncheckedCreateWithoutAuth_userInput>>
    connectOrCreate?: Enumerable<auth_user_user_permissionsCreateOrConnectWithoutAuth_userInput>
    createMany?: auth_user_user_permissionsCreateManyAuth_userInputEnvelope
    connect?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
  }

  export type django_admin_logCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<Enumerable<django_admin_logCreateWithoutAuth_userInput>, Enumerable<django_admin_logUncheckedCreateWithoutAuth_userInput>>
    connectOrCreate?: Enumerable<django_admin_logCreateOrConnectWithoutAuth_userInput>
    createMany?: django_admin_logCreateManyAuth_userInputEnvelope
    connect?: Enumerable<django_admin_logWhereUniqueInput>
  }

  export type auth_user_groupsUncheckedCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<Enumerable<auth_user_groupsCreateWithoutAuth_userInput>, Enumerable<auth_user_groupsUncheckedCreateWithoutAuth_userInput>>
    connectOrCreate?: Enumerable<auth_user_groupsCreateOrConnectWithoutAuth_userInput>
    createMany?: auth_user_groupsCreateManyAuth_userInputEnvelope
    connect?: Enumerable<auth_user_groupsWhereUniqueInput>
  }

  export type auth_user_user_permissionsUncheckedCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<Enumerable<auth_user_user_permissionsCreateWithoutAuth_userInput>, Enumerable<auth_user_user_permissionsUncheckedCreateWithoutAuth_userInput>>
    connectOrCreate?: Enumerable<auth_user_user_permissionsCreateOrConnectWithoutAuth_userInput>
    createMany?: auth_user_user_permissionsCreateManyAuth_userInputEnvelope
    connect?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
  }

  export type django_admin_logUncheckedCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<Enumerable<django_admin_logCreateWithoutAuth_userInput>, Enumerable<django_admin_logUncheckedCreateWithoutAuth_userInput>>
    connectOrCreate?: Enumerable<django_admin_logCreateOrConnectWithoutAuth_userInput>
    createMany?: django_admin_logCreateManyAuth_userInputEnvelope
    connect?: Enumerable<django_admin_logWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type auth_user_groupsUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<Enumerable<auth_user_groupsCreateWithoutAuth_userInput>, Enumerable<auth_user_groupsUncheckedCreateWithoutAuth_userInput>>
    connectOrCreate?: Enumerable<auth_user_groupsCreateOrConnectWithoutAuth_userInput>
    upsert?: Enumerable<auth_user_groupsUpsertWithWhereUniqueWithoutAuth_userInput>
    createMany?: auth_user_groupsCreateManyAuth_userInputEnvelope
    set?: Enumerable<auth_user_groupsWhereUniqueInput>
    disconnect?: Enumerable<auth_user_groupsWhereUniqueInput>
    delete?: Enumerable<auth_user_groupsWhereUniqueInput>
    connect?: Enumerable<auth_user_groupsWhereUniqueInput>
    update?: Enumerable<auth_user_groupsUpdateWithWhereUniqueWithoutAuth_userInput>
    updateMany?: Enumerable<auth_user_groupsUpdateManyWithWhereWithoutAuth_userInput>
    deleteMany?: Enumerable<auth_user_groupsScalarWhereInput>
  }

  export type auth_user_user_permissionsUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<Enumerable<auth_user_user_permissionsCreateWithoutAuth_userInput>, Enumerable<auth_user_user_permissionsUncheckedCreateWithoutAuth_userInput>>
    connectOrCreate?: Enumerable<auth_user_user_permissionsCreateOrConnectWithoutAuth_userInput>
    upsert?: Enumerable<auth_user_user_permissionsUpsertWithWhereUniqueWithoutAuth_userInput>
    createMany?: auth_user_user_permissionsCreateManyAuth_userInputEnvelope
    set?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    disconnect?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    delete?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    connect?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    update?: Enumerable<auth_user_user_permissionsUpdateWithWhereUniqueWithoutAuth_userInput>
    updateMany?: Enumerable<auth_user_user_permissionsUpdateManyWithWhereWithoutAuth_userInput>
    deleteMany?: Enumerable<auth_user_user_permissionsScalarWhereInput>
  }

  export type django_admin_logUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<Enumerable<django_admin_logCreateWithoutAuth_userInput>, Enumerable<django_admin_logUncheckedCreateWithoutAuth_userInput>>
    connectOrCreate?: Enumerable<django_admin_logCreateOrConnectWithoutAuth_userInput>
    upsert?: Enumerable<django_admin_logUpsertWithWhereUniqueWithoutAuth_userInput>
    createMany?: django_admin_logCreateManyAuth_userInputEnvelope
    set?: Enumerable<django_admin_logWhereUniqueInput>
    disconnect?: Enumerable<django_admin_logWhereUniqueInput>
    delete?: Enumerable<django_admin_logWhereUniqueInput>
    connect?: Enumerable<django_admin_logWhereUniqueInput>
    update?: Enumerable<django_admin_logUpdateWithWhereUniqueWithoutAuth_userInput>
    updateMany?: Enumerable<django_admin_logUpdateManyWithWhereWithoutAuth_userInput>
    deleteMany?: Enumerable<django_admin_logScalarWhereInput>
  }

  export type auth_user_groupsUncheckedUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<Enumerable<auth_user_groupsCreateWithoutAuth_userInput>, Enumerable<auth_user_groupsUncheckedCreateWithoutAuth_userInput>>
    connectOrCreate?: Enumerable<auth_user_groupsCreateOrConnectWithoutAuth_userInput>
    upsert?: Enumerable<auth_user_groupsUpsertWithWhereUniqueWithoutAuth_userInput>
    createMany?: auth_user_groupsCreateManyAuth_userInputEnvelope
    set?: Enumerable<auth_user_groupsWhereUniqueInput>
    disconnect?: Enumerable<auth_user_groupsWhereUniqueInput>
    delete?: Enumerable<auth_user_groupsWhereUniqueInput>
    connect?: Enumerable<auth_user_groupsWhereUniqueInput>
    update?: Enumerable<auth_user_groupsUpdateWithWhereUniqueWithoutAuth_userInput>
    updateMany?: Enumerable<auth_user_groupsUpdateManyWithWhereWithoutAuth_userInput>
    deleteMany?: Enumerable<auth_user_groupsScalarWhereInput>
  }

  export type auth_user_user_permissionsUncheckedUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<Enumerable<auth_user_user_permissionsCreateWithoutAuth_userInput>, Enumerable<auth_user_user_permissionsUncheckedCreateWithoutAuth_userInput>>
    connectOrCreate?: Enumerable<auth_user_user_permissionsCreateOrConnectWithoutAuth_userInput>
    upsert?: Enumerable<auth_user_user_permissionsUpsertWithWhereUniqueWithoutAuth_userInput>
    createMany?: auth_user_user_permissionsCreateManyAuth_userInputEnvelope
    set?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    disconnect?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    delete?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    connect?: Enumerable<auth_user_user_permissionsWhereUniqueInput>
    update?: Enumerable<auth_user_user_permissionsUpdateWithWhereUniqueWithoutAuth_userInput>
    updateMany?: Enumerable<auth_user_user_permissionsUpdateManyWithWhereWithoutAuth_userInput>
    deleteMany?: Enumerable<auth_user_user_permissionsScalarWhereInput>
  }

  export type django_admin_logUncheckedUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<Enumerable<django_admin_logCreateWithoutAuth_userInput>, Enumerable<django_admin_logUncheckedCreateWithoutAuth_userInput>>
    connectOrCreate?: Enumerable<django_admin_logCreateOrConnectWithoutAuth_userInput>
    upsert?: Enumerable<django_admin_logUpsertWithWhereUniqueWithoutAuth_userInput>
    createMany?: django_admin_logCreateManyAuth_userInputEnvelope
    set?: Enumerable<django_admin_logWhereUniqueInput>
    disconnect?: Enumerable<django_admin_logWhereUniqueInput>
    delete?: Enumerable<django_admin_logWhereUniqueInput>
    connect?: Enumerable<django_admin_logWhereUniqueInput>
    update?: Enumerable<django_admin_logUpdateWithWhereUniqueWithoutAuth_userInput>
    updateMany?: Enumerable<django_admin_logUpdateManyWithWhereWithoutAuth_userInput>
    deleteMany?: Enumerable<django_admin_logScalarWhereInput>
  }

  export type auth_groupCreateNestedOneWithoutAuth_user_groupsInput = {
    create?: XOR<auth_groupCreateWithoutAuth_user_groupsInput, auth_groupUncheckedCreateWithoutAuth_user_groupsInput>
    connectOrCreate?: auth_groupCreateOrConnectWithoutAuth_user_groupsInput
    connect?: auth_groupWhereUniqueInput
  }

  export type auth_userCreateNestedOneWithoutAuth_user_groupsInput = {
    create?: XOR<auth_userCreateWithoutAuth_user_groupsInput, auth_userUncheckedCreateWithoutAuth_user_groupsInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutAuth_user_groupsInput
    connect?: auth_userWhereUniqueInput
  }

  export type auth_groupUpdateOneRequiredWithoutAuth_user_groupsNestedInput = {
    create?: XOR<auth_groupCreateWithoutAuth_user_groupsInput, auth_groupUncheckedCreateWithoutAuth_user_groupsInput>
    connectOrCreate?: auth_groupCreateOrConnectWithoutAuth_user_groupsInput
    upsert?: auth_groupUpsertWithoutAuth_user_groupsInput
    connect?: auth_groupWhereUniqueInput
    update?: XOR<XOR<auth_groupUpdateToOneWithWhereWithoutAuth_user_groupsInput, auth_groupUpdateWithoutAuth_user_groupsInput>, auth_groupUncheckedUpdateWithoutAuth_user_groupsInput>
  }

  export type auth_userUpdateOneRequiredWithoutAuth_user_groupsNestedInput = {
    create?: XOR<auth_userCreateWithoutAuth_user_groupsInput, auth_userUncheckedCreateWithoutAuth_user_groupsInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutAuth_user_groupsInput
    upsert?: auth_userUpsertWithoutAuth_user_groupsInput
    connect?: auth_userWhereUniqueInput
    update?: XOR<XOR<auth_userUpdateToOneWithWhereWithoutAuth_user_groupsInput, auth_userUpdateWithoutAuth_user_groupsInput>, auth_userUncheckedUpdateWithoutAuth_user_groupsInput>
  }

  export type auth_permissionCreateNestedOneWithoutAuth_user_user_permissionsInput = {
    create?: XOR<auth_permissionCreateWithoutAuth_user_user_permissionsInput, auth_permissionUncheckedCreateWithoutAuth_user_user_permissionsInput>
    connectOrCreate?: auth_permissionCreateOrConnectWithoutAuth_user_user_permissionsInput
    connect?: auth_permissionWhereUniqueInput
  }

  export type auth_userCreateNestedOneWithoutAuth_user_user_permissionsInput = {
    create?: XOR<auth_userCreateWithoutAuth_user_user_permissionsInput, auth_userUncheckedCreateWithoutAuth_user_user_permissionsInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutAuth_user_user_permissionsInput
    connect?: auth_userWhereUniqueInput
  }

  export type auth_permissionUpdateOneRequiredWithoutAuth_user_user_permissionsNestedInput = {
    create?: XOR<auth_permissionCreateWithoutAuth_user_user_permissionsInput, auth_permissionUncheckedCreateWithoutAuth_user_user_permissionsInput>
    connectOrCreate?: auth_permissionCreateOrConnectWithoutAuth_user_user_permissionsInput
    upsert?: auth_permissionUpsertWithoutAuth_user_user_permissionsInput
    connect?: auth_permissionWhereUniqueInput
    update?: XOR<XOR<auth_permissionUpdateToOneWithWhereWithoutAuth_user_user_permissionsInput, auth_permissionUpdateWithoutAuth_user_user_permissionsInput>, auth_permissionUncheckedUpdateWithoutAuth_user_user_permissionsInput>
  }

  export type auth_userUpdateOneRequiredWithoutAuth_user_user_permissionsNestedInput = {
    create?: XOR<auth_userCreateWithoutAuth_user_user_permissionsInput, auth_userUncheckedCreateWithoutAuth_user_user_permissionsInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutAuth_user_user_permissionsInput
    upsert?: auth_userUpsertWithoutAuth_user_user_permissionsInput
    connect?: auth_userWhereUniqueInput
    update?: XOR<XOR<auth_userUpdateToOneWithWhereWithoutAuth_user_user_permissionsInput, auth_userUpdateWithoutAuth_user_user_permissionsInput>, auth_userUncheckedUpdateWithoutAuth_user_user_permissionsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type django_content_typeCreateNestedOneWithoutDjango_admin_logInput = {
    create?: XOR<django_content_typeCreateWithoutDjango_admin_logInput, django_content_typeUncheckedCreateWithoutDjango_admin_logInput>
    connectOrCreate?: django_content_typeCreateOrConnectWithoutDjango_admin_logInput
    connect?: django_content_typeWhereUniqueInput
  }

  export type auth_userCreateNestedOneWithoutDjango_admin_logInput = {
    create?: XOR<auth_userCreateWithoutDjango_admin_logInput, auth_userUncheckedCreateWithoutDjango_admin_logInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutDjango_admin_logInput
    connect?: auth_userWhereUniqueInput
  }

  export type django_content_typeUpdateOneWithoutDjango_admin_logNestedInput = {
    create?: XOR<django_content_typeCreateWithoutDjango_admin_logInput, django_content_typeUncheckedCreateWithoutDjango_admin_logInput>
    connectOrCreate?: django_content_typeCreateOrConnectWithoutDjango_admin_logInput
    upsert?: django_content_typeUpsertWithoutDjango_admin_logInput
    disconnect?: django_content_typeWhereInput | boolean
    delete?: django_content_typeWhereInput | boolean
    connect?: django_content_typeWhereUniqueInput
    update?: XOR<XOR<django_content_typeUpdateToOneWithWhereWithoutDjango_admin_logInput, django_content_typeUpdateWithoutDjango_admin_logInput>, django_content_typeUncheckedUpdateWithoutDjango_admin_logInput>
  }

  export type auth_userUpdateOneRequiredWithoutDjango_admin_logNestedInput = {
    create?: XOR<auth_userCreateWithoutDjango_admin_logInput, auth_userUncheckedCreateWithoutDjango_admin_logInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutDjango_admin_logInput
    upsert?: auth_userUpsertWithoutDjango_admin_logInput
    connect?: auth_userWhereUniqueInput
    update?: XOR<XOR<auth_userUpdateToOneWithWhereWithoutDjango_admin_logInput, auth_userUpdateWithoutDjango_admin_logInput>, auth_userUncheckedUpdateWithoutDjango_admin_logInput>
  }

  export type auth_permissionCreateNestedManyWithoutDjango_content_typeInput = {
    create?: XOR<Enumerable<auth_permissionCreateWithoutDjango_content_typeInput>, Enumerable<auth_permissionUncheckedCreateWithoutDjango_content_typeInput>>
    connectOrCreate?: Enumerable<auth_permissionCreateOrConnectWithoutDjango_content_typeInput>
    createMany?: auth_permissionCreateManyDjango_content_typeInputEnvelope
    connect?: Enumerable<auth_permissionWhereUniqueInput>
  }

  export type django_admin_logCreateNestedManyWithoutDjango_content_typeInput = {
    create?: XOR<Enumerable<django_admin_logCreateWithoutDjango_content_typeInput>, Enumerable<django_admin_logUncheckedCreateWithoutDjango_content_typeInput>>
    connectOrCreate?: Enumerable<django_admin_logCreateOrConnectWithoutDjango_content_typeInput>
    createMany?: django_admin_logCreateManyDjango_content_typeInputEnvelope
    connect?: Enumerable<django_admin_logWhereUniqueInput>
  }

  export type auth_permissionUncheckedCreateNestedManyWithoutDjango_content_typeInput = {
    create?: XOR<Enumerable<auth_permissionCreateWithoutDjango_content_typeInput>, Enumerable<auth_permissionUncheckedCreateWithoutDjango_content_typeInput>>
    connectOrCreate?: Enumerable<auth_permissionCreateOrConnectWithoutDjango_content_typeInput>
    createMany?: auth_permissionCreateManyDjango_content_typeInputEnvelope
    connect?: Enumerable<auth_permissionWhereUniqueInput>
  }

  export type django_admin_logUncheckedCreateNestedManyWithoutDjango_content_typeInput = {
    create?: XOR<Enumerable<django_admin_logCreateWithoutDjango_content_typeInput>, Enumerable<django_admin_logUncheckedCreateWithoutDjango_content_typeInput>>
    connectOrCreate?: Enumerable<django_admin_logCreateOrConnectWithoutDjango_content_typeInput>
    createMany?: django_admin_logCreateManyDjango_content_typeInputEnvelope
    connect?: Enumerable<django_admin_logWhereUniqueInput>
  }

  export type auth_permissionUpdateManyWithoutDjango_content_typeNestedInput = {
    create?: XOR<Enumerable<auth_permissionCreateWithoutDjango_content_typeInput>, Enumerable<auth_permissionUncheckedCreateWithoutDjango_content_typeInput>>
    connectOrCreate?: Enumerable<auth_permissionCreateOrConnectWithoutDjango_content_typeInput>
    upsert?: Enumerable<auth_permissionUpsertWithWhereUniqueWithoutDjango_content_typeInput>
    createMany?: auth_permissionCreateManyDjango_content_typeInputEnvelope
    set?: Enumerable<auth_permissionWhereUniqueInput>
    disconnect?: Enumerable<auth_permissionWhereUniqueInput>
    delete?: Enumerable<auth_permissionWhereUniqueInput>
    connect?: Enumerable<auth_permissionWhereUniqueInput>
    update?: Enumerable<auth_permissionUpdateWithWhereUniqueWithoutDjango_content_typeInput>
    updateMany?: Enumerable<auth_permissionUpdateManyWithWhereWithoutDjango_content_typeInput>
    deleteMany?: Enumerable<auth_permissionScalarWhereInput>
  }

  export type django_admin_logUpdateManyWithoutDjango_content_typeNestedInput = {
    create?: XOR<Enumerable<django_admin_logCreateWithoutDjango_content_typeInput>, Enumerable<django_admin_logUncheckedCreateWithoutDjango_content_typeInput>>
    connectOrCreate?: Enumerable<django_admin_logCreateOrConnectWithoutDjango_content_typeInput>
    upsert?: Enumerable<django_admin_logUpsertWithWhereUniqueWithoutDjango_content_typeInput>
    createMany?: django_admin_logCreateManyDjango_content_typeInputEnvelope
    set?: Enumerable<django_admin_logWhereUniqueInput>
    disconnect?: Enumerable<django_admin_logWhereUniqueInput>
    delete?: Enumerable<django_admin_logWhereUniqueInput>
    connect?: Enumerable<django_admin_logWhereUniqueInput>
    update?: Enumerable<django_admin_logUpdateWithWhereUniqueWithoutDjango_content_typeInput>
    updateMany?: Enumerable<django_admin_logUpdateManyWithWhereWithoutDjango_content_typeInput>
    deleteMany?: Enumerable<django_admin_logScalarWhereInput>
  }

  export type auth_permissionUncheckedUpdateManyWithoutDjango_content_typeNestedInput = {
    create?: XOR<Enumerable<auth_permissionCreateWithoutDjango_content_typeInput>, Enumerable<auth_permissionUncheckedCreateWithoutDjango_content_typeInput>>
    connectOrCreate?: Enumerable<auth_permissionCreateOrConnectWithoutDjango_content_typeInput>
    upsert?: Enumerable<auth_permissionUpsertWithWhereUniqueWithoutDjango_content_typeInput>
    createMany?: auth_permissionCreateManyDjango_content_typeInputEnvelope
    set?: Enumerable<auth_permissionWhereUniqueInput>
    disconnect?: Enumerable<auth_permissionWhereUniqueInput>
    delete?: Enumerable<auth_permissionWhereUniqueInput>
    connect?: Enumerable<auth_permissionWhereUniqueInput>
    update?: Enumerable<auth_permissionUpdateWithWhereUniqueWithoutDjango_content_typeInput>
    updateMany?: Enumerable<auth_permissionUpdateManyWithWhereWithoutDjango_content_typeInput>
    deleteMany?: Enumerable<auth_permissionScalarWhereInput>
  }

  export type django_admin_logUncheckedUpdateManyWithoutDjango_content_typeNestedInput = {
    create?: XOR<Enumerable<django_admin_logCreateWithoutDjango_content_typeInput>, Enumerable<django_admin_logUncheckedCreateWithoutDjango_content_typeInput>>
    connectOrCreate?: Enumerable<django_admin_logCreateOrConnectWithoutDjango_content_typeInput>
    upsert?: Enumerable<django_admin_logUpsertWithWhereUniqueWithoutDjango_content_typeInput>
    createMany?: django_admin_logCreateManyDjango_content_typeInputEnvelope
    set?: Enumerable<django_admin_logWhereUniqueInput>
    disconnect?: Enumerable<django_admin_logWhereUniqueInput>
    delete?: Enumerable<django_admin_logWhereUniqueInput>
    connect?: Enumerable<django_admin_logWhereUniqueInput>
    update?: Enumerable<django_admin_logUpdateWithWhereUniqueWithoutDjango_content_typeInput>
    updateMany?: Enumerable<django_admin_logUpdateManyWithWhereWithoutDjango_content_typeInput>
    deleteMany?: Enumerable<django_admin_logScalarWhereInput>
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type auth_group_permissionsCreateWithoutAuth_groupInput = {
    id?: bigint | number
    auth_permission: auth_permissionCreateNestedOneWithoutAuth_group_permissionsInput
  }

  export type auth_group_permissionsUncheckedCreateWithoutAuth_groupInput = {
    id?: bigint | number
    permission_id: number
  }

  export type auth_group_permissionsCreateOrConnectWithoutAuth_groupInput = {
    where: auth_group_permissionsWhereUniqueInput
    create: XOR<auth_group_permissionsCreateWithoutAuth_groupInput, auth_group_permissionsUncheckedCreateWithoutAuth_groupInput>
  }

  export type auth_group_permissionsCreateManyAuth_groupInputEnvelope = {
    data: Enumerable<auth_group_permissionsCreateManyAuth_groupInput>
    skipDuplicates?: boolean
  }

  export type auth_user_groupsCreateWithoutAuth_groupInput = {
    id?: bigint | number
    auth_user: auth_userCreateNestedOneWithoutAuth_user_groupsInput
  }

  export type auth_user_groupsUncheckedCreateWithoutAuth_groupInput = {
    id?: bigint | number
    user_id: number
  }

  export type auth_user_groupsCreateOrConnectWithoutAuth_groupInput = {
    where: auth_user_groupsWhereUniqueInput
    create: XOR<auth_user_groupsCreateWithoutAuth_groupInput, auth_user_groupsUncheckedCreateWithoutAuth_groupInput>
  }

  export type auth_user_groupsCreateManyAuth_groupInputEnvelope = {
    data: Enumerable<auth_user_groupsCreateManyAuth_groupInput>
    skipDuplicates?: boolean
  }

  export type auth_group_permissionsUpsertWithWhereUniqueWithoutAuth_groupInput = {
    where: auth_group_permissionsWhereUniqueInput
    update: XOR<auth_group_permissionsUpdateWithoutAuth_groupInput, auth_group_permissionsUncheckedUpdateWithoutAuth_groupInput>
    create: XOR<auth_group_permissionsCreateWithoutAuth_groupInput, auth_group_permissionsUncheckedCreateWithoutAuth_groupInput>
  }

  export type auth_group_permissionsUpdateWithWhereUniqueWithoutAuth_groupInput = {
    where: auth_group_permissionsWhereUniqueInput
    data: XOR<auth_group_permissionsUpdateWithoutAuth_groupInput, auth_group_permissionsUncheckedUpdateWithoutAuth_groupInput>
  }

  export type auth_group_permissionsUpdateManyWithWhereWithoutAuth_groupInput = {
    where: auth_group_permissionsScalarWhereInput
    data: XOR<auth_group_permissionsUpdateManyMutationInput, auth_group_permissionsUncheckedUpdateManyWithoutAuth_groupInput>
  }

  export type auth_group_permissionsScalarWhereInput = {
    AND?: Enumerable<auth_group_permissionsScalarWhereInput>
    OR?: Enumerable<auth_group_permissionsScalarWhereInput>
    NOT?: Enumerable<auth_group_permissionsScalarWhereInput>
    id?: BigIntFilter<"auth_group_permissions"> | bigint | number
    group_id?: IntFilter<"auth_group_permissions"> | number
    permission_id?: IntFilter<"auth_group_permissions"> | number
  }

  export type auth_user_groupsUpsertWithWhereUniqueWithoutAuth_groupInput = {
    where: auth_user_groupsWhereUniqueInput
    update: XOR<auth_user_groupsUpdateWithoutAuth_groupInput, auth_user_groupsUncheckedUpdateWithoutAuth_groupInput>
    create: XOR<auth_user_groupsCreateWithoutAuth_groupInput, auth_user_groupsUncheckedCreateWithoutAuth_groupInput>
  }

  export type auth_user_groupsUpdateWithWhereUniqueWithoutAuth_groupInput = {
    where: auth_user_groupsWhereUniqueInput
    data: XOR<auth_user_groupsUpdateWithoutAuth_groupInput, auth_user_groupsUncheckedUpdateWithoutAuth_groupInput>
  }

  export type auth_user_groupsUpdateManyWithWhereWithoutAuth_groupInput = {
    where: auth_user_groupsScalarWhereInput
    data: XOR<auth_user_groupsUpdateManyMutationInput, auth_user_groupsUncheckedUpdateManyWithoutAuth_groupInput>
  }

  export type auth_user_groupsScalarWhereInput = {
    AND?: Enumerable<auth_user_groupsScalarWhereInput>
    OR?: Enumerable<auth_user_groupsScalarWhereInput>
    NOT?: Enumerable<auth_user_groupsScalarWhereInput>
    id?: BigIntFilter<"auth_user_groups"> | bigint | number
    user_id?: IntFilter<"auth_user_groups"> | number
    group_id?: IntFilter<"auth_user_groups"> | number
  }

  export type auth_permissionCreateWithoutAuth_group_permissionsInput = {
    name: string
    codename: string
    django_content_type: django_content_typeCreateNestedOneWithoutAuth_permissionInput
    auth_user_user_permissions?: auth_user_user_permissionsCreateNestedManyWithoutAuth_permissionInput
  }

  export type auth_permissionUncheckedCreateWithoutAuth_group_permissionsInput = {
    id?: number
    name: string
    content_type_id: number
    codename: string
    auth_user_user_permissions?: auth_user_user_permissionsUncheckedCreateNestedManyWithoutAuth_permissionInput
  }

  export type auth_permissionCreateOrConnectWithoutAuth_group_permissionsInput = {
    where: auth_permissionWhereUniqueInput
    create: XOR<auth_permissionCreateWithoutAuth_group_permissionsInput, auth_permissionUncheckedCreateWithoutAuth_group_permissionsInput>
  }

  export type auth_groupCreateWithoutAuth_group_permissionsInput = {
    name: string
    auth_user_groups?: auth_user_groupsCreateNestedManyWithoutAuth_groupInput
  }

  export type auth_groupUncheckedCreateWithoutAuth_group_permissionsInput = {
    id?: number
    name: string
    auth_user_groups?: auth_user_groupsUncheckedCreateNestedManyWithoutAuth_groupInput
  }

  export type auth_groupCreateOrConnectWithoutAuth_group_permissionsInput = {
    where: auth_groupWhereUniqueInput
    create: XOR<auth_groupCreateWithoutAuth_group_permissionsInput, auth_groupUncheckedCreateWithoutAuth_group_permissionsInput>
  }

  export type auth_permissionUpsertWithoutAuth_group_permissionsInput = {
    update: XOR<auth_permissionUpdateWithoutAuth_group_permissionsInput, auth_permissionUncheckedUpdateWithoutAuth_group_permissionsInput>
    create: XOR<auth_permissionCreateWithoutAuth_group_permissionsInput, auth_permissionUncheckedCreateWithoutAuth_group_permissionsInput>
    where?: auth_permissionWhereInput
  }

  export type auth_permissionUpdateToOneWithWhereWithoutAuth_group_permissionsInput = {
    where?: auth_permissionWhereInput
    data: XOR<auth_permissionUpdateWithoutAuth_group_permissionsInput, auth_permissionUncheckedUpdateWithoutAuth_group_permissionsInput>
  }

  export type auth_permissionUpdateWithoutAuth_group_permissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    codename?: StringFieldUpdateOperationsInput | string
    django_content_type?: django_content_typeUpdateOneRequiredWithoutAuth_permissionNestedInput
    auth_user_user_permissions?: auth_user_user_permissionsUpdateManyWithoutAuth_permissionNestedInput
  }

  export type auth_permissionUncheckedUpdateWithoutAuth_group_permissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content_type_id?: IntFieldUpdateOperationsInput | number
    codename?: StringFieldUpdateOperationsInput | string
    auth_user_user_permissions?: auth_user_user_permissionsUncheckedUpdateManyWithoutAuth_permissionNestedInput
  }

  export type auth_groupUpsertWithoutAuth_group_permissionsInput = {
    update: XOR<auth_groupUpdateWithoutAuth_group_permissionsInput, auth_groupUncheckedUpdateWithoutAuth_group_permissionsInput>
    create: XOR<auth_groupCreateWithoutAuth_group_permissionsInput, auth_groupUncheckedCreateWithoutAuth_group_permissionsInput>
    where?: auth_groupWhereInput
  }

  export type auth_groupUpdateToOneWithWhereWithoutAuth_group_permissionsInput = {
    where?: auth_groupWhereInput
    data: XOR<auth_groupUpdateWithoutAuth_group_permissionsInput, auth_groupUncheckedUpdateWithoutAuth_group_permissionsInput>
  }

  export type auth_groupUpdateWithoutAuth_group_permissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    auth_user_groups?: auth_user_groupsUpdateManyWithoutAuth_groupNestedInput
  }

  export type auth_groupUncheckedUpdateWithoutAuth_group_permissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    auth_user_groups?: auth_user_groupsUncheckedUpdateManyWithoutAuth_groupNestedInput
  }

  export type auth_group_permissionsCreateWithoutAuth_permissionInput = {
    id?: bigint | number
    auth_group: auth_groupCreateNestedOneWithoutAuth_group_permissionsInput
  }

  export type auth_group_permissionsUncheckedCreateWithoutAuth_permissionInput = {
    id?: bigint | number
    group_id: number
  }

  export type auth_group_permissionsCreateOrConnectWithoutAuth_permissionInput = {
    where: auth_group_permissionsWhereUniqueInput
    create: XOR<auth_group_permissionsCreateWithoutAuth_permissionInput, auth_group_permissionsUncheckedCreateWithoutAuth_permissionInput>
  }

  export type auth_group_permissionsCreateManyAuth_permissionInputEnvelope = {
    data: Enumerable<auth_group_permissionsCreateManyAuth_permissionInput>
    skipDuplicates?: boolean
  }

  export type django_content_typeCreateWithoutAuth_permissionInput = {
    app_label: string
    model: string
    django_admin_log?: django_admin_logCreateNestedManyWithoutDjango_content_typeInput
  }

  export type django_content_typeUncheckedCreateWithoutAuth_permissionInput = {
    id?: number
    app_label: string
    model: string
    django_admin_log?: django_admin_logUncheckedCreateNestedManyWithoutDjango_content_typeInput
  }

  export type django_content_typeCreateOrConnectWithoutAuth_permissionInput = {
    where: django_content_typeWhereUniqueInput
    create: XOR<django_content_typeCreateWithoutAuth_permissionInput, django_content_typeUncheckedCreateWithoutAuth_permissionInput>
  }

  export type auth_user_user_permissionsCreateWithoutAuth_permissionInput = {
    id?: bigint | number
    auth_user: auth_userCreateNestedOneWithoutAuth_user_user_permissionsInput
  }

  export type auth_user_user_permissionsUncheckedCreateWithoutAuth_permissionInput = {
    id?: bigint | number
    user_id: number
  }

  export type auth_user_user_permissionsCreateOrConnectWithoutAuth_permissionInput = {
    where: auth_user_user_permissionsWhereUniqueInput
    create: XOR<auth_user_user_permissionsCreateWithoutAuth_permissionInput, auth_user_user_permissionsUncheckedCreateWithoutAuth_permissionInput>
  }

  export type auth_user_user_permissionsCreateManyAuth_permissionInputEnvelope = {
    data: Enumerable<auth_user_user_permissionsCreateManyAuth_permissionInput>
    skipDuplicates?: boolean
  }

  export type auth_group_permissionsUpsertWithWhereUniqueWithoutAuth_permissionInput = {
    where: auth_group_permissionsWhereUniqueInput
    update: XOR<auth_group_permissionsUpdateWithoutAuth_permissionInput, auth_group_permissionsUncheckedUpdateWithoutAuth_permissionInput>
    create: XOR<auth_group_permissionsCreateWithoutAuth_permissionInput, auth_group_permissionsUncheckedCreateWithoutAuth_permissionInput>
  }

  export type auth_group_permissionsUpdateWithWhereUniqueWithoutAuth_permissionInput = {
    where: auth_group_permissionsWhereUniqueInput
    data: XOR<auth_group_permissionsUpdateWithoutAuth_permissionInput, auth_group_permissionsUncheckedUpdateWithoutAuth_permissionInput>
  }

  export type auth_group_permissionsUpdateManyWithWhereWithoutAuth_permissionInput = {
    where: auth_group_permissionsScalarWhereInput
    data: XOR<auth_group_permissionsUpdateManyMutationInput, auth_group_permissionsUncheckedUpdateManyWithoutAuth_permissionInput>
  }

  export type django_content_typeUpsertWithoutAuth_permissionInput = {
    update: XOR<django_content_typeUpdateWithoutAuth_permissionInput, django_content_typeUncheckedUpdateWithoutAuth_permissionInput>
    create: XOR<django_content_typeCreateWithoutAuth_permissionInput, django_content_typeUncheckedCreateWithoutAuth_permissionInput>
    where?: django_content_typeWhereInput
  }

  export type django_content_typeUpdateToOneWithWhereWithoutAuth_permissionInput = {
    where?: django_content_typeWhereInput
    data: XOR<django_content_typeUpdateWithoutAuth_permissionInput, django_content_typeUncheckedUpdateWithoutAuth_permissionInput>
  }

  export type django_content_typeUpdateWithoutAuth_permissionInput = {
    app_label?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    django_admin_log?: django_admin_logUpdateManyWithoutDjango_content_typeNestedInput
  }

  export type django_content_typeUncheckedUpdateWithoutAuth_permissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    app_label?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    django_admin_log?: django_admin_logUncheckedUpdateManyWithoutDjango_content_typeNestedInput
  }

  export type auth_user_user_permissionsUpsertWithWhereUniqueWithoutAuth_permissionInput = {
    where: auth_user_user_permissionsWhereUniqueInput
    update: XOR<auth_user_user_permissionsUpdateWithoutAuth_permissionInput, auth_user_user_permissionsUncheckedUpdateWithoutAuth_permissionInput>
    create: XOR<auth_user_user_permissionsCreateWithoutAuth_permissionInput, auth_user_user_permissionsUncheckedCreateWithoutAuth_permissionInput>
  }

  export type auth_user_user_permissionsUpdateWithWhereUniqueWithoutAuth_permissionInput = {
    where: auth_user_user_permissionsWhereUniqueInput
    data: XOR<auth_user_user_permissionsUpdateWithoutAuth_permissionInput, auth_user_user_permissionsUncheckedUpdateWithoutAuth_permissionInput>
  }

  export type auth_user_user_permissionsUpdateManyWithWhereWithoutAuth_permissionInput = {
    where: auth_user_user_permissionsScalarWhereInput
    data: XOR<auth_user_user_permissionsUpdateManyMutationInput, auth_user_user_permissionsUncheckedUpdateManyWithoutAuth_permissionInput>
  }

  export type auth_user_user_permissionsScalarWhereInput = {
    AND?: Enumerable<auth_user_user_permissionsScalarWhereInput>
    OR?: Enumerable<auth_user_user_permissionsScalarWhereInput>
    NOT?: Enumerable<auth_user_user_permissionsScalarWhereInput>
    id?: BigIntFilter<"auth_user_user_permissions"> | bigint | number
    user_id?: IntFilter<"auth_user_user_permissions"> | number
    permission_id?: IntFilter<"auth_user_user_permissions"> | number
  }

  export type auth_user_groupsCreateWithoutAuth_userInput = {
    id?: bigint | number
    auth_group: auth_groupCreateNestedOneWithoutAuth_user_groupsInput
  }

  export type auth_user_groupsUncheckedCreateWithoutAuth_userInput = {
    id?: bigint | number
    group_id: number
  }

  export type auth_user_groupsCreateOrConnectWithoutAuth_userInput = {
    where: auth_user_groupsWhereUniqueInput
    create: XOR<auth_user_groupsCreateWithoutAuth_userInput, auth_user_groupsUncheckedCreateWithoutAuth_userInput>
  }

  export type auth_user_groupsCreateManyAuth_userInputEnvelope = {
    data: Enumerable<auth_user_groupsCreateManyAuth_userInput>
    skipDuplicates?: boolean
  }

  export type auth_user_user_permissionsCreateWithoutAuth_userInput = {
    id?: bigint | number
    auth_permission: auth_permissionCreateNestedOneWithoutAuth_user_user_permissionsInput
  }

  export type auth_user_user_permissionsUncheckedCreateWithoutAuth_userInput = {
    id?: bigint | number
    permission_id: number
  }

  export type auth_user_user_permissionsCreateOrConnectWithoutAuth_userInput = {
    where: auth_user_user_permissionsWhereUniqueInput
    create: XOR<auth_user_user_permissionsCreateWithoutAuth_userInput, auth_user_user_permissionsUncheckedCreateWithoutAuth_userInput>
  }

  export type auth_user_user_permissionsCreateManyAuth_userInputEnvelope = {
    data: Enumerable<auth_user_user_permissionsCreateManyAuth_userInput>
    skipDuplicates?: boolean
  }

  export type django_admin_logCreateWithoutAuth_userInput = {
    action_time: Date | string
    object_id?: string | null
    object_repr: string
    action_flag: number
    change_message: string
    django_content_type?: django_content_typeCreateNestedOneWithoutDjango_admin_logInput
  }

  export type django_admin_logUncheckedCreateWithoutAuth_userInput = {
    id?: number
    action_time: Date | string
    object_id?: string | null
    object_repr: string
    action_flag: number
    change_message: string
    content_type_id?: number | null
  }

  export type django_admin_logCreateOrConnectWithoutAuth_userInput = {
    where: django_admin_logWhereUniqueInput
    create: XOR<django_admin_logCreateWithoutAuth_userInput, django_admin_logUncheckedCreateWithoutAuth_userInput>
  }

  export type django_admin_logCreateManyAuth_userInputEnvelope = {
    data: Enumerable<django_admin_logCreateManyAuth_userInput>
    skipDuplicates?: boolean
  }

  export type auth_user_groupsUpsertWithWhereUniqueWithoutAuth_userInput = {
    where: auth_user_groupsWhereUniqueInput
    update: XOR<auth_user_groupsUpdateWithoutAuth_userInput, auth_user_groupsUncheckedUpdateWithoutAuth_userInput>
    create: XOR<auth_user_groupsCreateWithoutAuth_userInput, auth_user_groupsUncheckedCreateWithoutAuth_userInput>
  }

  export type auth_user_groupsUpdateWithWhereUniqueWithoutAuth_userInput = {
    where: auth_user_groupsWhereUniqueInput
    data: XOR<auth_user_groupsUpdateWithoutAuth_userInput, auth_user_groupsUncheckedUpdateWithoutAuth_userInput>
  }

  export type auth_user_groupsUpdateManyWithWhereWithoutAuth_userInput = {
    where: auth_user_groupsScalarWhereInput
    data: XOR<auth_user_groupsUpdateManyMutationInput, auth_user_groupsUncheckedUpdateManyWithoutAuth_userInput>
  }

  export type auth_user_user_permissionsUpsertWithWhereUniqueWithoutAuth_userInput = {
    where: auth_user_user_permissionsWhereUniqueInput
    update: XOR<auth_user_user_permissionsUpdateWithoutAuth_userInput, auth_user_user_permissionsUncheckedUpdateWithoutAuth_userInput>
    create: XOR<auth_user_user_permissionsCreateWithoutAuth_userInput, auth_user_user_permissionsUncheckedCreateWithoutAuth_userInput>
  }

  export type auth_user_user_permissionsUpdateWithWhereUniqueWithoutAuth_userInput = {
    where: auth_user_user_permissionsWhereUniqueInput
    data: XOR<auth_user_user_permissionsUpdateWithoutAuth_userInput, auth_user_user_permissionsUncheckedUpdateWithoutAuth_userInput>
  }

  export type auth_user_user_permissionsUpdateManyWithWhereWithoutAuth_userInput = {
    where: auth_user_user_permissionsScalarWhereInput
    data: XOR<auth_user_user_permissionsUpdateManyMutationInput, auth_user_user_permissionsUncheckedUpdateManyWithoutAuth_userInput>
  }

  export type django_admin_logUpsertWithWhereUniqueWithoutAuth_userInput = {
    where: django_admin_logWhereUniqueInput
    update: XOR<django_admin_logUpdateWithoutAuth_userInput, django_admin_logUncheckedUpdateWithoutAuth_userInput>
    create: XOR<django_admin_logCreateWithoutAuth_userInput, django_admin_logUncheckedCreateWithoutAuth_userInput>
  }

  export type django_admin_logUpdateWithWhereUniqueWithoutAuth_userInput = {
    where: django_admin_logWhereUniqueInput
    data: XOR<django_admin_logUpdateWithoutAuth_userInput, django_admin_logUncheckedUpdateWithoutAuth_userInput>
  }

  export type django_admin_logUpdateManyWithWhereWithoutAuth_userInput = {
    where: django_admin_logScalarWhereInput
    data: XOR<django_admin_logUpdateManyMutationInput, django_admin_logUncheckedUpdateManyWithoutAuth_userInput>
  }

  export type django_admin_logScalarWhereInput = {
    AND?: Enumerable<django_admin_logScalarWhereInput>
    OR?: Enumerable<django_admin_logScalarWhereInput>
    NOT?: Enumerable<django_admin_logScalarWhereInput>
    id?: IntFilter<"django_admin_log"> | number
    action_time?: DateTimeFilter<"django_admin_log"> | Date | string
    object_id?: StringNullableFilter<"django_admin_log"> | string | null
    object_repr?: StringFilter<"django_admin_log"> | string
    action_flag?: IntFilter<"django_admin_log"> | number
    change_message?: StringFilter<"django_admin_log"> | string
    content_type_id?: IntNullableFilter<"django_admin_log"> | number | null
    user_id?: IntFilter<"django_admin_log"> | number
  }

  export type auth_groupCreateWithoutAuth_user_groupsInput = {
    name: string
    auth_group_permissions?: auth_group_permissionsCreateNestedManyWithoutAuth_groupInput
  }

  export type auth_groupUncheckedCreateWithoutAuth_user_groupsInput = {
    id?: number
    name: string
    auth_group_permissions?: auth_group_permissionsUncheckedCreateNestedManyWithoutAuth_groupInput
  }

  export type auth_groupCreateOrConnectWithoutAuth_user_groupsInput = {
    where: auth_groupWhereUniqueInput
    create: XOR<auth_groupCreateWithoutAuth_user_groupsInput, auth_groupUncheckedCreateWithoutAuth_user_groupsInput>
  }

  export type auth_userCreateWithoutAuth_user_groupsInput = {
    password: string
    last_login?: Date | string | null
    is_superuser: boolean
    username: string
    first_name: string
    last_name: string
    email: string
    is_staff: boolean
    is_active: boolean
    date_joined: Date | string
    auth_user_user_permissions?: auth_user_user_permissionsCreateNestedManyWithoutAuth_userInput
    django_admin_log?: django_admin_logCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateWithoutAuth_user_groupsInput = {
    id?: number
    password: string
    last_login?: Date | string | null
    is_superuser: boolean
    username: string
    first_name: string
    last_name: string
    email: string
    is_staff: boolean
    is_active: boolean
    date_joined: Date | string
    auth_user_user_permissions?: auth_user_user_permissionsUncheckedCreateNestedManyWithoutAuth_userInput
    django_admin_log?: django_admin_logUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userCreateOrConnectWithoutAuth_user_groupsInput = {
    where: auth_userWhereUniqueInput
    create: XOR<auth_userCreateWithoutAuth_user_groupsInput, auth_userUncheckedCreateWithoutAuth_user_groupsInput>
  }

  export type auth_groupUpsertWithoutAuth_user_groupsInput = {
    update: XOR<auth_groupUpdateWithoutAuth_user_groupsInput, auth_groupUncheckedUpdateWithoutAuth_user_groupsInput>
    create: XOR<auth_groupCreateWithoutAuth_user_groupsInput, auth_groupUncheckedCreateWithoutAuth_user_groupsInput>
    where?: auth_groupWhereInput
  }

  export type auth_groupUpdateToOneWithWhereWithoutAuth_user_groupsInput = {
    where?: auth_groupWhereInput
    data: XOR<auth_groupUpdateWithoutAuth_user_groupsInput, auth_groupUncheckedUpdateWithoutAuth_user_groupsInput>
  }

  export type auth_groupUpdateWithoutAuth_user_groupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    auth_group_permissions?: auth_group_permissionsUpdateManyWithoutAuth_groupNestedInput
  }

  export type auth_groupUncheckedUpdateWithoutAuth_user_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    auth_group_permissions?: auth_group_permissionsUncheckedUpdateManyWithoutAuth_groupNestedInput
  }

  export type auth_userUpsertWithoutAuth_user_groupsInput = {
    update: XOR<auth_userUpdateWithoutAuth_user_groupsInput, auth_userUncheckedUpdateWithoutAuth_user_groupsInput>
    create: XOR<auth_userCreateWithoutAuth_user_groupsInput, auth_userUncheckedCreateWithoutAuth_user_groupsInput>
    where?: auth_userWhereInput
  }

  export type auth_userUpdateToOneWithWhereWithoutAuth_user_groupsInput = {
    where?: auth_userWhereInput
    data: XOR<auth_userUpdateWithoutAuth_user_groupsInput, auth_userUncheckedUpdateWithoutAuth_user_groupsInput>
  }

  export type auth_userUpdateWithoutAuth_user_groupsInput = {
    password?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_superuser?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_staff?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    auth_user_user_permissions?: auth_user_user_permissionsUpdateManyWithoutAuth_userNestedInput
    django_admin_log?: django_admin_logUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateWithoutAuth_user_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_superuser?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_staff?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    auth_user_user_permissions?: auth_user_user_permissionsUncheckedUpdateManyWithoutAuth_userNestedInput
    django_admin_log?: django_admin_logUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_permissionCreateWithoutAuth_user_user_permissionsInput = {
    name: string
    codename: string
    auth_group_permissions?: auth_group_permissionsCreateNestedManyWithoutAuth_permissionInput
    django_content_type: django_content_typeCreateNestedOneWithoutAuth_permissionInput
  }

  export type auth_permissionUncheckedCreateWithoutAuth_user_user_permissionsInput = {
    id?: number
    name: string
    content_type_id: number
    codename: string
    auth_group_permissions?: auth_group_permissionsUncheckedCreateNestedManyWithoutAuth_permissionInput
  }

  export type auth_permissionCreateOrConnectWithoutAuth_user_user_permissionsInput = {
    where: auth_permissionWhereUniqueInput
    create: XOR<auth_permissionCreateWithoutAuth_user_user_permissionsInput, auth_permissionUncheckedCreateWithoutAuth_user_user_permissionsInput>
  }

  export type auth_userCreateWithoutAuth_user_user_permissionsInput = {
    password: string
    last_login?: Date | string | null
    is_superuser: boolean
    username: string
    first_name: string
    last_name: string
    email: string
    is_staff: boolean
    is_active: boolean
    date_joined: Date | string
    auth_user_groups?: auth_user_groupsCreateNestedManyWithoutAuth_userInput
    django_admin_log?: django_admin_logCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateWithoutAuth_user_user_permissionsInput = {
    id?: number
    password: string
    last_login?: Date | string | null
    is_superuser: boolean
    username: string
    first_name: string
    last_name: string
    email: string
    is_staff: boolean
    is_active: boolean
    date_joined: Date | string
    auth_user_groups?: auth_user_groupsUncheckedCreateNestedManyWithoutAuth_userInput
    django_admin_log?: django_admin_logUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userCreateOrConnectWithoutAuth_user_user_permissionsInput = {
    where: auth_userWhereUniqueInput
    create: XOR<auth_userCreateWithoutAuth_user_user_permissionsInput, auth_userUncheckedCreateWithoutAuth_user_user_permissionsInput>
  }

  export type auth_permissionUpsertWithoutAuth_user_user_permissionsInput = {
    update: XOR<auth_permissionUpdateWithoutAuth_user_user_permissionsInput, auth_permissionUncheckedUpdateWithoutAuth_user_user_permissionsInput>
    create: XOR<auth_permissionCreateWithoutAuth_user_user_permissionsInput, auth_permissionUncheckedCreateWithoutAuth_user_user_permissionsInput>
    where?: auth_permissionWhereInput
  }

  export type auth_permissionUpdateToOneWithWhereWithoutAuth_user_user_permissionsInput = {
    where?: auth_permissionWhereInput
    data: XOR<auth_permissionUpdateWithoutAuth_user_user_permissionsInput, auth_permissionUncheckedUpdateWithoutAuth_user_user_permissionsInput>
  }

  export type auth_permissionUpdateWithoutAuth_user_user_permissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    codename?: StringFieldUpdateOperationsInput | string
    auth_group_permissions?: auth_group_permissionsUpdateManyWithoutAuth_permissionNestedInput
    django_content_type?: django_content_typeUpdateOneRequiredWithoutAuth_permissionNestedInput
  }

  export type auth_permissionUncheckedUpdateWithoutAuth_user_user_permissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content_type_id?: IntFieldUpdateOperationsInput | number
    codename?: StringFieldUpdateOperationsInput | string
    auth_group_permissions?: auth_group_permissionsUncheckedUpdateManyWithoutAuth_permissionNestedInput
  }

  export type auth_userUpsertWithoutAuth_user_user_permissionsInput = {
    update: XOR<auth_userUpdateWithoutAuth_user_user_permissionsInput, auth_userUncheckedUpdateWithoutAuth_user_user_permissionsInput>
    create: XOR<auth_userCreateWithoutAuth_user_user_permissionsInput, auth_userUncheckedCreateWithoutAuth_user_user_permissionsInput>
    where?: auth_userWhereInput
  }

  export type auth_userUpdateToOneWithWhereWithoutAuth_user_user_permissionsInput = {
    where?: auth_userWhereInput
    data: XOR<auth_userUpdateWithoutAuth_user_user_permissionsInput, auth_userUncheckedUpdateWithoutAuth_user_user_permissionsInput>
  }

  export type auth_userUpdateWithoutAuth_user_user_permissionsInput = {
    password?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_superuser?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_staff?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    auth_user_groups?: auth_user_groupsUpdateManyWithoutAuth_userNestedInput
    django_admin_log?: django_admin_logUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateWithoutAuth_user_user_permissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_superuser?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_staff?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    auth_user_groups?: auth_user_groupsUncheckedUpdateManyWithoutAuth_userNestedInput
    django_admin_log?: django_admin_logUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type django_content_typeCreateWithoutDjango_admin_logInput = {
    app_label: string
    model: string
    auth_permission?: auth_permissionCreateNestedManyWithoutDjango_content_typeInput
  }

  export type django_content_typeUncheckedCreateWithoutDjango_admin_logInput = {
    id?: number
    app_label: string
    model: string
    auth_permission?: auth_permissionUncheckedCreateNestedManyWithoutDjango_content_typeInput
  }

  export type django_content_typeCreateOrConnectWithoutDjango_admin_logInput = {
    where: django_content_typeWhereUniqueInput
    create: XOR<django_content_typeCreateWithoutDjango_admin_logInput, django_content_typeUncheckedCreateWithoutDjango_admin_logInput>
  }

  export type auth_userCreateWithoutDjango_admin_logInput = {
    password: string
    last_login?: Date | string | null
    is_superuser: boolean
    username: string
    first_name: string
    last_name: string
    email: string
    is_staff: boolean
    is_active: boolean
    date_joined: Date | string
    auth_user_groups?: auth_user_groupsCreateNestedManyWithoutAuth_userInput
    auth_user_user_permissions?: auth_user_user_permissionsCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateWithoutDjango_admin_logInput = {
    id?: number
    password: string
    last_login?: Date | string | null
    is_superuser: boolean
    username: string
    first_name: string
    last_name: string
    email: string
    is_staff: boolean
    is_active: boolean
    date_joined: Date | string
    auth_user_groups?: auth_user_groupsUncheckedCreateNestedManyWithoutAuth_userInput
    auth_user_user_permissions?: auth_user_user_permissionsUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userCreateOrConnectWithoutDjango_admin_logInput = {
    where: auth_userWhereUniqueInput
    create: XOR<auth_userCreateWithoutDjango_admin_logInput, auth_userUncheckedCreateWithoutDjango_admin_logInput>
  }

  export type django_content_typeUpsertWithoutDjango_admin_logInput = {
    update: XOR<django_content_typeUpdateWithoutDjango_admin_logInput, django_content_typeUncheckedUpdateWithoutDjango_admin_logInput>
    create: XOR<django_content_typeCreateWithoutDjango_admin_logInput, django_content_typeUncheckedCreateWithoutDjango_admin_logInput>
    where?: django_content_typeWhereInput
  }

  export type django_content_typeUpdateToOneWithWhereWithoutDjango_admin_logInput = {
    where?: django_content_typeWhereInput
    data: XOR<django_content_typeUpdateWithoutDjango_admin_logInput, django_content_typeUncheckedUpdateWithoutDjango_admin_logInput>
  }

  export type django_content_typeUpdateWithoutDjango_admin_logInput = {
    app_label?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    auth_permission?: auth_permissionUpdateManyWithoutDjango_content_typeNestedInput
  }

  export type django_content_typeUncheckedUpdateWithoutDjango_admin_logInput = {
    id?: IntFieldUpdateOperationsInput | number
    app_label?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    auth_permission?: auth_permissionUncheckedUpdateManyWithoutDjango_content_typeNestedInput
  }

  export type auth_userUpsertWithoutDjango_admin_logInput = {
    update: XOR<auth_userUpdateWithoutDjango_admin_logInput, auth_userUncheckedUpdateWithoutDjango_admin_logInput>
    create: XOR<auth_userCreateWithoutDjango_admin_logInput, auth_userUncheckedCreateWithoutDjango_admin_logInput>
    where?: auth_userWhereInput
  }

  export type auth_userUpdateToOneWithWhereWithoutDjango_admin_logInput = {
    where?: auth_userWhereInput
    data: XOR<auth_userUpdateWithoutDjango_admin_logInput, auth_userUncheckedUpdateWithoutDjango_admin_logInput>
  }

  export type auth_userUpdateWithoutDjango_admin_logInput = {
    password?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_superuser?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_staff?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    auth_user_groups?: auth_user_groupsUpdateManyWithoutAuth_userNestedInput
    auth_user_user_permissions?: auth_user_user_permissionsUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateWithoutDjango_admin_logInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_superuser?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_staff?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    date_joined?: DateTimeFieldUpdateOperationsInput | Date | string
    auth_user_groups?: auth_user_groupsUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_user_user_permissions?: auth_user_user_permissionsUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_permissionCreateWithoutDjango_content_typeInput = {
    name: string
    codename: string
    auth_group_permissions?: auth_group_permissionsCreateNestedManyWithoutAuth_permissionInput
    auth_user_user_permissions?: auth_user_user_permissionsCreateNestedManyWithoutAuth_permissionInput
  }

  export type auth_permissionUncheckedCreateWithoutDjango_content_typeInput = {
    id?: number
    name: string
    codename: string
    auth_group_permissions?: auth_group_permissionsUncheckedCreateNestedManyWithoutAuth_permissionInput
    auth_user_user_permissions?: auth_user_user_permissionsUncheckedCreateNestedManyWithoutAuth_permissionInput
  }

  export type auth_permissionCreateOrConnectWithoutDjango_content_typeInput = {
    where: auth_permissionWhereUniqueInput
    create: XOR<auth_permissionCreateWithoutDjango_content_typeInput, auth_permissionUncheckedCreateWithoutDjango_content_typeInput>
  }

  export type auth_permissionCreateManyDjango_content_typeInputEnvelope = {
    data: Enumerable<auth_permissionCreateManyDjango_content_typeInput>
    skipDuplicates?: boolean
  }

  export type django_admin_logCreateWithoutDjango_content_typeInput = {
    action_time: Date | string
    object_id?: string | null
    object_repr: string
    action_flag: number
    change_message: string
    auth_user: auth_userCreateNestedOneWithoutDjango_admin_logInput
  }

  export type django_admin_logUncheckedCreateWithoutDjango_content_typeInput = {
    id?: number
    action_time: Date | string
    object_id?: string | null
    object_repr: string
    action_flag: number
    change_message: string
    user_id: number
  }

  export type django_admin_logCreateOrConnectWithoutDjango_content_typeInput = {
    where: django_admin_logWhereUniqueInput
    create: XOR<django_admin_logCreateWithoutDjango_content_typeInput, django_admin_logUncheckedCreateWithoutDjango_content_typeInput>
  }

  export type django_admin_logCreateManyDjango_content_typeInputEnvelope = {
    data: Enumerable<django_admin_logCreateManyDjango_content_typeInput>
    skipDuplicates?: boolean
  }

  export type auth_permissionUpsertWithWhereUniqueWithoutDjango_content_typeInput = {
    where: auth_permissionWhereUniqueInput
    update: XOR<auth_permissionUpdateWithoutDjango_content_typeInput, auth_permissionUncheckedUpdateWithoutDjango_content_typeInput>
    create: XOR<auth_permissionCreateWithoutDjango_content_typeInput, auth_permissionUncheckedCreateWithoutDjango_content_typeInput>
  }

  export type auth_permissionUpdateWithWhereUniqueWithoutDjango_content_typeInput = {
    where: auth_permissionWhereUniqueInput
    data: XOR<auth_permissionUpdateWithoutDjango_content_typeInput, auth_permissionUncheckedUpdateWithoutDjango_content_typeInput>
  }

  export type auth_permissionUpdateManyWithWhereWithoutDjango_content_typeInput = {
    where: auth_permissionScalarWhereInput
    data: XOR<auth_permissionUpdateManyMutationInput, auth_permissionUncheckedUpdateManyWithoutDjango_content_typeInput>
  }

  export type auth_permissionScalarWhereInput = {
    AND?: Enumerable<auth_permissionScalarWhereInput>
    OR?: Enumerable<auth_permissionScalarWhereInput>
    NOT?: Enumerable<auth_permissionScalarWhereInput>
    id?: IntFilter<"auth_permission"> | number
    name?: StringFilter<"auth_permission"> | string
    content_type_id?: IntFilter<"auth_permission"> | number
    codename?: StringFilter<"auth_permission"> | string
  }

  export type django_admin_logUpsertWithWhereUniqueWithoutDjango_content_typeInput = {
    where: django_admin_logWhereUniqueInput
    update: XOR<django_admin_logUpdateWithoutDjango_content_typeInput, django_admin_logUncheckedUpdateWithoutDjango_content_typeInput>
    create: XOR<django_admin_logCreateWithoutDjango_content_typeInput, django_admin_logUncheckedCreateWithoutDjango_content_typeInput>
  }

  export type django_admin_logUpdateWithWhereUniqueWithoutDjango_content_typeInput = {
    where: django_admin_logWhereUniqueInput
    data: XOR<django_admin_logUpdateWithoutDjango_content_typeInput, django_admin_logUncheckedUpdateWithoutDjango_content_typeInput>
  }

  export type django_admin_logUpdateManyWithWhereWithoutDjango_content_typeInput = {
    where: django_admin_logScalarWhereInput
    data: XOR<django_admin_logUpdateManyMutationInput, django_admin_logUncheckedUpdateManyWithoutDjango_content_typeInput>
  }

  export type auth_group_permissionsCreateManyAuth_groupInput = {
    id?: bigint | number
    permission_id: number
  }

  export type auth_user_groupsCreateManyAuth_groupInput = {
    id?: bigint | number
    user_id: number
  }

  export type auth_group_permissionsUpdateWithoutAuth_groupInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    auth_permission?: auth_permissionUpdateOneRequiredWithoutAuth_group_permissionsNestedInput
  }

  export type auth_group_permissionsUncheckedUpdateWithoutAuth_groupInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_group_permissionsUncheckedUpdateManyWithoutAuth_groupInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_user_groupsUpdateWithoutAuth_groupInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    auth_user?: auth_userUpdateOneRequiredWithoutAuth_user_groupsNestedInput
  }

  export type auth_user_groupsUncheckedUpdateWithoutAuth_groupInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_user_groupsUncheckedUpdateManyWithoutAuth_groupInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_group_permissionsCreateManyAuth_permissionInput = {
    id?: bigint | number
    group_id: number
  }

  export type auth_user_user_permissionsCreateManyAuth_permissionInput = {
    id?: bigint | number
    user_id: number
  }

  export type auth_group_permissionsUpdateWithoutAuth_permissionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    auth_group?: auth_groupUpdateOneRequiredWithoutAuth_group_permissionsNestedInput
  }

  export type auth_group_permissionsUncheckedUpdateWithoutAuth_permissionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_group_permissionsUncheckedUpdateManyWithoutAuth_permissionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_user_user_permissionsUpdateWithoutAuth_permissionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    auth_user?: auth_userUpdateOneRequiredWithoutAuth_user_user_permissionsNestedInput
  }

  export type auth_user_user_permissionsUncheckedUpdateWithoutAuth_permissionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_user_user_permissionsUncheckedUpdateManyWithoutAuth_permissionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_user_groupsCreateManyAuth_userInput = {
    id?: bigint | number
    group_id: number
  }

  export type auth_user_user_permissionsCreateManyAuth_userInput = {
    id?: bigint | number
    permission_id: number
  }

  export type django_admin_logCreateManyAuth_userInput = {
    id?: number
    action_time: Date | string
    object_id?: string | null
    object_repr: string
    action_flag: number
    change_message: string
    content_type_id?: number | null
  }

  export type auth_user_groupsUpdateWithoutAuth_userInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    auth_group?: auth_groupUpdateOneRequiredWithoutAuth_user_groupsNestedInput
  }

  export type auth_user_groupsUncheckedUpdateWithoutAuth_userInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_user_groupsUncheckedUpdateManyWithoutAuth_userInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    group_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_user_user_permissionsUpdateWithoutAuth_userInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    auth_permission?: auth_permissionUpdateOneRequiredWithoutAuth_user_user_permissionsNestedInput
  }

  export type auth_user_user_permissionsUncheckedUpdateWithoutAuth_userInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type auth_user_user_permissionsUncheckedUpdateManyWithoutAuth_userInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type django_admin_logUpdateWithoutAuth_userInput = {
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: NullableStringFieldUpdateOperationsInput | string | null
    object_repr?: StringFieldUpdateOperationsInput | string
    action_flag?: IntFieldUpdateOperationsInput | number
    change_message?: StringFieldUpdateOperationsInput | string
    django_content_type?: django_content_typeUpdateOneWithoutDjango_admin_logNestedInput
  }

  export type django_admin_logUncheckedUpdateWithoutAuth_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: NullableStringFieldUpdateOperationsInput | string | null
    object_repr?: StringFieldUpdateOperationsInput | string
    action_flag?: IntFieldUpdateOperationsInput | number
    change_message?: StringFieldUpdateOperationsInput | string
    content_type_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type django_admin_logUncheckedUpdateManyWithoutAuth_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: NullableStringFieldUpdateOperationsInput | string | null
    object_repr?: StringFieldUpdateOperationsInput | string
    action_flag?: IntFieldUpdateOperationsInput | number
    change_message?: StringFieldUpdateOperationsInput | string
    content_type_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type auth_permissionCreateManyDjango_content_typeInput = {
    id?: number
    name: string
    codename: string
  }

  export type django_admin_logCreateManyDjango_content_typeInput = {
    id?: number
    action_time: Date | string
    object_id?: string | null
    object_repr: string
    action_flag: number
    change_message: string
    user_id: number
  }

  export type auth_permissionUpdateWithoutDjango_content_typeInput = {
    name?: StringFieldUpdateOperationsInput | string
    codename?: StringFieldUpdateOperationsInput | string
    auth_group_permissions?: auth_group_permissionsUpdateManyWithoutAuth_permissionNestedInput
    auth_user_user_permissions?: auth_user_user_permissionsUpdateManyWithoutAuth_permissionNestedInput
  }

  export type auth_permissionUncheckedUpdateWithoutDjango_content_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    codename?: StringFieldUpdateOperationsInput | string
    auth_group_permissions?: auth_group_permissionsUncheckedUpdateManyWithoutAuth_permissionNestedInput
    auth_user_user_permissions?: auth_user_user_permissionsUncheckedUpdateManyWithoutAuth_permissionNestedInput
  }

  export type auth_permissionUncheckedUpdateManyWithoutDjango_content_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    codename?: StringFieldUpdateOperationsInput | string
  }

  export type django_admin_logUpdateWithoutDjango_content_typeInput = {
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: NullableStringFieldUpdateOperationsInput | string | null
    object_repr?: StringFieldUpdateOperationsInput | string
    action_flag?: IntFieldUpdateOperationsInput | number
    change_message?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUpdateOneRequiredWithoutDjango_admin_logNestedInput
  }

  export type django_admin_logUncheckedUpdateWithoutDjango_content_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: NullableStringFieldUpdateOperationsInput | string | null
    object_repr?: StringFieldUpdateOperationsInput | string
    action_flag?: IntFieldUpdateOperationsInput | number
    change_message?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type django_admin_logUncheckedUpdateManyWithoutDjango_content_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    object_id?: NullableStringFieldUpdateOperationsInput | string | null
    object_repr?: StringFieldUpdateOperationsInput | string
    action_flag?: IntFieldUpdateOperationsInput | number
    change_message?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}